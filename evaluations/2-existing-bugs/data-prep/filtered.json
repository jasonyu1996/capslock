[
  {
    "advisory": {
      "id": "RUSTSEC-2021-0114",
      "package": "nanorand",
      "date": "2021-09-23",
      "url": "https://github.com/Absolucy/nanorand-rs/issues/28",
      "keywords": [
        "memory-safety",
        "aliasing"
      ],
      "aliases": [
        "CVE-2021-45705",
        "GHSA-p6gj-gpc8-f8xw",
        "GHSA-r57r-j98g-587f"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "affected": {
      "functions": {
        "nanorand::tls::tls_rand": [
          ">= 0.5.0",
          "<= 0.6.0"
        ]
      }
    },
    "text": "\n\n# Aliased mutable references from `tls_rand` & `TlsWyRand`\n\n`TlsWyRand`'s implementation of `Deref` unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.\n",
    "likely_poc": [
      "https://github.com/Absolucy/nanorand-rs/issues/28"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0129",
      "package": "kekbit",
      "date": "2020-12-18",
      "url": "https://github.com/motoras/kekbit/issues/34",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36449",
        "GHSA-g83m-67wh-whpw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.4"
      ]
    },
    "text": "\n\n# ShmWriter allows sending non-Send type across threads\n\nAffected versions of this crate implement `Send` for `ShmWriter<H>` without requiring `H: Send`. This allows users to send `H: !Send` to other threads, which can potentially lead to data races and undefined behavior.\n",
    "likely_poc": [
      "https://github.com/motoras/kekbit/issues/34"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0014",
      "package": "marc",
      "aliases": [
        "CVE-2021-26308",
        "GHSA-3mf3-2gv9-h39j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-26",
      "url": "https://github.com/blackbeam/rust-marc/issues/7",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# Record::read : Custom `Read` on uninitialized buffer may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. (`Record::read()`)\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 6299af0 by zero-initializing the newly allocated memory (via `data.resize(len, 0)`) instead of exposing uninitialized memory (`unsafe { data.set_len(len) }`).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0133",
      "package": "scottqueue",
      "date": "2020-11-15",
      "url": "https://github.com/rossdylan/rust-scottqueue/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36453",
        "GHSA-gvvv-w559-2hg6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Queue<T> should have a Send bound on its Send/Sync traits\n\nAffected versions of this crate unconditionally implements `Send`/`Sync` for `Queue<T>`.\n\nThis allows (1) creating data races to a `T: !Sync` and (2) sending `T: !Send` to other threads, resulting in memory corruption or other undefined behavior.\n",
    "likely_poc": [
      "https://github.com/rossdylan/rust-scottqueue/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0113",
      "package": "metrics-util",
      "date": "2021-04-07",
      "url": "https://github.com/metrics-rs/metrics/issues/190",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2021-45704",
        "GHSA-3hxh-7jxm-59x4",
        "GHSA-cwvc-87xq-pc5m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# AtomicBucket<T> unconditionally implements Send/Sync\n\nIn the affected versions of the crate, `AtomicBucket<T>` unconditionally implements `Send`/`Sync` traits. Therefore, users can create a data race to the inner\n`T: !Sync` by using the `AtomicBucket::data_with()` API.\nSuch data races can potentially cause memory corruption or other undefined behavior.\n\nThe flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct `Block<T>` (which is a data type contained inside `AtomicBucket<T>`).\n",
    "likely_poc": [
      "https://github.com/metrics-rs/metrics/issues/190"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0134",
      "package": "parc",
      "date": "2020-11-14",
      "url": "https://github.com/hyyking/rustracts/pull/6",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36454",
        "GHSA-29v7-3v4c-gf38",
        "GHSA-xwxc-j97j-84gf"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `LockWeak<T>` allows to create data race to `T`.\n\nIn the affected versions of this crate, `LockWeak<T>` unconditionally implemented `Send` with no trait bounds on `T`. `LockWeak<T>` doesn't own `T` and only provides `&T`.\n\nThis allows concurrent access to a non-Sync `T`, which can cause undefined behavior like data races.\n",
    "likely_poc": [
      "https://github.com/hyyking/rustracts/pull/6"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0154",
      "package": "buffoon",
      "date": "2020-12-31",
      "url": "https://github.com/carllerche/buffoon/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36512",
        "GHSA-hmx9-jm3v-33hv",
        "GHSA-v938-qcc9-rwv8"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# InputStream::read_exact : `Read` on uninitialized buffer causes UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0048",
      "package": "actix-http",
      "aliases": [
        "CVE-2020-35901",
        "GHSA-v3j6-xf77-8r9c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-24",
      "url": "https://github.com/actix/actix-web/issues/1321"
    },
    "versions": {
      "patched": [
        ">= 2.0.0-alpha.1"
      ]
    },
    "text": "\n\n# Use-after-free in BodyStream due to lack of pinning\n\nAffected versions of this crate did not require the buffer wrapped in `BodyStream` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the trait `MessageBody` require `Unpin`\nand making `poll_next()` function accept `Pin<&mut Self>` instead of `&mut self`.\n",
    "likely_poc": [
      "https://github.com/actix/actix-web/issues/1321"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0015",
      "package": "calamine",
      "aliases": [
        "CVE-2021-26951",
        "GHSA-ppqp-78xx-3r38"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-06",
      "url": "https://github.com/tafia/calamine/issues/199",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.17.0"
      ]
    },
    "text": "\n\n# `Sectors::get` accesses unclaimed/uninitialized memory\n\nAffected versions of this crate arbitrarily calls `Vec::set_len` to increase length of a vector without claiming more memory for the vector. Affected versions of this crate\nalso calls user-provided `Read` on the uninitialized memory of the vector that was\nextended with `Vec::set_len`.\n\nThis can overwrite active entities in adjacent heap memory and seems to be a major security issue. Also, calling user-provided `Read` on uninitialized memory is defined as UB in Rust.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0131",
      "package": "brotli-sys",
      "date": "2021-12-20",
      "url": "https://github.com/bitemyapp/brotli2-rs/issues/45",
      "references": [
        "https://github.com/google/brotli/releases/tag/v1.0.9"
      ],
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "CVE-2020-8927"
      ]
    },
    "affected": {},
    "versions": {
      "patched": []
    },
    "text": "\n# Integer overflow in the bundled Brotli C library\n\nA buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nAn updated version of `brotli-sys` has not been released. If one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.\n\nIn Rust the issue can be mitigated by migrating to the `brotli` crate, which provides a Rust implementation of Brotli compression and decompression that is not affected by this issue.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0119",
      "package": "nix",
      "date": "2021-09-27",
      "url": "https://github.com/nix-rust/nix/issues/1541",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "nss"
      ],
      "aliases": [
        "CVE-2021-45707",
        "GHSA-76w9-p8mg-j927",
        "GHSA-wgrg-5h56-jg27"
      ]
    },
    "versions": {
      "patched": [
        "^0.20.2",
        "^0.21.2",
        "^0.22.2",
        ">= 0.23.0"
      ],
      "unaffected": [
        "< 0.16.0"
      ]
    },
    "affected": {
      "os": [
        "linux",
        "freebsd",
        "android",
        "netbsd",
        "dragonfly",
        "openbsd",
        "fuchsia"
      ],
      "functions": {
        "nix::unistd::getgrouplist": [
          ">= 0.16.0"
        ]
      }
    },
    "text": "\n\n# Out-of-bounds write in nix::unistd::getgrouplist\n\nOn certain platforms, if a user has more than 16 groups, the\n`nix::unistd::getgrouplist` function will call the libc `getgrouplist`\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.\n\nThe libc `getgrouplist` function takes an in/out parameter `ngroups`\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the requested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify `ngroups`\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of `nix::unistd::getgrouplist` in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the `ngroups` variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n`getgrouplist` will then write past the end of the buffer.\n\nThe issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.\n",
    "likely_poc": [
      "https://github.com/nix-rust/nix/issues/1541"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0087",
      "package": "columnar",
      "date": "2021-01-07",
      "url": "https://github.com/frankmcsherry/columnar/issues/6",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45685",
        "GHSA-9mp7-45qh-r8j8",
        "GHSA-cxcc-q839-2cw9"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# columnar: `Read` on uninitialized buffer may cause UB (ColumnarReadExt::read_typed_vec())\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (`ColumnarReadExt::read_typed_vec()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0114",
      "package": "va-ts",
      "aliases": [
        "CVE-2020-36220",
        "GHSA-3hj2-hh36-hv9v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-22",
      "url": "https://github.com/video-audio/va-ts/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.0.4"
      ]
    },
    "text": "\n\n# `Demuxer` can carry non-Send types across thread boundaries\n\nIn the affected versions of this crate, `Demuxer<T>` unconditionally implemented `Send` with no trait bounds on `T`.\n\nThis allows sending a non-Send type `T` across thread boundaries, which can cause undefined behavior like unlocking a mutex from a thread that didn't lock the mutex, or memory corruption from data race.\n\nThe flaw was corrected in commit 0562cbf by adding a `T: Send` bound to the `Send` impl for `Demuxer<T>`.\n",
    "likely_poc": [
      "https://github.com/video-audio/va-ts/issues/4"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0092",
      "package": "concread",
      "aliases": [
        "CVE-2020-35928",
        "GHSA-4xj5-vv9x-63jp"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-13",
      "url": "https://github.com/kanidm/concread/issues/48",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.2.6"
      ]
    },
    "text": "\n\n# Send/Sync bound needed on V in `impl Send/Sync for ARCache<K, V>`\n\nAffected versions of this crate unconditionally implemented `Send`/`Sync` traits for `ARCache<K, V>` type.\n\nThis allows users to send/access types that do not implement `Send`/`Sync`, which can cause a data race.\n\nThe flaw was corrected in the 0.2.6 release by adding bounds `K: Send + Sync` & `V: Send + Sync` to affected `Send`/`Sync` trait implementations.\n",
    "likely_poc": [
      "https://github.com/kanidm/concread/issues/48"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0090",
      "package": "ash",
      "date": "2021-01-07",
      "url": "https://github.com/MaikKlein/ash/issues/354",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45688",
        "GHSA-64wv-8vwp-xgw2",
        "GHSA-qj69-c89v-jwq2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.33.1"
      ]
    },
    "text": "\n\n# Reading on uninitialized memory may cause UB ( `util::read_spv()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": [
      "https://github.com/MaikKlein/ash/issues/354"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0121",
      "package": "abox",
      "date": "2020-11-10",
      "url": "https://github.com/SonicFrog/abox/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36441",
        "GHSA-r626-fc64-3q28"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# AtomicBox<T> implements Send/Sync for any `T: Sized`\n\nAffected versions of this crate implements `Send`/`Sync` for `AtomicBox<T>` without requiring `T: Send`/`T: Sync`. This allows to create data races to `T: !Sync` and send `T: !Send` to another thread.\n\nSuch behavior breaks the compile-time thread safety guarantees of Rust, and allows users to incur undefined behavior using safe Rust (e.g. memory corruption from data race).\n\nThe flaw was corrected in commit 34c2b9e by adding trait bound `T: Send` to `Send` impl for `AtomicBox<T>` and trait bound `T: Sync` to `Sync` impl for `AtomicBox<T>`.\n",
    "likely_poc": [
      "https://github.com/SonicFrog/abox/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0071",
      "package": "time",
      "date": "2020-11-18",
      "url": "https://github.com/time-rs/time/issues/293",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "keywords": [
        "segfault"
      ],
      "aliases": [
        "CVE-2020-26235",
        "GHSA-wcg3-cvx6-7396"
      ]
    },
    "affected": {
      "os": [
        "linux",
        "redox",
        "solaris",
        "android",
        "ios",
        "macos",
        "netbsd",
        "openbsd",
        "freebsd"
      ],
      "functions": {
        "time::at": [
          "^0.1"
        ],
        "time::at_utc": [
          "^0.1"
        ],
        "time::now": [
          "^0.1"
        ],
        "time::UtcOffset::local_offset_at": [
          "< 0.2.23"
        ],
        "time::UtcOffset::try_local_offset_at": [
          "< 0.2.23"
        ],
        "time::UtcOffset::current_local_offset": [
          "< 0.2.23"
        ],
        "time::UtcOffset::try_current_local_offset": [
          "< 0.2.23"
        ],
        "time::OffsetDateTime::now_local": [
          "< 0.2.23"
        ],
        "time::OffsetDateTime::try_now_local": [
          "< 0.2.23"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.2.23"
      ],
      "unaffected": [
        "=0.2.0",
        "=0.2.1",
        "=0.2.2",
        "=0.2.3",
        "=0.2.4",
        "=0.2.5",
        "=0.2.6"
      ]
    },
    "text": "\n\n# Potential segfault in the time crate\n\n### Impact\n\nThe affected functions set environment variables without synchronization. On Unix-like operating systems, this can crash in multithreaded programs. Programs may segfault due to dereferencing a dangling pointer if an environment variable is read in a different thread than the affected functions. This may occur without the user's knowledge, notably in the Rust standard library or third-party libraries.\n\nThe affected functions from time 0.2.7 through 0.2.22 are:\n\n- `time::UtcOffset::local_offset_at`\n- `time::UtcOffset::try_local_offset_at`\n- `time::UtcOffset::current_local_offset`\n- `time::UtcOffset::try_current_local_offset`\n- `time::OffsetDateTime::now_local`\n- `time::OffsetDateTime::try_now_local`\n\nThe affected functions in time 0.1 (all versions) are:\n\n- `time::at_utc`\n- `time::at`\n- `time::now`\n- `time::tzset`\n\nNon-Unix targets (including Windows and wasm) are unaffected.\n\n### Patches\n\nPending a proper fix, the internal method that determines the local offset has been modified to always return `None` on the affected operating systems. This has the effect of returning an `Err` on the `try_*` methods and `UTC` on the non-`try_*` methods.\n\nUsers and library authors with time in their dependency tree should perform `cargo update`, which will pull in the updated, unaffected code.\n\nUsers of time 0.1 do not have a patch and should upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.\n\n### Workarounds\n\nA possible workaround for crates affected through the transitive dependency in `chrono`, is to avoid using the default `oldtime` feature dependency of the `chrono` crate by disabling its `default-features` and manually specifying the required features instead.\n\n#### Examples:\n\n`Cargo.toml`:  \n\n```toml\nchrono = { version = \"0.4\", default-features = false, features = [\"serde\"] }\n```\n\n```toml\nchrono = { version = \"0.4.22\", default-features = false, features = [\"clock\"] }\n```\n\nCommandline:  \n\n```bash\ncargo add chrono --no-default-features -F clock\n```\n\nSources:  \n - [chronotope/chrono#602 (comment)](https://github.com/chronotope/chrono/issues/602#issuecomment-1242149249)  \n - [vityafx/serde-aux#21](https://github.com/vityafx/serde-aux/issues/21)  \n",
    "likely_poc": [
      "https://github.com/time-rs/time/issues/293"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0036",
      "package": "failure",
      "aliases": [
        "CVE-2019-25010",
        "CVE-2020-25575",
        "GHSA-jq66-xh47-j9f3",
        "GHSA-r98r-j25q-rmpr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-11-13",
      "informational": "unsound",
      "keywords": [
        "unsound"
      ],
      "url": "https://github.com/rust-lang-nursery/failure/issues/336"
    },
    "affected": {
      "functions": {
        "failure::Fail::__private_get_type_id__": [
          ">= 0.1.0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Type confusion if __private_get_type_id__ is overridden\n\nSafe Rust code can implement malfunctioning `__private_get_type_id__` and cause\ntype confusion when downcasting, which is an undefined behavior.\n\nUsers who derive `Fail` trait are not affected.\n",
    "likely_poc": [
      "https://github.com/rust-lang-nursery/failure/issues/336"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0068",
      "package": "capnp",
      "date": "2022-11-30",
      "url": "https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md",
      "references": [
        "https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html",
        "https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx"
      ],
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2022-46149",
        "GHSA-qqff-4vw4-f6hx"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.15.2",
        "^0.14.11",
        "^0.13.7"
      ]
    },
    "text": "\n\n# out-of-bounds read possible when setting list-of-pointers\n\nIf a message consumer expects data\nof type \"list of pointers\",\nand if the consumer performs certain specific actions on such data,\nthen a message producer can cause the consumer to read out-of-bounds memory.\nThis could trigger a process crash in the consumer,\nor in some cases could allow exfiltration of private in-memory data.\n\nThe C++ Cap'n Proto library is also affected by this bug.\nSee the [advisory](https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md)\non the main Cap'n Proto repo for a succinct description of\nthe exact circumstances in which the problem can arise.\n",
    "likely_poc": [
      "https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0086",
      "package": "lexical-core",
      "date": "2023-09-03",
      "informational": "unsound",
      "references": [
        "https://github.com/Alexhuszagh/rust-lexical/issues/102",
        "https://github.com/Alexhuszagh/rust-lexical/issues/101",
        "https://github.com/Alexhuszagh/rust-lexical/issues/95",
        "https://github.com/Alexhuszagh/rust-lexical/issues/104",
        "https://github.com/Alexhuszagh/rust-lexical/issues/126"
      ],
      "related": [
        "RUSTSEC-2023-0055"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n`RUSTSEC-2024-0377` contains multiple soundness issues:\n\n 1. [Bytes::read() allows creating instances of types with invalid bit patterns](https://github.com/Alexhuszagh/rust-lexical/issues/102)\n 1. [BytesIter::read() advances iterators out of bounds](https://github.com/Alexhuszagh/rust-lexical/issues/101)\n 1. [The `BytesIter` trait has safety invariants but is public and not marked `unsafe`](https://github.com/Alexhuszagh/rust-lexical/issues/104)\n 1. [`write_float()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/95)\n 1. [`radix()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/126)\n\nVersion 1.0 fixes these issues, removes the vast majority of `unsafe` code, and also fixes some correctness issues.\n",
    "likely_poc": [
      "https://github.com/Alexhuszagh/rust-lexical/issues/102",
      "https://github.com/Alexhuszagh/rust-lexical/issues/101",
      "https://github.com/Alexhuszagh/rust-lexical/issues/95",
      "https://github.com/Alexhuszagh/rust-lexical/issues/104"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0106",
      "package": "multiqueue2",
      "aliases": [
        "CVE-2020-36214",
        "GHSA-jphw-p3m6-pj3c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-19",
      "url": "https://github.com/abbychau/multiqueue2/issues/10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.1.7"
      ]
    },
    "text": "\n\n# Queues allow non-Send types to be sent to other threads, allowing data races\n\nAffected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.\n\nThe flaw was corrected in v0.1.7 by adding `T: Send` bound to to the `Send` impl of four data types explained above.\n",
    "likely_poc": [
      "https://github.com/abbychau/multiqueue2/issues/10"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0141",
      "package": "noise_search",
      "date": "2020-12-10",
      "url": "https://github.com/pipedown/noise/issues/72",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36461",
        "GHSA-wxjf-9f4g-3v44"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# MvccRwLock allows data races & aliasing violations\n\nAffected versions of this crate unconditionally implement Send/Sync for `MvccRwLock`.\nThis can lead to data races when types that are either `!Send` or `!Sync` (e.g. `Rc<T>`, `Arc<Cell<_>>`) are contained inside `MvccRwLock` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nAlso, safe APIs of `MvccRwLock` allow aliasing violations by allowing `&T` and `LockResult<MutexGuard<Box<T>>>` to co-exist in conflicting lifetime regions. The APIs of `MvccRwLock` should either be marked as `unsafe` or `MbccRwLock` should be changed to private or pub(crate).\n",
    "likely_poc": [
      "https://github.com/pipedown/noise/issues/72"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0027",
      "package": "bam",
      "aliases": [
        "CVE-2021-28027",
        "GHSA-cpqj-r29q-chrh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-07",
      "url": "https://gitlab.com/tprodanov/bam/-/issues/4",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ]
    },
    "affected": {
      "functions": {
        "bam::bgzip::Block::load": [
          "< 0.1.3"
        ]
      }
    },
    "text": "\n\n# Loading a bgzip block can write out of bounds if size overflows.\n\nAffected versions of `bam` set the length of an internal buffer using\n`self.compressed.set_len(block_size - HEADER_SIZE - MIN_EXTRA_SIZE)` and then\nwrote into it. While `block_size` was constrained to a proper maximum, when it\nwas too small the subtraction could overflow negatively to a large number past\nthe capacity of `self.compressed`.\n\nThis can result in memory corruption in the form of writing out of bounds when\nloading a `bgzip` file with a small `block_size`.\n\nCommit `061eee38d4` fixed this issue by checking for the underflow when setting\nthe buffer size.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0009",
      "package": "basic_dsp_matrix",
      "aliases": [
        "CVE-2021-25906",
        "GHSA-fjr6-hm39-4cf9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-10",
      "url": "https://github.com/liebharc/basic_dsp/issues/47",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.2"
      ]
    },
    "text": "\n\n# panic safety issue in `impl TransformContent<S, D> for [S; (2|3|4)]`\n\nAffected versions of this crate did not guard against double drop while temporarily duplicating objects' ownership using `ptr::read()`. Upon panic in a user-provided function `conversion`, objects that are copied by `ptr::read()` are dropped twice, leading to memory corruption.\n\nThe flaw was corrected in v0.9.2 by using `ManuallyDrop<T>` to enclose objects that are to be temporarily duplicated.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0022",
      "package": "hyper",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/hyperium/hyper/pull/2545",
      "aliases": [
        "GHSA-f67m-9j94-qv9j"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.14.12"
      ]
    },
    "text": "\n\n# Parser creates invalid uninitialized value\n\nAffected versions of this crate called `mem::uninitialized()` in the HTTP1 parser to create values of type `httparse::Header` (from the `httparse` crate).\nThis is unsound, since `Header` contains references and thus must be non-null.\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0010",
      "package": "containers",
      "aliases": [
        "CVE-2021-25907",
        "GHSA-cv7x-6rc6-pq5v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-12",
      "url": "https://github.com/strake/containers.rs/issues/2",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.11"
      ]
    },
    "text": "\n\n# panic safety: double drop may happen within `util::{mutate, mutate2}`\n\nUpon panic in a user-provided function `f`, `fn mutate()` & `fn mutate2` drops twice a same object.\n\nAffected versions of this crate did not guard against double drop while temporarily duplicating an object's ownership with `ptr::read()`.\n\nDropping a same object can result in memory corruption.\n\nThe flaw was corrected in version \"0.9.11\" by fixing the code to abort upon panic.\n",
    "likely_poc": [
      "https://github.com/strake/containers.rs/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0040",
      "package": "arenavec",
      "aliases": [
        "CVE-2021-29930",
        "CVE-2021-29931",
        "GHSA-327x-39hh-65wf",
        "GHSA-955p-rc5h-hg6h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-12",
      "url": "https://github.com/ibabushkin/arenavec/issues/1",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# panic safety: double drop or uninitialized drop of T upon panic\n\nAffected versions of this crate did not guard against potential panics that may happen from user-provided functions `T::default()` and `T::drop()`.\n\nPanic within `T::default()` leads to dropping uninitialized `T`, when it is invoked from `common::Slice::<T, H>::new()`.\nPanic within `T::drop()` leads to double drop of `T`, when it is invoked either from `common::SliceVec::<T, H>::resize_with()` or `common::SliceVec::<T, H>::resize()`\n\nEither case causes memory corruption in the heap memory.\n",
    "likely_poc": [
      "https://github.com/ibabushkin/arenavec/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0055",
      "package": "lexical",
      "date": "2023-09-03",
      "informational": "unsound",
      "references": [
        "https://github.com/Alexhuszagh/rust-lexical/issues/102",
        "https://github.com/Alexhuszagh/rust-lexical/issues/101",
        "https://github.com/Alexhuszagh/rust-lexical/issues/95",
        "https://github.com/Alexhuszagh/rust-lexical/issues/104",
        "https://github.com/Alexhuszagh/rust-lexical/issues/126"
      ],
      "aliases": [
        "GHSA-c2hm-mjxv-89r4"
      ]
    },
    "versions": {
      "patched": [
        ">= 7.0.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n`lexical` contains multiple soundness issues:\n\n 1. [Bytes::read() allows creating instances of types with invalid bit patterns](https://github.com/Alexhuszagh/rust-lexical/issues/102)\n 1. [BytesIter::read() advances iterators out of bounds](https://github.com/Alexhuszagh/rust-lexical/issues/101)\n 1. [The `BytesIter` trait has safety invariants but is public and not marked `unsafe`](https://github.com/Alexhuszagh/rust-lexical/issues/104)\n 1. [`write_float()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/95)\n 1. [`radix()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/126)\n\nThe crate also has some correctness issues.\n\n## Alternatives\n\nFor quickly parsing floating-point numbers third-party crates are no longer needed. A fast float parsing algorithm by the author of `lexical` has been [merged](https://github.com/rust-lang/rust/pull/86761) into libcore.\n\nFor quickly parsing integers, consider `atoi` and `btoi` crates (100% safe code). `atoi_radix10` provides even faster parsing, but only with `-C target-cpu=native`, and at the cost of some `unsafe`.\n\nFor formatting integers in a `#[no_std]` context consider the [`numtoa`](https://crates.io/crates/numtoa) crate.\n\nFor working with big numbers consider `num-bigint` and `num-traits`.\n",
    "likely_poc": [
      "https://github.com/Alexhuszagh/rust-lexical/issues/102",
      "https://github.com/Alexhuszagh/rust-lexical/issues/101",
      "https://github.com/Alexhuszagh/rust-lexical/issues/95",
      "https://github.com/Alexhuszagh/rust-lexical/issues/104"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0122",
      "package": "beef",
      "date": "2020-10-28",
      "url": "https://github.com/maciejhirsz/beef/issues/37",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36442",
        "GHSA-m7w4-8wp8-m2xq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# beef::Cow lacks a Sync bound on its Send trait allowing for data races\n\nAffected versions of this crate did not have a `T: Sync` bound in the `Send` impl for `Cow<'_, T, U>`. This allows users to create data races by making `Cow` contain types that are (Send && !Sync) like `Cell<_>` or `RefCell<_>`.\n\nSuch data races can lead to memory corruption.\n\nThe flaw was corrected in commit d1c7658 by adding trait bounds `T: Sync` and `T::Owned: Send` to the `Send` impl for `Cow<'_, T, U>`.\n",
    "likely_poc": [
      "https://github.com/maciejhirsz/beef/issues/37"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0346",
      "package": "zerovec-derive",
      "date": "2024-07-01",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.3",
        ">= 0.9.7, <0.10.0"
      ]
    },
    "text": "\n\n# Incorrect usage of `#[repr(packed)]`\n\nThe affected versions make unsafe memory accesses under the assumption that `#[repr(packed)]` has a guaranteed field order. \n\nThe Rust specification does not guarantee this, and https://github.com/rust-lang/rust/pull/125360 (1.80.0-beta) starts \nreordering fields of `#[repr(packed)]` structs, leading to illegal memory accesses.\n\nThe patched versions `0.9.7` and `0.10.3` use `#[repr(C, packed)]`, which guarantees field order.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0076",
      "package": "cpython",
      "date": "2023-11-14",
      "url": "https://github.com/dgrunwald/rust-cpython/commit/e815555",
      "references": [
        "https://github.com/dgrunwald/rust-cpython/issues/265",
        "https://github.com/dgrunwald/rust-cpython/issues/294"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `cpython` is unmaintained\n\nThe `cpython` crate and the underlying `python3-sys` and `python27-sys` crates have been marked as [no longer actively maintained] by the developer.\n\nThere are also open issues for unsound code that is currently in these crates:\n\n- [cpython#265]: Using some string functions causes segmentation faults on big-endian architectures. Due to incorrect bitfield manipulations, it is possible to create invalid Python objects that crash the Python interpreter.\n- [cpython#294]: Python 3.12 is not supported. Due to ABI changes in Python 3.12, calling some string functions will result in invalid Python objects and / or cause out-of-bounds memory accesses.\n\n## Recommended alternatives\n\n- [`pyo3`] (version 0.19.2 and newer)\n\nThe `pyo3` crate is actively maintained. Preliminary support for Python 3.12 was added in version 0.19.2, and version 0.20.0 was released with full support for Python 3.12.\n\nBoth versions implement string functions correctly on big-endian architectures. The endianness issue affecting the `cpython` crate was fixed in recent versions of `pyo3`.\n\n[no longer actively maintained]: https://github.com/dgrunwald/rust-cpython/commit/e815555\n[cpython#265]: https://github.com/dgrunwald/rust-cpython/issues/265\n[cpython#294]: https://github.com/dgrunwald/rust-cpython/issues/294\n[`pyo3`]: https://crates.io/crates/pyo3\n\n",
    "likely_poc": [
      "https://github.com/dgrunwald/rust-cpython/issues/265",
      "https://github.com/dgrunwald/rust-cpython/issues/294"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0105",
      "package": "abi_stable",
      "aliases": [
        "CVE-2020-36212",
        "CVE-2020-36213",
        "GHSA-vq23-5h4f-vwpv",
        "GHSA-wqxc-qrq4-w5v4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-21",
      "url": "https://github.com/rodrimati1992/abi_stable_crates/issues/44",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.1"
      ]
    },
    "text": "\n\n# Update unsound DrainFilter and RString::retain\n\nAffected versions of this crate contained code from the Rust standard library that contained soundness bugs rust-lang/rust#60977 (double drop) & rust-lang/rust#78498 (create invalid utf-8 string).\n\nThe flaw was corrected in v0.9.1 by making a similar fix to the one made in the Rust standard library.\n",
    "likely_poc": [
      "https://github.com/rodrimati1992/abi_stable_crates/issues/44"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0016",
      "package": "ms3d",
      "aliases": [
        "CVE-2021-26952",
        "GHSA-9f5r-vqm5-m342"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-26",
      "url": "https://github.com/andrewhickman/ms3d/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ]
    },
    "text": "\n\n# `IoReader::read()`: user-provided `Read` on uninitialized buffer may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 599313b by zero-initializing the buffer (via `self.buf.resize(len, 0)`) before passing it to `Read`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0019",
      "package": "tokio-rustls",
      "aliases": [
        "CVE-2020-35875",
        "GHSA-2jfv-g3fh-xq3v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-05-19",
      "keywords": [
        "tls",
        "ssl",
        "DoS"
      ],
      "url": "https://github.com/tokio-rs/tls/pull/14"
    },
    "versions": {
      "patched": [
        ">= 0.12.3, < 0.13.0",
        ">= 0.13.1"
      ],
      "unaffected": [
        "< 0.12"
      ]
    },
    "text": "\n\n# tokio-rustls reads may cause excessive memory usage\n\n`tokio-rustls` does not call `process_new_packets` immediately after `read`,\nso the expected termination condition `wants_read` always returns true.\nAs long as new incoming data arrives faster than it is processed\nand the reader does not return pending, data will be buffered.\n\nThis may cause DoS.\n",
    "likely_poc": [
      "https://github.com/tokio-rs/tls/pull/14"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0078",
      "package": "net2",
      "date": "2020-11-07",
      "url": "https://github.com/deprecrated/net2-rs/issues/105",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-35919",
        "CVE-2020-35920",
        "GHSA-458v-4hrf-g3m4",
        "GHSA-c79c-gwph-gqfm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.36"
      ]
    },
    "text": "\n\n# `net2` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`net2`](https://crates.io/crates/net2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": [
      "https://github.com/deprecrated/net2-rs/issues/105"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0094",
      "package": "rdiff",
      "date": "2021-02-03",
      "url": "https://github.com/dyule/rdiff/issues/3",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45694",
        "GHSA-2rxc-8f9w-fjq8",
        "GHSA-q579-9wp9-gfp2"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Window can read out of bounds if Read instance returns more bytes than buffer size\n\n`rdiff` performs a diff of two provided strings or files. As part of its reading\ncode it uses the return value of a `Read` instance to set the length of\nits internal character vector.\n\nIf the `Read` implementation claims that it has read more bytes than the length\nof the provided buffer, the length of the vector will be set to longer than its\ncapacity. This causes `rdiff` APIs to return uninitialized memory in its API\nmethods.\n",
    "likely_poc": [
      "https://github.com/dyule/rdiff/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0013",
      "package": "fake-static",
      "date": "2020-04-24",
      "aliases": [
        "GHSA-8xw8-mmqv-frqq"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# fake-static allows converting any reference into a `'static` reference\n\nfake-static allows converting a reference with any lifetime into\na reference with `'static` lifetime without the `unsafe` keyword.\n\nInternally, this crate does not use unsafe code, it instead\nexploits a soundness bug in rustc:\n\nhttps://github.com/rust-lang/rust/issues/25860\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0021",
      "package": "eyre",
      "date": "2024-03-05",
      "url": "https://github.com/eyre-rs/eyre/issues/141",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-4v52-7q2x-v4xj"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.12"
      ],
      "unaffected": [
        "< 0.6.9"
      ]
    },
    "affected": {
      "functions": {
        "eyre::Report::downcast": [
          ">= 0.6.9, < 0.6.12"
        ]
      }
    },
    "text": "\n\n# Parts of Report are dropped as the wrong type during downcast\n\nIn affected versions, after a `Report` is constructed using `wrap_err` or\n`wrap_err_with` to attach a message of type `D` onto an error of type `E`, then\nusing `downcast` to recover ownership of either the value of type `D` or the\nvalue of type `E`, one of two things can go wrong:\n\n- If downcasting to `E`, there remains a value of type `D` to be dropped. It is\n  incorrectly \"dropped\" by running `E`'s drop behavior, rather than `D`'s. For\n  example if `D` is `&str` and `E` is `std::io::Error`, there would be a call of\n  `std::io::Error::drop` in which the reference received by the `Drop` impl does\n  not refer to a valid value of type `std::io::Error`, but instead to `&str`.\n\n- If downcasting to `D`, there remains a value of type `E` to be dropped. When\n  `D` and `E` do not happen to be the same size, `E`'s drop behavior is\n  incorrectly executed in the wrong location. The reference received by the\n  `Drop` impl may point left or right of the real `E` value that is meant to be\n  getting dropped.\n\nIn both cases, when the `Report` contains an error `E` that has nontrivial drop\nbehavior, the most likely outcome is memory corruption.\n\nWhen the `Report` contains an error `E` that has trivial drop behavior (for\nexample a `Utf8Error`) but where `D` has nontrivial drop behavior (such as\n`String`), the most likely outcome is that downcasting to `E` would leak `D`.\n",
    "likely_poc": [
      "https://github.com/eyre-rs/eyre/issues/141"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0159",
      "package": "chrono",
      "date": "2020-11-10",
      "url": "https://github.com/chronotope/chrono/issues/499",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "keywords": [
        "segfault"
      ],
      "related": [
        "CVE-2020-26235",
        "RUSTSEC-2020-0071"
      ]
    },
    "versions": {
      "patched": [
        ">=0.4.20"
      ]
    },
    "text": "\n\n# Potential segfault in `localtime_r` invocations\n\n### Impact\n\nUnix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.\n\n### Workarounds\n\nNo workarounds are known.\n\n### References\n\n- [time-rs/time#293](https://github.com/time-rs/time/issues/293)\n",
    "likely_poc": [
      "https://github.com/chronotope/chrono/issues/499"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0137",
      "package": "lever",
      "date": "2020-11-10",
      "url": "https://github.com/vertexclique/lever/issues/15",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36457",
        "GHSA-9pp4-8p8v-g78w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.1"
      ]
    },
    "text": "\n\n# AtomicBox<T> lacks bound on its Send and Sync traits allowing data races\n\n`AtomicBox<T>` is a `Box` type designed to be used across threads, however, it\nimplements the `Send` and `Sync` traits for all types `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.\n",
    "likely_poc": [
      "https://github.com/vertexclique/lever/issues/15"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0043",
      "package": "ws",
      "aliases": [
        "CVE-2020-35896",
        "GHSA-rh7x-ppxx-p34c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-09-25",
      "keywords": [
        "websocket",
        "dos",
        "ddos",
        "oom",
        "memory",
        "remotely"
      ],
      "url": "https://github.com/housleyjk/ws-rs/issues/291"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Insufficient size checks in outgoing buffer in ws allows remote attacker to run the process out of memory\n\nAffected versions of this crate did not properly check and cap the growth of the outgoing buffer.\n\nThis allows a remote attacker to take down the process by growing the buffer of their (single) connection until the process runs out of memory it can allocate and is killed.\n\nThe flaw was corrected in the [`parity-ws` fork](https://crates.io/crates/parity-ws) (>=0.10.0) by [disconnecting a client when the buffer runs full](https://github.com/housleyjk/ws-rs/pull/328).\n",
    "likely_poc": [
      "https://github.com/housleyjk/ws-rs/issues/291"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0007",
      "package": "bitvec",
      "aliases": [
        "CVE-2020-35862",
        "GHSA-7cjc-hvxf-gqh7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-03-27",
      "url": "https://github.com/myrrlyn/bitvec/issues/55"
    },
    "affected": {
      "functions": {
        "bitvec::vec::BitVec::into_boxed_bitslice": [
          "< 0.17.4, >= 0.11.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.17.4"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# use-after or double free of allocated memory\n\nConversion of `BitVec` to `BitBox` did not account for allocation movement.\n\nThe flaw was corrected by using the address after resizing, rather than the original base address.\n",
    "likely_poc": [
      "https://github.com/myrrlyn/bitvec/issues/55"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0053",
      "package": "algorithmica",
      "date": "2021-03-07",
      "url": "https://github.com/AbrarNitk/algorithmica/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2021-31996",
        "GHSA-jh37-772x-4hpw"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# 'merge_sort::merge()' crashes with double-free for `T: Drop`\n\nIn the affected versions of this crate, `merge_sort::merge()` wildly duplicates and drops ownership of `T` without guarding against double-free. Due to such implementation,\nsimply invoking `merge_sort::merge()` on `Vec<T: Drop>` can cause **double free** bugs.\n",
    "likely_poc": [
      "https://github.com/AbrarNitk/algorithmica/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0043",
      "package": "uu_od",
      "aliases": [
        "CVE-2021-29934",
        "GHSA-w9vv-q986-vj7x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-17",
      "url": "https://github.com/uutils/coreutils/issues/1729",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.0.4"
      ]
    },
    "text": "\n\n# PartialReader passes uninitialized memory to user-provided Read\n\nAffected versions of this crate passed an uniniitalized buffer to a\nuser-provided `Read` instance in `PartialReader::read`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was fixed in commit [`39d62c6`](https://github.com/uutils/coreutils/commit/39d62c6c1f809022c903180471c10fde6ecd12d1)\nby zero-initializing the passed buffer.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0094",
      "package": "reffers",
      "aliases": [
        "CVE-2020-36203",
        "GHSA-39xg-8p43-h76x"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-01",
      "url": "https://github.com/diwic/reffers-rs/issues/7",
      "informational": "unsound",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Unsound: can make `ARefss` contain a !Send, !Sync object.\n\n`ARefss<'a, V>` is a type that is assumed to contain objects that are `Send + Sync`.\n\nIn the affected versions of this crate,\n`Send`/`Sync` traits are unconditionally implemented for `ARefss<'a, V>`.\n\nBy using the `ARefss::map()` API, we can insert a `!Send` or `!Sync` object into `ARefss<'a, V>`. After that, it is possible to create a data race to the inner object of `ARefss<'a, V>`, which can lead to undefined behavior & memory corruption.\n\nThe flaw was corrected in commit 6dd7ca0 (https://github.com/diwic/reffers-rs/commit/6dd7ca0d50f2464df708975cdafcfaeeb6d41c66) by adding trait bound `V: Send + Sync` to `ARefss::map()` API.\n",
    "likely_poc": [
      "https://github.com/diwic/reffers-rs/issues/7"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0032",
      "package": "ntru",
      "date": "2023-03-22",
      "url": "https://github.com/FrinkGlobal/ntru-rs/issues/8",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "ffi",
        "buffer overflow"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-fq33-vmhv-48xh"
      ]
    },
    "versions": {
      "patched": []
    },
    "affected": {
      "functions": {
        "ntru::types::PrivateKey::export": [
          ">= 0.4.3"
        ],
        "ntru::types::PublicKey::export": [
          ">= 0.4.3"
        ]
      }
    },
    "text": "\n\n# Unsound FFI: Wrong API usage causes write past allocated area\n\nThe following usage causes undefined behavior.\n```rust\nlet kp: ntru::types::KeyPair = \u2026;\nkp.get_public().export(Default::default())\n```\n\nWhen compiled with debug assertions, the code above will trigger a `attempt to subtract with overflow` panic before UB occurs.\nOther mistakes (e.g. using `EncParams` from a different key) may always trigger UB.\n\nLikely, older versions of this crate are also affected, but have not been tested.\n",
    "likely_poc": [
      "https://github.com/FrinkGlobal/ntru-rs/issues/8"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0119",
      "package": "ticketed_lock",
      "date": "2020-11-17",
      "url": "https://github.com/kvark/ticketed_lock/issues/7",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36439",
        "GHSA-77m6-x95j-75r5",
        "GHSA-gq4h-f254-7cw9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# ReadTicket and WriteTicket should only be sendable when T is Send\n\nAffected versions of this crate unconditionally implemented `Send` for `ReadTicket<T>` & `WriteTicket<T>`.\nThis allows to send non-Send `T` to other threads.\n\nThis can allows creating data races by cloning types with internal mutability and sending them to other threads (as `T` of `ReadTicket<T>`/`WriteTicket<T>`). Such data races can cause memory corruption or other undefined behavior.\n\nThe flaw was corrected in commit a986a93 by adding `T: Send` bounds to `Send` impls of `ReadTicket<T>`/`WriteTicket<T>`.\n",
    "likely_poc": [
      "https://github.com/kvark/ticketed_lock/issues/7"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0143",
      "package": "multiqueue",
      "date": "2020-12-25",
      "url": "https://github.com/schets/multiqueue/issues/31",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36463",
        "GHSA-jf43-3v8j-qwwr",
        "GHSA-r2x6-vrxx-jgv4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Queues allow non-Send types to be sent to other threads, allowing data races\n\nAffected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.\n",
    "likely_poc": [
      "https://github.com/schets/multiqueue/issues/31"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0006",
      "package": "ncurses",
      "aliases": [
        "CVE-2019-15547",
        "CVE-2019-15548",
        "GHSA-32v7-ghpr-c8hg",
        "GHSA-g7r5-x7cr-vm3v"
      ],
      "date": "2019-06-15",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    },
    "affected": {
      "functions": {
        "ncurses::instr": [
          ">= 0"
        ],
        "ncurses::mvprintw": [
          ">= 0"
        ],
        "ncurses::mvwinstr": [
          ">= 0"
        ],
        "ncurses::mvwprintw": [
          ">= 0"
        ],
        "ncurses::printw": [
          ">= 0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Buffer overflow and format vulnerabilities in functions exposed without unsafe\n\n`ncurses` exposes functions from the ncurses library which:\n\n- Pass buffers without length to C functions that may write an arbitrary amount of\n  data, leading to a buffer overflow. (`instr`, `mvwinstr`, etc)\n- Passes rust &str to strings expecting C format arguments, allowing hostile\n  input to execute a format string attack, which trivially allows writing\n  arbitrary data to stack memory (functions in the `printw` family).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0125",
      "package": "convec",
      "date": "2020-11-24",
      "url": "https://github.com/krl/convec/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36445",
        "GHSA-rpxm-vmr7-5f5f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# convec::ConVec<T> unconditionally implements Send/Sync\n\nAffected versions of this crate unconditionally implement Send/Sync for `ConVec<T>`.\nThis allows users to insert `T` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<_>>` or `Rc<_>` as `T` in `ConVec<T>`. It is also possible to create data races by using types like `Cell<_>` or `RefCell<_>` as `T` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.\n",
    "likely_poc": [
      "https://github.com/krl/convec/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0028",
      "package": "toodee",
      "aliases": [
        "CVE-2021-28028",
        "CVE-2021-28029",
        "GHSA-wcvp-r8j8-47pc",
        "GHSA-xm9m-2vj8-fmfr"
      ],
      "date": "2021-02-19",
      "url": "https://github.com/antonmarsden/toodee/issues/13",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "toodee::TooDee::insert_row": [
          "< 0.3.0"
        ]
      }
    },
    "text": "\n\n# Multiple memory safety issues in insert_row\n\nWhen inserting rows from an iterator at a particular index, `toodee` would shift\nitems over, duplicating their ownership. The space reserved for the new elements\nwas based on the `len()` returned by the `ExactSizeIterator`.\n\nThis could result in elements in the array being freed twice if the iterator\npanics. Uninitialized or previously freed elements could also be exposed if the\n`len()` didn't match the number of elements.\n\nThese issues were fixed in commit `ced70c17` by temporarily setting the length\nof the array smaller while processing it and adding assertions on the number\nof elements returned by the iterator.\n",
    "likely_poc": [
      "https://github.com/antonmarsden/toodee/issues/13"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0006",
      "package": "rmpv",
      "categories": [
        "denial-of-service"
      ],
      "date": "2017-11-21",
      "keywords": [
        "memory",
        "dos",
        "msgpack",
        "serialization",
        "deserialization"
      ],
      "url": "https://github.com/3Hren/msgpack-rust/issues/151",
      "aliases": [
        "GHSA-mcrf-7hf9-f6q5"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Unchecked vector pre-allocation\n\nAffected versions of this crate pre-allocate memory on deserializing raw\nbuffers without checking whether there is sufficient data available.\n\nThis allows an attacker to do denial-of-service attacks by sending small\nmsgpack messages that allocate gigabytes of memory.\n",
    "likely_poc": [
      "https://github.com/3Hren/msgpack-rust/issues/151"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0032",
      "package": "byte_struct",
      "aliases": [
        "CVE-2021-28033",
        "GHSA-8fgg-5v78-6g76"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-01",
      "url": "https://github.com/wwylele/byte-struct-rs/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Deserializing an array can drop uninitialized memory on panic\n\nThe `read_bytes_default_le` function for `[T; n]` arrays, used to deserialize\narrays of `T` from bytes created a `[T; n]` array with `std::mem::uninitialized`\nand then called `T`'s deserialization method.\n\nIf `T`'s deserialization method panicked, the uninitialized memory could drop\ninvalid objects.\n\nThis flaw was corrected in `a535678` by removing the unsafe block and using\na `.map` function to deserialize each element of the array instead.\n",
    "likely_poc": [
      "https://github.com/wwylele/byte-struct-rs/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0108",
      "package": "ckb",
      "date": "2021-07-25",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-48vq-8jqv-gm6f",
      "aliases": [
        "CVE-2021-45699",
        "GHSA-2969-8hh9-57jc",
        "GHSA-48vq-8jqv-gm6f"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.40.0"
      ]
    },
    "text": "\n\n# Remote memory exhaustion in ckb\n\nIn the ckb sync protocol, SyncState maintains a HashMap called 'misbehavior' that keeps a score of a peer's violations of the protocol. This HashMap is keyed to PeerIndex (an alias for SessionId), and entries are never removed from it. SessionId is an integer that increases monotonically with every new connection.\n\nA remote attacker can manipulate this HashMap to grow forever, resulting in degraded performance and ultimately a panic on allocation failure or being killed by the OS, depending on the platform.\n\nThis is a critical severity security bug. It could be exploited to create a targeted or network-wide denial of service, to reduce the hash power of the network as part of a 51% attack, and perhaps in other creative ways.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0091",
      "package": "arc-swap",
      "date": "2020-12-10",
      "url": "https://github.com/vorner/arc-swap/issues/45",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "dangling reference"
      ],
      "aliases": [
        "CVE-2020-35711",
        "GHSA-9pqx-g3jh-qpqq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.8, < 1.0.0-0",
        ">= 1.1.0"
      ],
      "unaffected": [
        "< 0.4.2"
      ]
    },
    "affected": {
      "functions": {
        "arc_swap::access::MapGuard::deref": [
          "< 1.1.0"
        ]
      }
    },
    "text": "\n\n# Dangling reference in `access::Map` with Constant\n\nUsing the `arc_swap::access::Map` with the `Constant` test helper (or with\nuser-provided implementation of the `Access` trait) could sometimes lead to the\nmap returning dangling references.\n\nReplaced by implementation without `unsafe`, at the cost of added `Clone` bound\non the closure and small penalty on performance.\n",
    "likely_poc": [
      "https://github.com/vorner/arc-swap/issues/45"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0113",
      "package": "atomic-option",
      "aliases": [
        "CVE-2020-36219",
        "GHSA-8gf5-q9p9-wvmc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-31",
      "url": "https://github.com/reem/rust-atomic-option/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# AtomicOption should have Send + Sync bound on its type argument.\n\nIn the affected versions of this crate,\n`AtomicOption<T>` unconditionally implements `Sync`.\n\nThis allows programmers to move non-Sync types across thread boundaries (e.g. `Rc<T>`, `Arc<Cell<T>>`), which can lead to data races and undefined behavior. \nIt is also possible to send non-Send types like `std::sync::MutexGuard` to other threads, which can lead to undefined behavior.\n",
    "likely_poc": [
      "https://github.com/reem/rust-atomic-option/issues/4"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0140",
      "package": "model",
      "date": "2020-11-10",
      "url": "https://github.com/spacejam/model/issues/3",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36460",
        "GHSA-mxv6-q98x-h958"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Shared` can cause a data race\n\n`Shared` data structure in `model` crate implements `Send` and `Sync` traits regardless of the inner type.\nThis allows safe Rust code to trigger a data race, which is undefined behavior in Rust.\n\nUsers are advised to treat `Shared` as an unsafe type.\nIt should not be used outside of the testing context,\nand care must be taken so that the testing code does not have a data race\nbesides a race condition that is expected to be caught by the test.\n\nCheck [the Rustonomicon](https://doc.rust-lang.org/nomicon/races.html) for the difference between\na data race and a general race condition.\n",
    "likely_poc": [
      "https://github.com/spacejam/model/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0030",
      "package": "scratchpad",
      "aliases": [
        "CVE-2021-28031",
        "GHSA-3qm2-rfqw-fmrw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-18",
      "url": "https://github.com/okready/scratchpad/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.3.1"
      ]
    },
    "affected": {
      "functions": {
        "scratchpad::SliceMoveSource::move_elements": [
          "< 1.3.1"
        ]
      }
    },
    "text": "\n\n# move_elements can double-free objects on panic\n\nAffected versions of `scratchpad` used `ptr::read` to read elements while\ncalling a user provided function `f` on them.\n\nSince the pointer read duplicates ownership, a panic inside the user provided\n`f` function could cause a double free when unwinding.\n\nThe flaw was fixed in commit `891561bea` by removing the unsafe block and using\na plain iterator.\n",
    "likely_poc": [
      "https://github.com/okready/scratchpad/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0012",
      "package": "smallvec",
      "aliases": [
        "CVE-2019-15554",
        "GHSA-69gw-hgj3-45m7"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "date": "2019-07-19",
      "url": "https://github.com/servo/rust-smallvec/issues/149"
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::grow": [
          "< 0.6.10, >= 0.6.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.10"
      ],
      "unaffected": [
        "< 0.6.3"
      ]
    },
    "text": "\n\n# Memory corruption in SmallVec::grow()\n\nAttempting to call `grow` on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.\n",
    "likely_poc": [
      "https://github.com/servo/rust-smallvec/issues/149"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0009",
      "package": "smallvec",
      "aliases": [
        "CVE-2019-15551",
        "GHSA-mm7v-vpv8-xfc3"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-06-06",
      "keywords": [
        "double free",
        "use after free",
        "arbitrary code execution"
      ],
      "url": "https://github.com/servo/rust-smallvec/issues/148"
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::grow": [
          "< 0.6.10, >= 0.6.5"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.10"
      ],
      "unaffected": [
        "< 0.6.5"
      ]
    },
    "text": "\n\n# Double-free and use-after-free in SmallVec::grow()\n\nAttempting to call `grow` on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.\n",
    "likely_poc": [
      "https://github.com/servo/rust-smallvec/issues/148"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0003",
      "package": "smallvec",
      "aliases": [
        "CVE-2018-20991",
        "GHSA-rxr4-x558-x7hw"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-07-19",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/servo/rust-smallvec/issues/96"
    },
    "versions": {
      "patched": [
        ">= 0.6.3",
        "^0.3.4",
        "^0.4.5",
        "^0.5.1"
      ],
      "unaffected": [
        "< 0.3.2"
      ]
    },
    "text": "\n\n# Possible double free during unwinding in SmallVec::insert_many\n\nIf an iterator passed to `SmallVec::insert_many` panicked in `Iterator::next`,\ndestructors were run during unwinding while the vector was in an inconsistent\nstate, possibly causing a double free (a destructor running on two copies of\nthe same value).\n\nThis is fixed in smallvec 0.6.3 by ensuring that the vector's length is not\nupdated to include moved items until they have been removed from their\noriginal positions.  Items may now be leaked if `Iterator::next` panics, but\nthey will not be dropped more than once.\n\nThank you to @Vurich for reporting this bug.\n",
    "likely_poc": [
      "https://github.com/servo/rust-smallvec/issues/96"
    ]
  },
  {
    "advisory": {
      "date": "2018-09-25",
      "id": "RUSTSEC-2018-0018",
      "package": "smallvec",
      "informational": "unsound",
      "url": "https://github.com/servo/rust-smallvec/issues/126",
      "aliases": [
        "CVE-2018-25023",
        "GHSA-55m5-whcv-c49c",
        "GHSA-66p5-j55p-32r9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.13"
      ]
    },
    "text": "\n\n# smallvec creates uninitialized value of any type\n\nAffected versions of this crate called `mem::uninitialized()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null and thus may not remain uninitialized).\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.\n",
    "likely_poc": [
      "https://github.com/servo/rust-smallvec/issues/126"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0003",
      "package": "smallvec",
      "aliases": [
        "CVE-2021-25900",
        "GHSA-43w2-9j62-hq99"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-08",
      "url": "https://github.com/servo/rust-smallvec/issues/252",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "buffer-overflow",
        "heap-overflow",
        "unsound"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.14, < 1.0.0",
        ">= 1.6.1"
      ],
      "unaffected": [
        "< 0.6.3"
      ]
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::insert_many": [
          ">= 0.6.3, < 0.6.14",
          ">= 1.0.0, < 1.6.1"
        ]
      }
    },
    "text": "\n\n# Buffer overflow in SmallVec::insert_many\n\nA bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.\n\nThis bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.\n \nThe flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.\n\nThank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Tech\u2019s SSLab for finding and reporting this bug.\n",
    "likely_poc": [
      "https://github.com/servo/rust-smallvec/issues/252"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0065",
      "package": "anymap",
      "date": "2021-05-07",
      "informational": "unmaintained",
      "url": "https://github.com/chris-morgan/anymap/issues/37",
      "aliases": [
        "CVE-2021-38187",
        "GHSA-hc92-9h3m-c39j"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# anymap is unmaintained.\n\nThe `anymap` crate does not appear to be maintained, and the most recent\npublished version 0.12.1 includes a soundness bug. This has been\n[fixed](https://github.com/chris-morgan/anymap/pull/32) a few years ago, but\nwas never released.\n",
    "likely_poc": [
      "https://github.com/chris-morgan/anymap/issues/37"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0146",
      "package": "generic-array",
      "date": "2020-04-09",
      "url": "https://github.com/fizyk20/generic-array/issues/98",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "soundness"
      ],
      "aliases": [
        "CVE-2020-36465",
        "GHSA-3358-4f7f-p4j4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.8.4, < 0.9.0",
        ">= 0.9.1, < 0.10.0",
        ">= 0.10.1, < 0.11.0",
        ">= 0.11.2, < 0.12.0",
        ">= 0.12.4, < 0.13.0",
        ">= 0.13.3"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n\n# arr! macro erases lifetimes\n\nAffected versions of this crate allowed unsoundly extending\nlifetimes using `arr!` macro. This may result in a variety of\nmemory corruption scenarios, most likely use-after-free.\n",
    "likely_poc": [
      "https://github.com/fizyk20/generic-array/issues/98"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0013",
      "package": "safe-transmute",
      "aliases": [
        "CVE-2018-21000",
        "GHSA-2v78-j59h-fmpf"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-11-27",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/nabijaczleweli/safe-transmute-rs/pull/36"
    },
    "versions": {
      "patched": [
        ">= 0.10.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Vec-to-vec transmutations could lead to heap overflow/corruption\n\nAffected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor,\nwhich could lead to memory corruption or data leakage.\n\nThe flaw was corrected by using the constructor correctly.\n",
    "likely_poc": [
      "https://github.com/nabijaczleweli/safe-transmute-rs/pull/36"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0020",
      "package": "whoami",
      "date": "2024-02-28",
      "url": "https://github.com/ardaku/whoami/issues/91",
      "categories": [
        "denial-of-service",
        "memory-corruption"
      ],
      "keywords": [
        "buffer-overflow",
        "stack-buffer-overflow",
        "cwe-121"
      ],
      "aliases": [
        "GHSA-w5w5-8vfh-xcjq"
      ]
    },
    "affected": {
      "os": [
        "illumos",
        "solaris",
        "dragonfly",
        "freebsd",
        "netbsd",
        "openbsd"
      ],
      "functions": {
        "whoami::username": [
          "< 1.5.0"
        ],
        "whoami::realname": [
          "< 1.5.0"
        ],
        "whoami::username_os": [
          "< 1.5.0"
        ],
        "whoami::realname_os": [
          "< 1.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.5.0"
      ],
      "unaffected": [
        "< 0.5.3"
      ]
    },
    "text": "\n\n# Stack buffer overflow with whoami on several Unix platforms\n\nWith versions of the whoami crate >= 0.5.3 and < 1.5.0, calling any of these functions leads to an\nimmediate stack buffer overflow on illumos and Solaris:\n\n- `whoami::username`\n- `whoami::realname`\n- `whoami::username_os`\n- `whoami::realname_os`\n\nWith versions of the whoami crate >= 0.5.3 and < 1.0.1, calling any of the above functions also\nleads to a stack buffer overflow on these platforms:\n\n- Bitrig\n- DragonFlyBSD\n- FreeBSD\n- NetBSD\n- OpenBSD\n\nThis occurs because of an incorrect definition of the `passwd` struct on those platforms.\n\nAs a result of this issue, denial of service and data corruption have both been observed in the\nwild. The issue is possibly exploitable as well.\n\nThis vulnerability also affects other Unix platforms that aren't Linux or macOS.\n\nThis issue has been addressed in whoami 1.5.0.\n\nFor more information, see [this GitHub issue](https://github.com/ardaku/whoami/issues/91).\n",
    "likely_poc": [
      "https://github.com/ardaku/whoami/issues/91"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0035",
      "package": "rand_core",
      "aliases": [
        "GHSA-mmc9-pwm7-qj5w",
        "CVE-2020-25576"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-04-19",
      "informational": "unsound",
      "url": "https://github.com/rust-random/rand/blob/master/rand_core/CHANGELOG.md#050---2019-06-06"
    },
    "affected": {
      "functions": {
        "rand_core::BlockRng::fill_bytes": [
          "< 0.4.2"
        ],
        "rand_core::BlockRng::next_u64": [
          "< 0.4.2"
        ]
      }
    },
    "versions": {
      "patched": [
        "^ 0.3.1",
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Unaligned memory access\n\nAffected versions of this crate violated alignment when casting byte slices to\ninteger slices, resulting in undefined behavior.\n\nThe flaw was corrected by Ralf Jung and Diggory Hardy.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0015",
      "package": "compact_arena",
      "aliases": [
        "CVE-2019-16139",
        "GHSA-7j36-gc4r-9x3r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-05-21",
      "keywords": [
        "uninitialized-memory"
      ],
      "url": "https://github.com/llogiq/compact_arena/issues/22"
    },
    "affected": {
      "functions": {
        "compact_arena::SmallArena::new": [
          "< 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Flaw in generativity allows out-of-bounds access\n\nAffected versions of this crate did not properly implement the generativity,\nbecause the invariant lifetimes were not necessarily `drop`ped.\n\nThis allows an attacker to mix up two arenas, using indices created from one\narena with another one. This might lead to an out-of-bounds read or write\naccess into the memory reserved for the arena.\n\nThe flaw was corrected by implementing generativity correctly in version 0.4.0.\n",
    "likely_poc": [
      "https://github.com/llogiq/compact_arena/issues/22"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0041",
      "package": "sized-chunks",
      "aliases": [
        "CVE-2020-25791",
        "CVE-2020-25792",
        "CVE-2020-25793",
        "CVE-2020-25794",
        "CVE-2020-25795",
        "CVE-2020-25796",
        "GHSA-64gv-qg2v-vxv6",
        "GHSA-9p9m-9xww-qjcx",
        "GHSA-fqpx-cq8x-9wp4",
        "GHSA-mp6f-p9gp-vpj9",
        "GHSA-rfgg-vccr-m46m",
        "GHSA-x54v-qxxr-93qc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-06",
      "url": "https://github.com/bodil/sized-chunks/issues/11"
    },
    "versions": {
      "patched": [
        ">= 0.6.3"
      ]
    },
    "text": "\n\n# Multiple soundness issues in Chunk and InlineArray\n\nChunk:\n\n* Array size is not checked when constructed with `unit()` and `pair()`.\n* Array size is not checked when constructed with `From<InlineArray<A, T>>`.\n* `Clone` and `insert_from` are not panic-safe; A panicking iterator causes memory safety issues with them.\n\nInlineArray:\n\n* Generates unaligned references for types with a large alignment requirement.\n",
    "likely_poc": [
      "https://github.com/bodil/sized-chunks/issues/11"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0020",
      "package": "libpulse-binding",
      "date": "2018-12-22",
      "url": "https://github.com/advisories/GHSA-6gvc-4jvj-pwq4",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2018-25001",
        "GHSA-6gvc-4jvj-pwq4",
        "GHSA-f56g-chqp-22m9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N"
    },
    "versions": {
      "patched": [
        ">= 2.5.0"
      ],
      "unaffected": [
        "< 1.0.5"
      ]
    },
    "text": "\n\n# Possible use-after-free with `proplist::Iterator`\n\nAffected versions contained a possible use-after-free issue with property list iteration\ndue to a lack of a lifetime constraint tying the lifetime of a `proplist::Iterator` to the\n`Proplist` object for which it was created. This made it possible for users, without\nexperiencing a compiler error/warning, to destroy the `Proplist` object before the iterator,\nthus destroying the underlying C object the iterator works upon, before the iterator may be\nfinished with it.\n\nThis impacts all versions of the crate before `2.5.0` back to `1.0.5`. Before version\n`1.0.5` the function that produces the iterator was broken to the point of being useless.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0021",
      "package": "libpulse-binding",
      "date": "2018-06-15",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2018-25027",
        "CVE-2018-25028",
        "GHSA-ghpq-vjxw-ch5w",
        "GHSA-hxjf-h2mh-r6hj",
        "GHSA-jqpv-jm4m-86j9"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.1"
      ]
    },
    "affected": {
      "functions": {
        "libpulse_binding::stream::Stream::get_format_info": [
          "< 1.2.1"
        ],
        "libpulse_binding::stream::Stream::get_context": [
          "< 1.2.1"
        ]
      }
    },
    "text": "\n\n# Use-after-free with objects returned by `Stream`'s `get_format_info` and `get_context` methods\n\nAffected versions contained a pair of use-after-free issues with the objects returned by the `get_format_info` and `get_context` methods of `Stream` objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0038",
      "package": "libpulse-binding",
      "date": "2019-03-10",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2019-25055",
        "GHSA-wcxc-jf6c-8rx9",
        "GHSA-xvcg-2q82-r87j"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.6.0"
      ]
    },
    "text": "\n\n# Fix for UB in failure to catch panics crossing FFI boundaries\n\nAffected versions of this crate failed to catch panics crossing FFI boundaries via callbacks, which\nis a form of UB. This flaw was corrected by [this commit][1] which was included in version 2.6.0.\n\n[1]: https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494\n",
    "likely_poc": [
      "https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0034",
      "package": "pkcs11",
      "date": "2022-07-22",
      "url": "https://github.com/mheese/rust-pkcs11/issues/57",
      "categories": [
        "code-execution",
        "memory-corruption",
        "crypto-failure"
      ],
      "keywords": [
        "segfault",
        "undefined behaviour"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# Safety issues in `pkcs11`\n\n### Impact\n\nThe interface of `pkcs11` is subject to a number of safety issues, mainly related to handling of raw pointers. Despite presenting a safe interface, many of the functions and methods that rely on inputs which contain pointers (attributes and mechanisms in particular) can lead to segmentation faults and undefined behaviour when those pointers get dereferenced. For more details see the issues referenced below.\n\nOther problems that have been identified by the community include use-after-free ([mheese/rust-pkcs11#53](https://github.com/mheese/rust-pkcs11/pull/53)) and unsound uses of `transmute_copy` ([mheese/rust-pkcs11#55](https://github.com/mheese/rust-pkcs11/issues/55)).\n\n### Workarounds\n\nUsers of the crate need to be _extremely_ careful in all the calls made to avoid segmentation faults and undefined behaviour due to use of stale pointers. Whenever a pointer is derived from a value and passed to the library, that value's lifetime must be guaranteed to outlast all calls that rely on the pointer. For example, users should **avoid** creating or converting values within a separate scope (say, in a dedicated function), deriving a pointer, then extracting the pointer from that scope leaving the value to get dropped before passing the pointer to `pkcs11`.\n\n### References\n\n- [mheese/rust-pkcs11#38](https://github.com/mheese/rust-pkcs11/issues/38)\n- [mheese/rust-pkcs11#53](https://github.com/mheese/rust-pkcs11/pull/53)\n- [mheese/rust-pkcs11#55](https://github.com/mheese/rust-pkcs11/issues/55)\n- [mheese/rust-pkcs11#54](https://github.com/mheese/rust-pkcs11/issues/54)\n- [mheese/rust-pkcs11#50](https://github.com/mheese/rust-pkcs11/issues/50)\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0115",
      "package": "zeroize_derive",
      "date": "2021-09-24",
      "url": "https://github.com/iqlusioninc/crates/issues/876",
      "aliases": [
        "CVE-2021-45706",
        "GHSA-c5hx-w945-j4pq"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.1"
      ]
    },
    "text": "\n\n# `#[zeroize(drop)]` doesn't implement `Drop` for `enum`s\n\nAffected versions of this crate did not implement `Drop` when `#[zeroize(drop)]` was used on an `enum`.\n\nThis can result in memory not being zeroed out after dropping it, which is exactly what is intended when adding this attribute.\n\nThe flaw was corrected in version 1.2 and `#[zeroize(drop)]` on `enum`s now properly implements `Drop`.\n",
    "likely_poc": [
      "https://github.com/iqlusioninc/crates/issues/876"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0150",
      "package": "disrustor",
      "date": "2020-12-17",
      "url": "https://github.com/sklose/disrustor/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36470",
        "GHSA-w9r2-qrpm-4rmj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3"
      ]
    },
    "text": "\n\n# RingBuffer can create multiple mutable references and cause data races\n\nThe `RingBuffer` type retrieves mutable references from the `DataProvider` in a\nnon-atomic manner, potentially allowing the creation of multiple mutable\nreferences. `RingBuffer` also implements the `Send` and `Sync` traits for all\ntypes `T`.\n\nThis allows undefined behavior from the aliased mutable references as well\nas data races.\n",
    "likely_poc": [
      "https://github.com/sklose/disrustor/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0342",
      "package": "vodozemac",
      "date": "2024-05-02",
      "url": "https://github.com/matrix-org/vodozemac/security/advisories/GHSA-c3hm-hxwf-g5c6",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2024-34063",
        "GHSA-c3hm-hxwf-g5c6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.0"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "text": "\n\n# Degraded secret zeroization capabilities \n\nVersions 0.5.0 and 0.5.1 of vodozemac have degraded secret zeroization capabilities,\ndue to changes in third-party cryptographic dependencies (the Dalek crates),\nwhich moved secret zeroization capabilities behind a feature flag while\nvodozemac disabled the default feature set.\n\n## Impact\n\nThe degraded zeroization capabilities could result in the production of more\nmemory copies of encryption secrets and secrets could linger in memory longer\nthan necessary. This marginally increases the risk of sensitive data exposure.\n\nOverall, we consider the impact of this issue to be low. Although cryptographic\nbest practices recommend the clearing of sensitive information from memory once\nit's no longer needed, the inherent limitations of Rust regarding absolute\nzeroization reduce the practical severity of this lapse.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0046",
      "package": "actix-service",
      "aliases": [
        "CVE-2020-35899",
        "GHSA-whc7-5p35-4ww2"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-08",
      "informational": "unsound",
      "url": "https://github.com/actix/actix-net/pull/158"
    },
    "versions": {
      "patched": [
        ">= 1.0.6"
      ]
    },
    "text": "\n\n# bespoke Cell implementation allows obtaining several mutable references to the same data\n\nThe custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.\n",
    "likely_poc": [
      "https://github.com/actix/actix-net/pull/158"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0049",
      "package": "through",
      "aliases": [
        "CVE-2021-29940",
        "GHSA-5hpj-m323-cphm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-18",
      "url": "https://github.com/gretchenfrage/through/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `through` and `through_and` causes a double free if the map function panics\n\n`through` and `through_and` take a mutable reference as well as a mapping\nfunction to change the provided reference. They do this by calling `ptr::read`\non the reference which duplicates ownership and then calling the mapping\nfunction.\n\nIf the mapping function panics, both the original object and the one\nduplicated by `ptr::read` get dropped, causing a double free.\n",
    "likely_poc": [
      "https://github.com/gretchenfrage/through/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0078",
      "package": "tracing",
      "date": "2023-10-19",
      "url": "https://github.com/tokio-rs/tracing/pull/2765",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ],
      "aliases": [
        "GHSA-8f24-6m29-wm2r"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.40"
      ],
      "unaffected": [
        "<= 0.1.37"
      ]
    },
    "affected": {
      "functions": {
        "tracing::instrument::Instrumented::into_inner": [
          ">= 0.1.38",
          "< 0.1.40"
        ]
      }
    },
    "text": "\n\n# Potential stack use-after-free in `Instrumented::into_inner`\n\nThe implementation of the [`Instrumented::into_inner`] method in affected\nversions of this crate contains undefined behavior due to incorrect use of\n[`std::mem::forget`] The function creates `*const` pointers to `self`, calls\n[`mem::forget(self)`][`std::mem::forget`], and then moves values out of those\npointers using [`std::ptr::read`].\n\n```rust\n// To manually destructure `Instrumented` without `Drop`, we\n// move it into a ManuallyDrop and use pointers to its fields\nlet span: *const Span = &this.span;\nlet inner: *const ManuallyDrop<T> = &this.inner;\nmem::forget(self);\n// SAFETY: Those pointers are valid for reads, because `Drop` didn't\n//         run, and properly aligned, because `Instrumented` isn't\n//         `#[repr(packed)]`.\nlet _span = unsafe { span.read() };\nlet inner = unsafe { inner.read() };\n```\n\nHowever, the [`mem::forget` documentation][`std::mem::forget`] states:\n\n> Any resources the value manages, such as heap memory or a file handle, will\n> linger forever in an unreachable state. **However, it does not guarantee that\n> pointers to this memory will remain valid.**\n\nThis means that these pointers are no longer valid. This could result in a stack\nuse-after-free if LLVM chooses to reuse `self`'s stack slot for a rebinding\nafter the call to [`std::mem::forget`].\n\nThis undefined behavior has not been observed to cause miscompilation as of Rust\n1.73.0. However, any use of this method with the affected versions of `tracing`\nare unsound.\n\nThe flaw was corrected in commit [20a1762] ([PR #2765]) by replacing the use of\n[`std::mem::forget`] with `std::mem::ManuallyDrop`, ensuring that the stack slot\nis not reused and the pointers remain valid when they are read. The fix is\npublished in `tracing` [v0.1.40]. Affected versions have been yanked from\ncrates.io.\n\nThanks to [Taylor Cramer] and [Manish Goregaokar] for finding and correcting\nthis issue!\n\n[`Instrumented::into_inner`]:\n    https://docs.rs/tracing/latest/tracing/instrument/struct.Instrumented.html#method.into_inner\n[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n[`std::ptr::read`]:\n    https://doc.rust-lang.org/std/primitive.pointer.html#method.read-1\n[20a1762]:\n    https://github.com/tokio-rs/tracing/commit/20a1762b3fd5f1fafead198fd18e469c68683721\n[PR #2765]: https://github.com/tokio-rs/tracing/pull/2765\n[v0.1.40]: https://crates.io/crates/tracing/0.1.40\n[Taylor Cramer]: https://github.com/cramertj\n[Manish Goregaokar]: https://github.com/manishearth\n",
    "likely_poc": [
      "https://github.com/tokio-rs/tracing/pull/2765"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0075",
      "package": "ark-r1cs-std",
      "date": "2021-07-08",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "r1cs",
        "zksnark",
        "arkworks"
      ],
      "url": "https://github.com/arkworks-rs/r1cs-std/pull/70",
      "aliases": [
        "CVE-2021-38194",
        "GHSA-qj3v-q2vj-4c8h"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "affected": {
      "functions": {
        "ark_r1cs_std::FieldVar::mul_by_inverse": [
          "< 0.3.0"
        ]
      }
    },
    "text": "\n\n# Flaw in `FieldVar::mul_by_inverse` allows unsound R1CS constraint systems\n\nVersions `0.2.0` to `0.3.0` of ark-r1cs-std did not enforce any constraints in the `FieldVar::mul_by_inverse` method, allowing a malicious prover to produce an unsound proof that passes all verifier checks.\nThis method was used primarily in scalar multiplication for [`short_weierstrass::ProjectiveVar`](https://docs.rs/ark-r1cs-std/0.3.0/ark_r1cs_std/groups/curves/short_weierstrass/struct.ProjectiveVar.html).\n\nThis bug was fixed in commit `47ddbaa`, and was released as part of version `0.3.1` on `crates.io`.\n",
    "likely_poc": [
      "https://github.com/arkworks-rs/r1cs-std/pull/70"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0070",
      "package": "lock_api",
      "aliases": [
        "CVE-2020-35910",
        "CVE-2020-35911",
        "CVE-2020-35912",
        "CVE-2020-35913",
        "CVE-2020-35914",
        "GHSA-5wg8-7c9q-794v",
        "GHSA-gmv4-vmx3-x9f3",
        "GHSA-hj9h-wrgg-hgmx",
        "GHSA-ppj3-7jw3-8vc4",
        "GHSA-vh4p-6j7g-f4j9"
      ],
      "date": "2020-11-08",
      "url": "https://github.com/Amanieu/parking_lot/pull/262",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "affected": {
      "functions": {
        "lock_api::MappedMutexGuard": [
          ">= 0.1.0"
        ],
        "lock_api::MappedRwLockReadGuard": [
          ">= 0.1.0"
        ],
        "lock_api::MappedRwLockWriteGuard": [
          ">= 0.1.0"
        ],
        "lock_api::RwLockReadGuard": [
          ">= 0.1.0"
        ],
        "lock_api::RwLockWriteGuard": [
          ">= 0.1.0"
        ]
      }
    },
    "text": "\n\n# Some lock_api lock guard objects can cause data races\n\nAffected versions of lock_api had unsound implementations of the `Send` or\n`Sync` traits for some guard objects, namely:\n\n* MappedMutexGuard\n* MappedRwLockReadGuard\n* MappedRwLockWriteGuard\n* RwLockReadGuard\n* RwLockWriteGuard\n\nThese guards could allow data races through types that are not safe to `Send`\nacross thread boundaries in safe Rust code.\n\nThis issue was fixed by changing the trait bounds on the `Mapped` guard types\nand removing the `Sync` trait for the `RwLock` guards.\n",
    "likely_poc": [
      "https://github.com/Amanieu/parking_lot/pull/262"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0013",
      "package": "libgit2-sys",
      "date": "2024-02-06",
      "url": "https://github.com/rust-lang/git2-rs/pull/1017",
      "references": [
        "https://github.com/libgit2/libgit2/releases/tag/v1.7.2"
      ],
      "categories": [
        "denial-of-service",
        "code-execution",
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
      "related": [
        "CVE-2024-24575",
        "CVE-2024-24577",
        "GHSA-54mf-x2rh-hq9v",
        "GHSA-j2v7-4f6v-gpg8"
      ],
      "aliases": [
        "GHSA-22q8-ghmq-63vf"
      ]
    },
    "affected": {
      "functions": {
        "libgit2_sys::git_revparse_single": [
          "< 0.16.2, >= 0.13.0"
        ],
        "libgit2_sys::git_index_add": [
          "< 0.16.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.16.2"
      ]
    },
    "text": "\n\n# Memory corruption, denial of service, and arbitrary code execution in libgit2\n\nThe [libgit2](https://github.com/libgit2/libgit2/) project fixed three security issues in the 1.7.2 release. These issues are:\n\n* The `git_revparse_single` function can potentially enter an infinite loop on a well-crafted input, potentially causing a Denial of Service. This function is exposed in the `git2` crate via the [`Repository::revparse_single`](https://docs.rs/git2/latest/git2/struct.Repository.html#method.revparse_single) method.\n* The `git_index_add` function may cause heap corruption and possibly lead to arbitrary code execution. This function is exposed in the `git2` crate via the [`Index::add`](https://docs.rs/git2/latest/git2/struct.Index.html#method.add) method.\n* The smart transport negotiation may experience an out-of-bounds read when a remote server did not advertise capabilities.\n\nThe `libgit2-sys` crate bundles libgit2, or optionally links to a system libgit2 library. In either case, versions of the libgit2 library less than 1.7.2 are vulnerable. The 0.16.2 release of `libgit2-sys` bundles the fixed version of 1.7.2, and requires a system libgit2 version of at least 1.7.2.\n\nIt is recommended that all users upgrade.\n",
    "likely_poc": [
      "https://github.com/rust-lang/git2-rs/pull/1017"
    ]
  },
  {
    "advisory": {
      "categories": [
        "denial-of-service",
        "memory-corruption"
      ],
      "date": "2020-01-16",
      "id": "RUSTSEC-2020-0002",
      "package": "prost",
      "aliases": [
        "CVE-2020-35858",
        "GHSA-gv73-9mwv-fwgq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "keywords": [
        "stack overflow"
      ],
      "url": "https://github.com/danburkert/prost/issues/267"
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Parsing a specially crafted message can result in a stack overflow\n\nAffected versions of this crate contained a bug in which decoding untrusted\ninput could overflow the stack.\n\nOn architectures with stack probes (like x86), this can be used for denial of\nservice attacks, while on architectures without stack probes (like ARM)\noverflowing the stack is unsound and can result in potential memory corruption\n(or even RCE).\n \nThe flaw was quickly corrected by @danburkert and released in version 0.6.1.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0007",
      "package": "asn1_der",
      "aliases": [
        "CVE-2019-15549",
        "GHSA-v5r6-6r3c-wqxc"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-06-13",
      "keywords": [
        "dos"
      ],
      "url": "https://github.com/KizzyCode/asn1_der/issues/1"
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ]
    },
    "text": "\n\n# Processing of maliciously crafted length fields causes memory allocation SIGABRTs\n\nAffected versions of this crate tried to preallocate a vector for an arbitrary amount of bytes announced by the ASN.1-DER length field without further checks.\n\nThis allows an attacker to trigger a SIGABRT by creating length fields that announce more bytes than the allocator can provide.\n \nThe flaw was corrected by not preallocating memory.\n",
    "likely_poc": [
      "https://github.com/KizzyCode/asn1_der/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0046",
      "package": "rocksdb",
      "date": "2022-05-11",
      "url": "https://github.com/rust-rocksdb/rust-rocksdb/pull/616",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "out-of-bounds read"
      ],
      "aliases": [
        "GHSA-xpp3-xrff-w6rh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.19.0"
      ]
    },
    "affected": {
      "functions": {
        "rocksdb::DBWithThreadMode::open_cf_descriptors_with_ttl": [
          "< 0.19.0"
        ]
      }
    },
    "text": "\n\n# Out-of-bounds read when opening multiple column families with TTL\n\nAffected versions of this crate called the RocksDB C API\n`rocksdb_open_column_families_with_ttl()` with a pointer to a single integer\nTTL value, but one TTL value for each column family is expected.\n\nThis is only relevant when using\n`rocksdb::DBWithThreadMode::open_cf_descriptors_with_ttl()` with multiple\ncolumn families.\n\nThis bug has been fixed in v0.19.0.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0072",
      "package": "tokio",
      "date": "2021-07-07",
      "url": "https://github.com/tokio-rs/tokio/issues/3929",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "race condition",
        "send"
      ],
      "aliases": [
        "CVE-2021-38191",
        "GHSA-2grh-hm3w-w7hv"
      ]
    },
    "affected": {
      "functions": {
        "tokio::task::JoinHandle::abort": [
          "<= 1.8.0, >= 0.3.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.5.1, < 1.6.0",
        ">= 1.6.3, < 1.7.0",
        ">= 1.7.2, < 1.8.0",
        ">= 1.8.1"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Task dropped in wrong thread when aborting `LocalSet` task\n\nWhen aborting a task with `JoinHandle::abort`, the future is dropped in the\nthread calling abort if the task is not currently being executed. This is\nincorrect for tasks spawned on a `LocalSet`.\n\nThis can easily result in race conditions as many projects use `Rc` or `RefCell`\nin their Tokio tasks for better performance.\n\nSee [tokio#3929][issue] for more details.\n\n[issue]: https://github.com/tokio-rs/tokio/issues/3929\n",
    "likely_poc": [
      "https://github.com/tokio-rs/tokio/issues/3929"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0005",
      "package": "tokio",
      "date": "2023-01-11",
      "url": "https://github.com/tokio-rs/tokio/issues/5372",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-4q83-7cq4-p6wg"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.18.5, < 1.19.0",
        ">= 1.20.4, < 1.21.0",
        ">= 1.24.2"
      ],
      "unaffected": [
        "< 0.2.0"
      ]
    },
    "text": "\n\n# `tokio::io::ReadHalf<T>::unsplit` is Unsound\n\n`tokio::io::ReadHalf<T>::unsplit` can violate the `Pin` contract\n\nThe soundness issue is described in the [tokio/issues#5372](https://github.com/tokio-rs/tokio/issues/5372)\n\nSpecific set of conditions needed to trigger an issue (a !Unpin type in ReadHalf)\nis unusual, combined with the difficulty of making any arbitrary use-after-free\nexploitable in Rust without doing a lot of careful alignment of data types in\nthe surrounding code.\n\nThe `tokio` feature `io-util` is also required to be enabled to trigger this\nsoundness issue.\n\nThanks to zachs18 reporting the issue to Tokio team responsibly and taiki-e\nand carllerche appropriately responding and fixing the soundness bug.\n\nTokio before 0.2.0 used `futures` 0.1 that did not have `Pin`, so it is not\naffected by this issue.\n",
    "likely_poc": [
      "https://github.com/tokio-rs/tokio/issues/5372"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0124",
      "package": "tokio",
      "aliases": [
        "CVE-2021-45710",
        "GHSA-fg7r-2g4j-5cgr"
      ],
      "date": "2021-11-16",
      "url": "https://github.com/tokio-rs/tokio/issues/4225",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "race condition"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.8.4, < 1.9.0",
        ">= 1.13.1"
      ],
      "unaffected": [
        "< 0.1.14"
      ]
    },
    "affected": {
      "functions": {
        "tokio::sync::oneshot::Receiver::close": [
          "<= 1.13.0, >= 0.1.14"
        ]
      }
    },
    "text": "\n\n# Data race when sending and receiving after closing a `oneshot` channel\n\nIf a `tokio::sync::oneshot` channel is closed (via the\n[`oneshot::Receiver::close`] method), a data race may occur if the\n`oneshot::Sender::send` method is called while the corresponding\n`oneshot::Receiver` is `await`ed or calling `try_recv`.\n\nWhen these methods are called concurrently on a closed channel, the two halves\nof the channel can concurrently access a shared memory location, resulting in a\ndata race. This has been observed to [cause memory corruption][corruption].\n\nNote that the race only occurs when **both** halves of the channel are used\nafter the `Receiver` half has called `close`. Code where `close` is not used, or where the\n`Receiver` is not `await`ed and `try_recv` is not called after calling `close`,\nis not affected.\n\nSee [tokio#4225][issue] for more details.\n\n[corruption]: https://github.com/tokio-rs/tokio/issues/4225#issuecomment-967434847\n[issue]: https://github.com/tokio-rs/tokio/issues/4225\n[`oneshot::Receiver::close`]: https://docs.rs/tokio/1.14.0/tokio/sync/oneshot/struct.Receiver.html#method.close\n",
    "likely_poc": [
      "https://github.com/tokio-rs/tokio/issues/4225"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0002",
      "package": "dashmap",
      "date": "2022-01-10",
      "url": "https://github.com/xacrimon/dashmap/issues/167",
      "categories": [
        "memory-exposure",
        "memory-corruption"
      ],
      "keywords": [
        "segfault",
        "use-after-free"
      ],
      "aliases": [
        "GHSA-mpg5-fvwp-42m2"
      ]
    },
    "affected": {
      "functions": {
        "dashmap::mapref::multiple::RefMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMulti::value": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMulti::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::pair_mut": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::value": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::pair_mut": [
          ">= 5.0.0"
        ],
        "dashmap::setref::multiple::RefMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::setref::one::Ref::key": [
          ">= 5.0.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 5.1.0"
      ],
      "unaffected": [
        "< 5.0.0"
      ]
    },
    "text": "\n\n# Unsoundness in `dashmap` references\n\nReference returned by some methods of `Ref` (and similar types) may outlive the `Ref` and escape the lock.\nThis causes undefined behavior and may result in a segfault.\n\nMore information in [`dashmap#167`](https://github.com/xacrimon/dashmap/issues/167) issue.\n",
    "likely_poc": [
      "https://github.com/xacrimon/dashmap/issues/167"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0011",
      "package": "memoffset",
      "aliases": [
        "CVE-2019-15553",
        "GHSA-rh89-x75f-rh3c"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2019-07-16",
      "informational": "unsound",
      "url": "https://github.com/Gilnaa/memoffset/issues/9#issuecomment-505461490"
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# Flaw in offset_of and span_of causes SIGILL, drops uninitialized memory of arbitrary type on panic in client code\n\nAffected versions of this crate caused traps and/or memory unsafety by zero-initializing references.\nThey also could lead to uninitialized memory being dropped if the field for which the offset is requested was behind a deref coercion, and that deref coercion caused a panic.\n\nThe flaw was corrected by using `MaybeUninit`.\n",
    "likely_poc": [
      "https://github.com/Gilnaa/memoffset/issues/9#issuecomment-505461490"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0045",
      "package": "memoffset",
      "date": "2023-06-21",
      "url": "https://github.com/Gilnaa/memoffset/issues/24",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memoffset",
        "offset"
      ],
      "aliases": [
        "GHSA-wfg4-322g-9vqv"
      ]
    },
    "affected": {
      "functions": {
        "memoffset::offset_of": [
          "< 0.6.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ]
    },
    "text": "\n\n# memoffset allows reading uninitialized memory\nmemoffset allows attempt of reading data from address `0` with arbitrary type. This behavior is an undefined behavior because address `0` to `std::mem::size_of<T>` may not have valid bit-pattern with `T`. Old implementation dereferences uninitialized memory obtained from `std::mem::align_of`. Older implementation prior to it allows using uninitialized data obtained from `std::mem::uninitialized` with arbitrary type then compute offset by taking the address of field-projection. This may also result in an undefined behavior for \"father\" that includes (directly or transitively) type that [does not allow to be uninitialized](https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html).\n\nThis flaw was corrected by using `std::ptr::addr_of` in <https://github.com/Gilnaa/memoffset/pull/50>.\n",
    "likely_poc": [
      "https://github.com/Gilnaa/memoffset/issues/24"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0155",
      "package": "acc_reader",
      "date": "2020-12-27",
      "url": "https://github.com/netvl/acc_reader/issues/1",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36513",
        "CVE-2020-36514",
        "GHSA-799f-r78p-gq9c",
        "GHSA-hv9v-7w3v-rj6f",
        "GHSA-p4cr-64x4-f92f"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Read` on uninitialized buffer in `fill_buf()` and `read_up_to()`\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0115",
      "package": "ruspiro-singleton",
      "date": "2020-11-16",
      "url": "https://github.com/RusPiRo/ruspiro-singleton/issues/10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36435",
        "GHSA-fqq2-xp7m-xvm8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# Singleton lacks bounds on Send and Sync.\n\n`Singleton<T>` is meant to be a static object that can be initialized lazily. In\norder to satisfy the requirement that `static` items must implement `Sync`,\n`Singleton` implemented both `Sync` and `Send` unconditionally.\n\nThis allows for a bug where non-`Sync` types such as `Cell` can be used in\nsingletons and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `b0d2bd20e` by adding trait bounds, requiring\nthe contaiend type to implement `Sync`.\n",
    "likely_poc": [
      "https://github.com/RusPiRo/ruspiro-singleton/issues/10"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0034",
      "package": "arr",
      "aliases": [
        "CVE-2020-35886",
        "CVE-2020-35887",
        "CVE-2020-35888",
        "GHSA-36xw-hgfv-jwm7",
        "GHSA-c7fw-cr3w-wvfc",
        "GHSA-fhvj-7f9p-w788"
      ],
      "date": "2020-08-25",
      "url": "https://github.com/sjep/array/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple security issues including data race, buffer overflow, and uninitialized memory drop\n\n`arr` crate contains multiple security issues. Specifically,\n\n1. It incorrectly implements Sync/Send bounds, which allows to smuggle non-Sync/Send types across the thread boundary.\n2. `Index` and `IndexMut` implementation does not check the array bound.\n3. `Array::new_from_template()` drops uninitialized memory.\n",
    "likely_poc": [
      "https://github.com/sjep/array/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0021",
      "package": "nb-connect",
      "aliases": [
        "CVE-2021-27376",
        "GHSA-rm4w-6696-r77p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-14",
      "url": "https://github.com/smol-rs/nb-connect/issues/1",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 1.0.3"
      ]
    },
    "text": "\n\n# `nb-connect` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`nb-connect`](https://crates.io/crates/nb-connect) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0054",
      "package": "mail-internals",
      "date": "2023-08-07",
      "url": "https://git.sr.ht/~nabijaczleweli/mail-internals.crate/commit/05443c864b204e7f1512caf2d53e8cce4dd340fc",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "mail",
        "mail-api"
      ],
      "aliases": [
        "GHSA-rcx8-48pc-v9q8"
      ]
    },
    "affected": {
      "functions": {
        "mail_internals::utils::vec_insert_bytes": [
          ">= 0.2.0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Use-after-free in `vec_insert_bytes`\nIncorrect reallocation logic in the function [`vec_insert_bytes`](https://docs.rs/mail-internals/0.2.3/mail_internals/utils/fn.vec_insert_bytes.html) causes a use-after-free.\n\nThis function does not have to be called directly to trigger the vulnerability because many methods on [`EncodingWriter`](https://docs.rs/mail-internals/0.2.3/mail_internals/encoder/struct.EncodingWriter.html) call this function internally.\n\nThe mail-\\* suite is unmaintained and the upstream sources have been actively vandalised.\nA fixed `mail-internals-ng` (and `mail-headers-ng` and `mail-core-ng`) crate has been published which fixes this, and a dependency on another unsound crate.\n",
    "likely_poc": [
      "https://git.sr.ht/~nabijaczleweli/mail-internals.crate/commit/05443c864b204e7f1512caf2d53e8cce4dd340fc"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0030",
      "package": "versionize",
      "date": "2023-03-24",
      "url": "https://github.com/firecracker-microvm/versionize/pull/53",
      "categories": [
        "memory-exposure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L",
      "aliases": [
        "CVE-2023-28448",
        "GHSA-8vxc-r5wp-vgvc"
      ]
    },
    "affected": {
      "os": [
        "linux"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.10"
      ]
    },
    "text": "\n\n# `Versionize::deserialize` implementation for `FamStructWrapper<T>` is lacking bound checks, potentially leading to out of bounds memory accesses \n\nAn issue was discovered in the `Versionize::deserialize` implementation provided by the `versionize` crate for `vmm_sys_util::fam::FamStructWrapper`, which can lead to out of bounds memory accesses. The impact started with version 0.1.1. The issue was corrected in version 0.1.10 by inserting a check that verifies, for any deserialized header, the lengths of compared flexible arrays are equal and aborting deserialization otherwise.\n",
    "likely_poc": [
      "https://github.com/firecracker-microvm/versionize/pull/53"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0022",
      "package": "ozone",
      "aliases": [
        "CVE-2020-35877",
        "CVE-2020-35878",
        "GHSA-m3ww-7hrp-gw9w",
        "GHSA-p2q9-9cq6-h3jw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-07-04"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Ozone contains several memory safety issues\n\nOzone contains several memory safety issues including [out-of-bound access](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/buffer.rs#L38-L48)\nand dropping of [uninitialized memory](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/map.rs#L94-L101).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0037",
      "package": "diesel",
      "aliases": [
        "CVE-2021-28305",
        "GHSA-j8q9-5rp9-4mv9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-05",
      "url": "https://github.com/diesel-rs/diesel/pull/2663",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use after free"
      ]
    },
    "affected": {
      "functions": {
        "diesel::SqliteConnection::query_by_name": [
          "< 1.4.6"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.4.6"
      ]
    },
    "text": "\n\n# Fix a use-after-free bug in diesels Sqlite backend\n\nWe've misused `sqlite3_column_name`. The\n[SQLite](https://www.sqlite.org/c3ref/column_name.html) documentation\nstates that the following:\n\n> The returned string pointer is valid until either the prepared statement\n> is destroyed by sqlite3_finalize() or until the statement is automatically\n> reprepared by the first call to sqlite3_step() for a particular\n> run or until the next call to sqlite3_column_name()\n> or sqlite3_column_name16() on the same column.\n\nAs part of our `query_by_name` infrastructure we've first received all\nfield names for the prepared statement and stored them as string slices\nfor later use. After that we called `sqlite3_step()` for the first time,\nwhich invalids the pointer and therefore the stored string slice.\n",
    "likely_poc": [
      "https://github.com/diesel-rs/diesel/pull/2663"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0061",
      "package": "libwebp-sys",
      "date": "2023-09-12",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "webp"
      ],
      "aliases": [
        "CVE-2023-4863",
        "CVE-2023-5129",
        "GHSA-j7hp-h8jx-5ppr"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.3"
      ]
    },
    "text": "\n\n# libwebp: OOB write in BuildHuffmanTable\n\n[Google](https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html) and [Mozilla](https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/) have released security advisories for RCE due to heap overflow in libwebp. Google warns the vulnerability has been exploited in the wild.\n\nlibwebp needs to be updated to 1.3.2 to include a patch for \"OOB write in BuildHuffmanTable\".\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0028",
      "package": "neon",
      "date": "2022-05-22",
      "url": "https://github.com/neon-bindings/neon/issues/896",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "incorrect-lifetime"
      ],
      "aliases": [
        "GHSA-8mj7-wxmc-f424"
      ]
    },
    "affected": {
      "functions": {
        "neon::types::JsArrayBuffer::external": [
          "< 0.10.1, >= 0.8.0"
        ],
        "neon::types::JsBuffer::external": [
          "< 0.10.1, >= 0.8.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.1"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n\n# Use after free in Neon external buffers\n\nNeon provides functionality for creating JavaScript `ArrayBuffer` (and the `Buffer` subtype) instances backed by bytes allocated outside of V8/Node. The [`JsArrayBuffer::external`](https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external) and [`JsBuffer::external`](https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external) did not require `T: 'static` prior to Neon `0.10.1`. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript `ArrayBuffer`.\n\nThe following example demonstrates use after free. It compiles on versions `<0.10.1` and fails to compile afterward.\n\n```rust\npub fn soundness_hole(mut cx: FunctionContext) -> JsResult<JsArrayBuffer> {\n    let mut data = vec![0u8, 1, 2, 3];\n    \n    // Creating an external from `&mut [u8]` instead of `Vec<u8>` since there is a blanket impl\n    // of `AsMut<T> for &mut T`\n    let buf = JsArrayBuffer::external(&mut cx, data.as_mut_slice());\n\n    // `buf` is still holding a reference to `data`!\n    drop(data);\n\n    Ok(buf)\n}\n```\n",
    "likely_poc": [
      "https://github.com/neon-bindings/neon/issues/896"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0080",
      "package": "miow",
      "aliases": [
        "CVE-2020-35921",
        "GHSA-jrcf-4jp8-m28v"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-13",
      "url": "https://github.com/yoshuawuyts/miow/issues/38",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        "^ 0.2.2",
        ">= 0.3.6"
      ]
    },
    "text": "\n\n# `miow` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`miow`](https://crates.io/crates/miow) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": [
      "https://github.com/yoshuawuyts/miow/issues/38"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0054",
      "package": "rkyv",
      "date": "2021-04-28",
      "url": "https://github.com/djkoloski/rkyv/issues/113",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "uninitialized",
        "memory",
        "information",
        "leak"
      ],
      "aliases": [
        "CVE-2021-31919",
        "GHSA-w5cr-frph-hw7f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.6.0"
      ]
    },
    "affected": {
      "functions": {
        "rkyv::Archive::resolve": [
          "< 0.6.0"
        ]
      }
    },
    "text": "\n\n# Archives may contain uninitialized memory\n\n`rkyv` is a serialization framework that writes struct-compatible memory to be stored or\ntransmitted. During serialization, struct padding bytes and unused enum bytes may not be\ninitialized. These bytes may be written to disk or sent over unsecured channels.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0044",
      "package": "openssl",
      "date": "2023-06-20",
      "url": "https://github.com/sfackler/rust-openssl/issues/1965",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "GHSA-xcf7-rvmh-g6q4"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::verify::X509VerifyParamRef::set_host": [
          "< 0.10.55, >=0.10.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.55"
      ]
    },
    "text": "\n\n# `openssl` `X509VerifyParamRef::set_host` buffer over-read\n\nWhen this function was passed an empty string, `openssl` would attempt to call `strlen` on it, reading arbitrary memory until it reached a NUL byte.\n",
    "likely_poc": [
      "https://github.com/sfackler/rust-openssl/issues/1965"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0022",
      "package": "openssl",
      "date": "2023-03-24",
      "url": "https://github.com/sfackler/rust-openssl/pull/1854",
      "categories": [
        "thread-safety"
      ],
      "aliases": [
        "GHSA-3gxf-9r58-2ghg"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::X509NameBuilder::build": [
          "< 0.10.48, >=0.9.7"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.48"
      ]
    },
    "text": "\n\n# `openssl` `X509NameBuilder::build` returned object is not thread safe\n\nOpenSSL has a `modified` bit that it can set on on `X509_NAME` objects. If this\nbit is set then the object is not thread-safe even when it appears the code is\nnot modifying the value.\n\nThanks to David Benjamin (Google) for reporting this issue.\n",
    "likely_poc": [
      "https://github.com/sfackler/rust-openssl/pull/1854"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0072",
      "package": "openssl",
      "date": "2023-11-23",
      "url": "https://github.com/sfackler/rust-openssl/issues/2096",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-xphf-cx8h-7q9g"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::store::X509StoreRef::objects": [
          "< 0.10.60, >=0.10.29"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.60"
      ]
    },
    "text": "\n\n# `openssl` `X509StoreRef::objects` is unsound\n\nThis function returned a shared reference into an OpenSSL datastructure but did not account for interior mutability. OpenSSL may modify the data behind this reference, meaning accesses can race and the reference is unsound.\n\nUse of this function should be replaced with `X509StoreRef::all_certificates`.\n",
    "likely_poc": [
      "https://github.com/sfackler/rust-openssl/issues/2096"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0010",
      "package": "openssl",
      "aliases": [
        "CVE-2018-20997",
        "GHSA-xjxc-vfw2-cg96"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-06-01",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/sfackler/rust-openssl/pull/942"
    },
    "versions": {
      "patched": [
        ">= 0.10.9"
      ],
      "unaffected": [
        "< 0.10.8"
      ]
    },
    "text": "\n\n# Use after free in CMS Signing\n\nAffected versions of the OpenSSL crate used structures after they'd been freed.\n",
    "likely_poc": [
      "https://github.com/sfackler/rust-openssl/pull/942"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0049",
      "package": "actix-codec",
      "aliases": [
        "CVE-2020-35902",
        "GHSA-rqgx-hpg4-456r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-30",
      "url": "https://github.com/actix/actix-net/issues/91"
    },
    "versions": {
      "patched": [
        ">= 0.3.0-beta.1"
      ]
    },
    "text": "\n\n# Use-after-free in Framed due to lack of pinning\n\nAffected versions of this crate did not require the buffer wrapped in `Framed` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the affected functions accept `Pin<&mut Self>` instead of `&mut self`.\n",
    "likely_poc": [
      "https://github.com/actix/actix-net/issues/91"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0019",
      "package": "actix-web",
      "categories": [
        "memory-corruption"
      ],
      "date": "2018-06-08",
      "url": "https://github.com/actix/actix-web/issues/289",
      "aliases": [
        "CVE-2018-25024",
        "CVE-2018-25025",
        "CVE-2018-25026",
        "GHSA-7x36-h62w-vw65",
        "GHSA-9qj6-4rfq-vm84",
        "GHSA-fgfm-hqjw-3265",
        "GHSA-w65j-g6c7-g3m4"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.15"
      ]
    },
    "text": "\n\n# Multiple memory safety issues\n\nAffected versions contain multiple memory safety issues, such as:\n\n - Unsoundly coercing immutable references to mutable references\n - Unsoundly extending lifetimes of strings\n - Adding the `Send` marker trait to objects that cannot be safely sent between threads\n\nThis may result in a variety of memory corruption scenarios, most likely use-after-free.\n \nA significant refactoring effort has been conducted to resolve these issues.\n",
    "likely_poc": [
      "https://github.com/actix/actix-web/issues/289"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0029",
      "package": "rgb",
      "aliases": [
        "CVE-2020-25016",
        "GHSA-g4rw-8m5q-6453"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "date": "2020-06-14",
      "informational": "unsound",
      "keywords": [
        "type confusion"
      ],
      "url": "https://github.com/kornelski/rust-rgb/issues/35"
    },
    "versions": {
      "patched": [
        ">= 0.8.20"
      ],
      "unaffected": [
        "< 0.5.4"
      ]
    },
    "text": "\n\n# Allows viewing and modifying arbitrary structs as bytes\n\nAffected versions of rgb crate allow viewing and modifying data of any type `T` wrapped in `RGB<T>` as bytes,\nand do not correctly constrain `RGB<T>` and other wrapper structures to the types for which it is safe to do so.\n\nSafety violation possible for a type wrapped in `RGB<T>` and similar wrapper structures:\n\n * If `T` contains padding, viewing it as bytes may lead to exposure of contents of uninitialized memory.\n * If `T` contains a pointer, modifying it as bytes may lead to dereferencing of arbitrary pointers.\n * Any safety and/or validity invariants for `T` may be violated.\n \nThe issue was resolved by requiring all types wrapped in structures provided by RGB crate to implement an unsafe marker trait.\n",
    "likely_poc": [
      "https://github.com/kornelski/rust-rgb/issues/35"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0132",
      "package": "compu-brotli-sys",
      "date": "2021-12-20",
      "url": "https://github.com/google/brotli/releases/tag/v1.0.9",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "CVE-2020-8927",
        "GHSA-5v8v-66v8-mwm7"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 1.0.9"
      ]
    },
    "text": "\n\n# Integer overflow in the bundled Brotli C library\n\nA buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nIf one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0035",
      "package": "quinn",
      "aliases": [
        "CVE-2021-28036",
        "GHSA-fhv4-fx3v-77w6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-03-04",
      "url": "https://github.com/quinn-rs/quinn/issues/968",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        "^0.5.4",
        "^0.6.2",
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# `quinn` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`quinn`](https://crates.io/crates/quinn) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": [
      "https://github.com/quinn-rs/quinn/issues/968"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0123",
      "package": "libp2p-deflate",
      "date": "2020-01-24",
      "url": "https://github.com/libp2p/rust-libp2p/issues/1932",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2020-36443",
        "GHSA-gvcp-948f-8f2p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.27.1"
      ]
    },
    "text": "\n\n# Contents of uninitialized memory exposed in DeflateOutput's AsyncRead implementation\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided trait function `AsyncRead::poll_read()`.\n\nArbitrary `AsyncRead::poll_read()` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 5ba266a by ensuring the newly allocated part of the buffer is zero-initialized before passing it to a user-provided `AsyncRead::poll_read()`.\n",
    "likely_poc": [
      "https://github.com/libp2p/rust-libp2p/issues/1932"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0046",
      "package": "cyfs-base",
      "date": "2023-06-15",
      "informational": "unsound",
      "url": "https://github.com/buckyos/CYFS/issues/275",
      "keywords": [
        "alignment",
        "unsound"
      ],
      "aliases": [
        "GHSA-g753-ghr7-q33w"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Misaligned pointer dereference in `ChunkId::new`\nThe function `ChunkId::new` creates a misaligned pointer by casting mutable pointer of `u8` slice which has alignment 1 to the mutable pointer of `u32` which has alignment 4, and dereference the misaligned pointer leading UB, which should not be allowed in safe function.\n",
    "likely_poc": [
      "https://github.com/buckyos/CYFS/issues/275"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0084",
      "package": "libp2p",
      "date": "2022-07-12",
      "url": "https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8",
      "aliases": [
        "CVE-2022-23486",
        "GHSA-jvgw-gccv-q5p8"
      ],
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.45.1"
      ]
    },
    "text": "\n# libp2p Lack of resource management DoS\n\nlibp2p allows a potential attacker to cause victim p2p node to run out of memory\n\nThe out of memory failure can cause crashes where libp2p is intended to be used\nwithin large scale networks leading to potential Denial of Service (DoS) vector\n\nUsers should upgrade or reference the [DoS mitigation strategies](https://docs.libp2p.io/reference/dos-mitigation/).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0006",
      "package": "cache",
      "aliases": [
        "CVE-2021-25903",
        "GHSA-gh87-6jr3-8q47"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-01",
      "url": "https://github.com/krl/cache/issues/2",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "soundness"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Exposes internally used raw pointer\n\nAffected versions of this crate dereference a raw pointer that can be modified\nwithout using `unsafe` code.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0128",
      "package": "cache",
      "date": "2020-11-24",
      "url": "https://github.com/krl/cache/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36448",
        "GHSA-g78p-g85h-q6ww"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Cache<K>: Send/Sync impls needs trait bounds on `K`\n\nAffected versions of this crate unconditionally implement Send/Sync for `Cache<K>`.\nThis allows users to insert `K` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<T>>` or `Rc<T>` as `K` in `Cache<K>`. It is also possible to create data races by using types like `Cell<T>` or `RefCell<T>` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0017",
      "package": "internment",
      "aliases": [
        "CVE-2020-35874",
        "GHSA-96w3-p368-4h8c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-05-28",
      "url": "https://github.com/droundy/internment/issues/11"
    },
    "affected": {
      "functions": {
        "internment::ArcIntern::drop": [
          ">= 0.3.12"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ],
      "unaffected": [
        "< 0.3.12"
      ]
    },
    "text": "\n\n# Use after free in ArcIntern::drop\n\n`ArcIntern::drop` has a race condition where it can release memory\nwhich is about to get another user. The new user will get a reference\nto freed memory.\n\nThis was fixed by serializing access to an interned object while it\nis being deallocated.\n\nVersions prior to 0.3.12 used stronger locking which avoided the problem.\n",
    "likely_poc": [
      "https://github.com/droundy/internment/issues/11"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0036",
      "package": "internment",
      "aliases": [
        "CVE-2021-28037",
        "GHSA-gppw-3h6h-v6q2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-03",
      "url": "https://github.com/droundy/internment/issues/20",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Intern<T>: Data race allowed on T\n\nAffected versions of this crate unconditionally implements `Sync` for `Intern<T>`.\nThis allows users to create data race on `T: !Sync`, which may lead to undefined behavior\n(for example, memory corruption).\n\nThe flaw was corrected in commit 2928a87 by adding the trait bound `T: Sync` in the `Sync` impl of `Intern<T>`.\n",
    "likely_poc": [
      "https://github.com/droundy/internment/issues/20"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0068",
      "package": "cocoon",
      "date": "2023-10-15",
      "url": "https://github.com/fadeevab/cocoon/issues/22",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N",
      "keywords": [
        "nonce",
        "stream-cipher"
      ],
      "aliases": [
        "GHSA-6878-6wc2-pf5h"
      ]
    },
    "affected": {
      "functions": {
        "cocoon::Cocoon::encrypt": [
          "<= 0.3.3"
        ],
        "cocoon::Cocoon::dump": [
          "<= 0.3.3"
        ],
        "cocoon::Cocoon::wrap": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::encrypt": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::dump": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::wrap": [
          "<= 0.3.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Sequential calls of encryption API (`encrypt`, `wrap`, and `dump`) result in nonce reuse\n\n**Problem**: Trying to create a new encrypted message with the same cocoon\nobject generates the same ciphertext. It mostly affects `MiniCocoon` and\n`Cocoon` objects with custom seeds and RNGs (where `StdRng` is used under\nthe hood).\n\n**Note**: The issue does **NOT** affect objects created with **`Cocoon::new`**\nwhich utilizes `ThreadRng`.\n\n**Cause**: `StdRng` produces the same nonce because `StdRng::clone` resets its\nstate.\n\n**Measure**: Make encryption API mutable (`encrypt`, `wrap`, and `dump`).\n\n**Workaround**: Create a new cocoon object with a new **seed** per each\nencryption.\n\n## How to Reproduce\n\n```rust\nlet cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data1)?;\n\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n```\n\n## Workaround\n\nFor `cocoon <= 0.3.3`, create a new cocoon with a different **seed**\nper each `encrypt`/`wrap`/`dump` call.\n\n```rust\nlet cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data1)?;\n\n// Another seed: &[2; 32].\nlet cocoon = MiniCocoon::from_password(b\"password\", &[2; 32]);\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [53, 223, 209, 96, 130, 99, 209, 108, 83, 189, 123, 81, 19, 1]\n```\n",
    "likely_poc": [
      "https://github.com/fadeevab/cocoon/issues/22"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0004",
      "package": "base64",
      "aliases": [
        "CVE-2017-1000430",
        "GHSA-x67x-vg9m-65c3"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2017-05-03",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319"
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "text": "\n\n# Integer overflow leads to heap-based buffer overflow in encode_config_buf\n\nAffected versions of this crate suffered from an integer overflow bug when\ncalculating the size of a buffer to use when encoding base64 using the\n`encode_config_buf` and `encode_config` functions.  If the input string\nwas large, this would cause a buffer to be allocated that was too small.\nSince this function writes to the buffer using unsafe code, it would\nallow an attacker to write beyond the buffer, causing memory corruption\nand possibly the execution of arbitrary code.\n\nThis flaw was corrected by using checked arithmetic to calculate\nthe size of the buffer.\n",
    "likely_poc": [
      "https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0142",
      "package": "syncpool",
      "date": "2020-11-29",
      "url": "https://github.com/Chopinsky/byte_buffer/issues/2",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2020-36462",
        "GHSA-r88h-6987-g79f",
        "GHSA-vp6r-mrq9-8f4h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.6"
      ]
    },
    "text": "\n\n# Send bound needed on T (for Send impl of `Bucket2`)\n\nAffected versions of this crate unconditionally implements `Send` for `Bucket2`. This allows sending non-Send types to other threads.\n\nThis can lead to data races when non Send types like `Cell<T>` or `Rc<T>` are contained inside `Bucket2` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nThe flaw was corrected in commit 15b2828 by adding a `T: Send` bound to the `Send` impl of `Bucket2<T>`.\n",
    "likely_poc": [
      "https://github.com/Chopinsky/byte_buffer/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0001",
      "package": "ferris-says",
      "date": "2024-01-13",
      "url": "https://github.com/rust-lang/ferris-says/pull/21",
      "informational": "unsound",
      "aliases": [
        "GHSA-v363-rrf2-5fmj"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ],
      "unaffected": [
        "<= 0.1.2"
      ]
    },
    "text": "\n\n# Unsound use of str::from_utf8_unchecked on bytes which are not UTF-8\n\nAffected versions receive a `&[u8]` from the caller through a safe API, and pass\nit directly to the unsafe `str::from_utf8_unchecked` function.\n\nThe behavior of `ferris_says::say` is undefined if the bytes from the caller\ndon't happen to be valid UTF-8.\n\nThe flaw was corrected in [ferris-says#21] by using the safe `str::from_utf8`\ninstead, and returning an error on invalid input. However this fix has not yet\nbeen published to crates.io as a patch version for 0.2.\n\nSeparately, [ferris-says#32] has introduced a different API for version 0.3\nwhich accepts input as `&str` rather than `&[u8]`, so is unaffected by this bug.\n\n[ferris-says#21]: https://github.com/rust-lang/ferris-says/pull/21\n[ferris-says#32]: https://github.com/rust-lang/ferris-says/pull/32\n",
    "likely_poc": [
      "https://github.com/rust-lang/ferris-says/pull/21"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0012",
      "package": "arrow2",
      "date": "2022-03-04",
      "url": "https://github.com/jorgecarleitao/arrow2/issues/880",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-5j8w-r7g8-5472"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.1, < 0.8",
        ">= 0.8.2, < 0.9",
        ">= 0.9.2, < 0.10",
        ">= 0.10.0"
      ]
    },
    "text": "\n\n# Arrow2 allows double free in `safe` code\n\nThe struct `Ffi_ArrowArray` implements `#derive(Clone)` that is inconsistent with\nits custom implementation of `Drop`, resulting in a double free when cloned.\n\nCloning this struct in `safe` results in a segmentation fault, which is unsound.\n\nThis derive was removed from this struct. All users are advised to either:\n* bump the patch version of this crate (for versions `v0.7,v0.8,v0.9`), or\n* migrate to a more recent version of  the crate (when using `<0.7`).\n\nDoing so elimitates this vulnerability (code no longer compiles).\n",
    "likely_poc": [
      "https://github.com/jorgecarleitao/arrow2/issues/880"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0130",
      "package": "bunch",
      "date": "2020-11-12",
      "url": "https://github.com/krl/bunch/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36450",
        "GHSA-jwph-qp5h-f9wj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Bunch<T> unconditionally implements Send/Sync\n\nAffected versions of this crate unconditionally implements `Send`/`Sync` for `Bunch<T>`.\nThis allows users to insert `T: !Sync` to `Bunch<T>`. It is possible to create a data race to a `T: !Sync` by invoking the `Bunch::get()` API (which returns `&T`) from multiple threads. It is also possible to send `T: !Send` to other threads by inserting `T` inside `Bunch<T>` and sending `Bunch<T>` to another thread, allowing to create a data race by inserting types like `T = Rc<_>`.\n\nSuch data races can lead to memory corruption.\n",
    "likely_poc": [
      "https://github.com/krl/bunch/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0088",
      "package": "magnetic",
      "aliases": [
        "CVE-2020-35925",
        "GHSA-wv4p-jp67-jr97"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-29",
      "url": "https://github.com/johnshaw/magnetic/issues/9",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.1"
      ]
    },
    "text": "\n\n# MPMCConsumer/Producer allows sending non-Send type across threads\n\nAffected versions of this crate unconditionally implemented `Sync` and `Send` traits for `MPMCConsumer` and `MPMCProducer` types.\n\nThis allows users to send types that do not implement `Send` trait across thread boundaries, which can cause a data race.\n\nThe flaw was corrected in the 2.0.1 release by adding `T: Send` bound to affected Sync/Send trait implementations.\n",
    "likely_poc": [
      "https://github.com/johnshaw/magnetic/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0057",
      "package": "inventory",
      "date": "2023-09-10",
      "url": "https://github.com/dtolnay/inventory/pull/43",
      "informational": "unsound",
      "keywords": [
        "life-before-main"
      ],
      "aliases": [
        "GHSA-ghc8-5cgm-5rpf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Fails to prohibit standard library access prior to initialization of Rust standard library runtime\n\nAffected versions allow arbitrary caller-provided code to execute before the\nlifetime of `main`.\n\nIf the caller-provided code accesses particular pieces of the standard library\nthat require an initialized Rust runtime, such as `std::io` or `std::thread`,\nthese may not behave as documented. Panics are likely; UB is possible.\n\nThe flaw was corrected by enforcing that only code written within the\n`inventory` crate, which is guaranteed not to access runtime-dependent parts of\nthe standard library, runs before `main`. Caller-provided code is restricted to\nrunning at compile time.\n",
    "likely_poc": [
      "https://github.com/dtolnay/inventory/pull/43"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0058",
      "package": "inventory",
      "date": "2023-09-10",
      "url": "https://github.com/dtolnay/inventory/pull/42",
      "informational": "unsound",
      "categories": [
        "thread-safety"
      ],
      "keywords": [
        "life-before-main"
      ],
      "aliases": [
        "GHSA-36xm-35qq-795w"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Exposes reference to non-Sync data to an arbitrary thread\n\nAffected versions do not enforce a `Sync` bound on the type of caller-provided\nvalue held in the plugin registry. References to these values are made\naccessible to arbitrary threads other than the one that constructed them.\n\nA caller could use this flaw to submit thread-unsafe data into inventory, then\naccess it as a reference simultaneously from multiple threads.\n\nThe flaw was corrected by enforcing that data submitted by the caller into\ninventory is `Sync`.\n",
    "likely_poc": [
      "https://github.com/dtolnay/inventory/pull/42"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0152",
      "package": "out-reference",
      "date": "2021-01-20",
      "url": "https://github.com/RustyYato/out-ref/issues/1",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "unsound",
        "raw-pointer"
      ],
      "aliases": [
        "GHSA-p7mj-xvxg-grff"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ],
      "unaffected": [
        "< 0.1.0"
      ]
    },
    "affected": {
      "functions": {
        "out_reference::Out::from_raw": [
          ">= 0.1.0, < 0.2.0"
        ]
      }
    },
    "text": "\n\n# `out_reference::Out::from_raw` should be `unsafe`\n\n`Out::from_raw` in affected versions allows writing a value to invalid memory address without requiring `unsafe`.\n\nThe soundness issue has been addressed by making `Out::from_raw` an unsafe function.\n",
    "likely_poc": [
      "https://github.com/RustyYato/out-ref/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0031",
      "package": "nano_arena",
      "aliases": [
        "CVE-2021-28032",
        "GHSA-wp34-mqw5-jj85"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-31",
      "url": "https://github.com/bennetthardwick/nano-arena/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "aliasing",
        "unsound"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "affected": {
      "functions": {
        "nano_arena::Arena::split_at": [
          "< 0.5.2"
        ],
        "nano_arena::ArenaSplit::split_at": [
          "< 0.5.2"
        ]
      }
    },
    "text": "\n\n# split_at allows obtaining multiple mutable references to the same data\n\nAffected versions of this crate assumed that `Borrow<Idx>` was guaranteed to\nreturn the same value on `.borrow()`. The borrowed index value was used to\nretrieve a mutable reference to a value.\n\nIf the `Borrow<Idx>` implementation returned a different index, the split arena\nwould allow retrieving the index as a mutable reference creating two mutable\nreferences to the same element. This violates Rust's aliasing rules and allows\nfor memory safety issues such as writing out of bounds and use-after-frees.\n\nThe flaw was corrected in commit `6b83f9d` by storing the `.borrow()` value in\na temporary variable.\n",
    "likely_poc": [
      "https://github.com/bennetthardwick/nano-arena/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0042",
      "package": "ouroboros",
      "date": "2023-06-11",
      "url": "https://github.com/joshua-maros/ouroboros/issues/88",
      "informational": "unsound",
      "aliases": [
        "GHSA-87mf-9wg6-ppf8"
      ]
    },
    "versions": {
      "patched": [
        ">=0.16.0"
      ]
    },
    "text": "\n\n# Ouroboros is Unsound\n\n## Summary\n\nOuroboros has a soundness problem, but a fix has been implemented in 0.16.0.\n\n## More details:\n\nIn 0.15.0, Ouroboros works internally by creating a struct where all \nuses of 'this are replaced by 'static. However, a recent addition to \nMiri checks that references passed to functions are valid during the \nentire execution of the function, even when those references are \npassed inside a struct. This poses an issue for dropping \nself-referencing values, as the reference becomes invalid during the \ndropping process. Effectively, since self-referencing structs are \nnot allowed in vanilla Rust, there is no allowance for dropping data\nduring a function that has also been given a reference to that data. \nThere's usually no way to pass a and &a to the same function.\n\nA fix was attempted, where the struct would be turned in to a raw \nbyte array and only transformed back into the underlying data type \ninside each function. This is allowable as a reference can be \ncreated and die over the body of a function, as long as the \nreference was created inside the function. However, this is also \nnot sound if the original struct contains padding. There is no \nway to initialize padding bytes to a known value that Miri will \naccept, so when it is cast to an array some of the bytes contain \nuninitialized values. This is not acceptable (despite the fact \nthat these bytes are never read) due to the potential for \noptimizations that may read from the uninitialized bytes. Besides \nwhich, this fix does not allow for template or constant parameters \nas there is no way to check the size of a templated type without \ngiving specific, concrete values for the template parameters.\n\nThe final solution was to use this fix while wrapping the raw byte\narray in `MaybeUninit<>`.\n",
    "likely_poc": [
      "https://github.com/joshua-maros/ouroboros/issues/88"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0108",
      "package": "eventio",
      "aliases": [
        "CVE-2020-36216",
        "GHSA-69vj-xx27-g45w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-20",
      "url": "https://github.com/petabi/eventio/issues/33",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.1"
      ]
    },
    "text": "\n\n# Soundness issue: Input<R> can be misused to create data race to an object\n\n`Input<R>` implements `Send` without requiring `R: Send`.\n\nAffected versions of this crate allows users to send non-Send types to other threads,\nwhich can lead to undefined behavior such as data race and memory corruption.\n\nThe flaw was corrected in version 0.5.1 by adding `R: Send` bound to the `Send` impl of `Input<R>`.\n",
    "likely_poc": [
      "https://github.com/petabi/eventio/issues/33"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0032",
      "package": "alpm-rs",
      "aliases": [
        "CVE-2020-35885",
        "GHSA-qc4m-gc8r-mg8m"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-08-20",
      "informational": "unsound",
      "url": "https://github.com/pigeonhands/rust-arch/issues/2"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# StrcCtx deallocates a memory region that it doesn't own\n\n`StrcCtx` deallocate a memory region that it doesn't own when `StrcCtx` is created without using `StrcCtx::new`.\nThis can introduce memory safety issues such as double-free and use-after-free to client programs.\n",
    "likely_poc": [
      "https://github.com/pigeonhands/rust-arch/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0111",
      "package": "tremor-script",
      "date": "2021-09-16",
      "url": "https://github.com/tremor-rs/tremor-runtime/pull/1217",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2021-45701",
        "CVE-2021-45702",
        "GHSA-3pp4-64mp-9cg9",
        "GHSA-9qvw-46gf-4fv8",
        "GHSA-q2x5-6q7q-r872"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.11.6"
      ],
      "unaffected": [
        "<= 0.7.2"
      ]
    },
    "text": "\n\n# Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`\n\nAffected versions of this crate maintains references to memory that might have been freed already.\nIf affects the following two `tremor-script` language constructs:\n\n* A [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) where we assign the result back to the target expression\n  and the expression to be merged needs to reference the `event`:\n\n```\nlet state = merge state of event end;\n```\n\n* A [Patch](https://www.tremor.rs/docs/tremor-script/index#patch) where we assign the result back to the target expression\n  and the patch operations used need to reference the `event`:\n\n```\nlet state = patch state of insert event.key => event.value end;\n```\n\nFor constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization\nwas applied to manipulate the target value in-place, instead of cloning it.\n\nOur `Value` struct which underpins all event data in `tremor-script`, is representing as borrowed strings `beef::Cow<'lifetime, str>` \nthat reference the actual `Vec<u8>` the event is based upon. We keep the raw byte-array next to the event structure inside our `Event` struct as a self-referential struct,\nso we make sure that the structured `Value` and its references are valid across its whole lifetime.\n\nThe optimization was considered safe as long as it was only possible to merge or patche `event` data or static data.\nWhen `state` was introduced to `tremor-script` a new possibility existed, to keep `Value` data around for longer than the lifetime of an event.\nIf `event` data is merged or patched into `state` without cloning `state` first, it can still reference keys or values from\nthe previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.\n\n\n## Workaround\n\nIf an upgrade is not possible, a possible workaround is to avoid the optimization\nby introducing a temporary variable and not immediately reassigning to `state`:\n\n```\nlet tmp = merge state of event end;\nlet state = tmp\n```\n\n## Fix\n\nThe flaw was corrected in `tremor-script` version 0.11.6 via commit [1a2efcd](https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e) by removing the optimization\nand always clone the target expression of a [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) or [Patch](https://www.tremor.rs/docs/tremor-script/index#patch.\n\n",
    "likely_poc": [
      "https://github.com/tremor-rs/tremor-runtime/pull/1217"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0364",
      "package": "gitoxide-core",
      "date": "2024-08-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h",
      "references": [
        "https://github.com/advisories/GHSA-88g2-r9rw-g55h",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-43785",
        "https://github.com/Byron/gitoxide/issues/1534"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N",
      "keywords": [
        "terminal",
        "control-characters",
        "escape-sequences"
      ],
      "aliases": [
        "CVE-2024-43785",
        "GHSA-88g2-r9rw-g55h"
      ],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# gitoxide-core does not neutralize special characters for terminals\n\n### Summary\n\nThe `gix` and `ein` commands write pathnames and other metadata literally to terminals, even if they contain characters terminals treat specially, including ANSI escape sequences. This sometimes allows an untrusted repository to misrepresent its contents and to alter or concoct error messages.\n\n### Details\n\n`gitoxide-core`, which provides most underlying functionality of the `gix` and `ein` commands, does not neutralize newlines, backspaces, or control characters\u2014including those that form ANSI escape sequences\u2014that appear in a repository's paths, author and committer names, commit messages, or other metadata. Such text may be written as part of the output of a command, as well as appearing in error messages when an operation fails.\n\nANSI escape sequences are of particular concern because, when printed to a terminal, they can change colors, including to render subsequent text unreadable; reposition the cursor to write text in a different location, including where text has already been written; clear the terminal; set the terminal title-bar text to arbitrary values; render the terminal temporarily unusable; and other such operations.\n\nThe effect is mostly an annoyance. But the author of a malicious repository who can predict how information from the repository may be accessed can cause files in the repository to be concealed or otherwise misrepresented, as well as rewrite all or part of error messages, or mimic error messages convincingly by repositioning the cursor and writing colored text.\n\n### PoC\n\nOn a Unix-like system in a POSIX-compatible shell, run:\n\n```sh\ngit init misleading-path\ncd misleading-path\ntouch \"$(printf '\\033]0;Boo!\\007\\033[2K\\r\\033[91mError: Repository is corrupted. Run \\033[96mEVIL_COMMAND\\033[91m to attempt recovery.\\033[0m')\"\ngit add .\ngit commit -m 'Initial commit'\n```\n\nIn the repository\u2014or, if desired, in a clone of it, to show that this is exploitable by getting a user to clone an untrusted repository\u2014run this command, which outputs entries in a three-column form showing type, hash, and filename:\n\n```sh\ngix tree entries\n```\n\nAlthough the output is of that form, it does not appear to be. Instead, the output in a terminal looks like this, colorized to appear to be an error message, with `EVIL_COMMAND` in another color, and with no other text:\n\n```text\nError: Repository is corrupted. Run EVIL_COMMAND to attempt recovery.\n```\n\nIn some terminals, a beep or other sound will be made. In most terminals, the title bar text will be changed to `Boo!`, though in some shells this may be immediately undone when printing the prompt. These elements are included to showcase the abilities of ANSI escape sequences, but they are not usually themselves threats.\n\nTo see what is actually produced, `gix tree entries` can be piped to a command that displays special characters symbolically, such as `less` or `cat -v` if available.\n\n```text\nBLOB e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ESC]0;Boo!^GESC[2K^MESC[91mError: Repository is corrupted. Run ESC[96mEVIL_COMMANDESC[91m to attempt recovery.ESC[0m\n```\n\nThat shows the effect on `gix tree entries`, but various other commands are also affected, and the escape sequences and other special characters can also appear in non-path metadata, such as in the `user.name` used to create a commit.\n\n### Impact\n\nFor users who do not clone or operate in clones of untrusted repositories, there is no impact.\n\nWindows is much less affected than Unix-like systems due to limitations on what characters can appear in filenames, and because traditionally Windows terminals do not support as many ANSI escape sequences.\n\nBecause different `gix` and `ein` commands display different data in different formats, the author of a malicious repository must guess how it will be used, which complicates crafting truly convincing output, though it may be possible to craft a repository where `gix clone` fails to clone it but produces a misleading message.\n\nAlthough this is mainly exploitable on systems *other* than Windows, in the ability to produce misleading output this superficially resembles [CVE-2024-35197](https://github.com/advisories/GHSA-49jc-r788-3fc9). But this is much more limited, because:\n\n- The misleading output can only be made to go where the application is already sending output. Redirection is not defeated, and devices to access cannot be chosen by the attacker.\n- The misleading output can only be take place *when* the application is already producing output. This limitation complicates the production of believable messages.\n- Only terminals are affected. Even if a standard stream is redirected to another file or device, these special characters would not have a special effect, unless echoed later without sanitization.\n- Reading and blocking cannot be performed.\n- Applications other than the gitoxide `gix` and `ein` executables are unaffected. The exception is if another application uses `gitoxide-core`. But this is explicitly discouraged in the `gitoxide-core` documentation and is believed to be rare.\n",
    "likely_poc": [
      "https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h",
      "https://github.com/advisories/GHSA-88g2-r9rw-g55h",
      "https://nvd.nist.gov/vuln/detail/CVE-2024-43785",
      "https://github.com/Byron/gitoxide/issues/1534"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0048",
      "package": "stackvector",
      "aliases": [
        "CVE-2021-29939",
        "GHSA-9frf-r7c7-j2vg"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-19",
      "url": "https://github.com/Alexhuszagh/rust-stackvector/issues/2",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.9"
      ]
    },
    "text": "\n\n# StackVec::extend can write out of bounds when size_hint is incorrect\n\n`StackVec::extend` used the lower and upper bounds from an Iterator's\n`size_hint` to determine how many items to push into the stack based vector.\n\nIf the `size_hint` implementation returned a lower bound that was larger than\nthe upper bound, `StackVec` would write out of bounds and overwrite memory\non the stack. As mentioned by the [size_hint](https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods)\ndocumentation, `size_hint` is mainly for optimization and incorrect\nimplementations should not lead to memory safety issues.\n",
    "likely_poc": [
      "https://github.com/Alexhuszagh/rust-stackvector/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0032",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-2097",
        "GHSA-3wx7-46ch-7rq2"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-07-05",
      "url": "https://www.openssl.org/news/secadv/20220705.txt"
    },
    "versions": {
      "patched": [
        ">= 111.22, < 300.0",
        ">= 300.0.9"
      ]
    },
    "text": "\n\n# AES OCB fails to encrypt some bytes\n\nAES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised\nimplementation will not encrypt the entirety of the data under some\ncircumstances.  This could reveal sixteen bytes of data that was\npreexisting in the memory that wasn't written.  In the special case of\n\"in place\" encryption, sixteen bytes of the plaintext would be revealed.\n\nSince OpenSSL does not support OCB based cipher suites for TLS and DTLS,\nthey are both unaffected.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0025",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-1473",
        "GHSA-g323-fr93-4j3c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2022-05-03",
      "url": "https://www.openssl.org/news/secadv/20220503.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.6"
      ],
      "unaffected": [
        "< 300.0"
      ]
    },
    "text": "\n\n# Resource leakage when decoding certificates and keys\n\nThe `OPENSSL_LH_flush()` function, which empties a hash table, contains\na bug that breaks reuse of the memory occupied by the removed hash\ntable entries.\n\nThis function is used when decoding certificates or keys. If a long lived\nprocess periodically decodes certificates or keys its memory usage will\nexpand without bounds and the process might be terminated by the operating\nsystem causing a denial of service. Also traversing the empty hash table\nentries will take increasingly more time.\n\nTypically such long lived processes might be TLS clients or TLS servers\nconfigured to accept client certificate authentication.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0129",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-4044",
        "GHSA-mmjf-f5jw-w72q"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2021-12-14",
      "url": "https://www.openssl.org/news/secadv/20211214.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.4"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# Invalid handling of `X509_verify_cert()` internal errors in libssl\n\nInternally libssl in OpenSSL calls `X509_verify_cert()` on the client side to\nverify a certificate supplied by a server. That function may return a negative\nreturn value to indicate an internal error (for example out of memory). Such a\nnegative return value is mishandled by OpenSSL and will cause an IO function\n(such as `SSL_connect()` or `SSL_do_handshake()`) to not indicate success and a\nsubsequent call to `SSL_get_error()` to return the value\n`SSL_ERROR_WANT_RETRY_VERIFY`. This return value is only supposed to be returned\nby OpenSSL if the application has previously called\n`SSL_CTX_set_cert_verify_callback()`. Since most applications do not do this the\n`SSL_ERROR_WANT_RETRY_VERIFY` return value from `SSL_get_error()` will be totally\nunexpected and applications may not behave correctly as a result. The exact\nbehaviour will depend on the application but it could result in crashes,\ninfinite loops or other similar incorrect responses.\n\nThis issue is made more serious in combination with a separate bug in OpenSSL\n3.0 that will cause `X509_verify_cert()` to indicate an internal error when\nprocessing a certificate chain. This will occur where a certificate does not\ninclude the Subject Alternative Name extension but where a Certificate Authority\nhas enforced name constraints. This issue can occur even with valid chains.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0006",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0286",
        "GHSA-x4qr-2fvf-3mr5"
      ],
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 111.25, < 300.0",
        ">= 300.0.12"
      ]
    },
    "text": "\n\n# X.400 address type confusion in X.509 `GeneralName`\n\nThere is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 `GeneralName`. X.400 addresses were parsed as an `ASN1_STRING` but\nthe public structure definition for `GENERAL_NAME` incorrectly specified the type\nof the `x400Address` field as `ASN1_TYPE`. This field is subsequently interpreted by\nthe OpenSSL function `GENERAL_NAME_cmp` as an `ASN1_TYPE` rather than an\n`ASN1_STRING`.\n\nWhen CRL checking is enabled (i.e. the application sets the\n`X509_V_FLAG_CRL_CHECK` flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a `memcmp` call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0033",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-2274",
        "GHSA-735f-pg76-fxc4"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-07-05",
      "url": "https://www.openssl.org/news/secadv/20220705.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.9"
      ],
      "unaffected": [
        "< 300.0.8"
      ]
    },
    "text": "\n\n# Heap memory corruption with RSA private key operation\n\nThe OpenSSL 3.0.4 release introduced a serious bug in the RSA\nimplementation for X86_64 CPUs supporting the AVX512IFMA instructions.\nThis issue makes the RSA implementation with 2048 bit private keys\nincorrect on such machines and memory corruption will happen during\nthe computation. As a consequence of the memory corruption an attacker\nmay be able to trigger a remote code execution on the machine performing\nthe computation.\n\nSSL/TLS servers or other servers using 2048 bit RSA private keys running\non machines supporting AVX512IFMA instructions of the X86_64 architecture\nare affected by this issue.\n\nNote that on a vulnerable machine, proper testing of OpenSSL would fail and\nshould be noticed before deployment.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0098",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-3712",
        "GHSA-q9wj-f4qw-6vfj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "categories": [
        "denial-of-service",
        "crypto-failure"
      ],
      "date": "2021-08-24",
      "url": "https://www.openssl.org/news/secadv/20210824.txt"
    },
    "versions": {
      "patched": [
        ">= 111.16"
      ]
    },
    "text": "\n\n# Read buffer overruns processing ASN.1 strings\n\nASN.1 strings are represented internally within OpenSSL as an ASN1_STRING\nstructure which contains a buffer holding the string data and a field holding\nthe buffer length. This contrasts with normal C strings which are represented as\na buffer for the string data which is terminated with a NUL (0) byte.\n\nAlthough not a strict requirement, ASN.1 strings that are parsed using OpenSSL's\nown \"d2i\" functions (and other similar parsing functions) as well as any string\nwhose value has been set with the ASN1_STRING_set() function will additionally\nNUL terminate the byte array in the ASN1_STRING structure.\n\nHowever, it is possible for applications to directly construct valid ASN1_STRING\nstructures which do not NUL terminate the byte array by directly setting the\n\"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by\nusing the `ASN1_STRING_set0()` function.\n\nNumerous OpenSSL functions that print ASN.1 data have been found to assume that\nthe ASN1_STRING byte array will be NUL terminated, even though this is not\nguaranteed for strings that have been directly constructed. Where an application\nrequests an ASN.1 structure to be printed, and where that ASN.1 structure\ncontains ASN1_STRINGs that have been directly constructed by the application\nwithout NUL terminating the \"data\" field, then a read buffer overrun can occur.\n\nThe same thing can also occur during name constraints processing of certificates\n(for example if a certificate has been directly constructed by the application\ninstead of loading it via the OpenSSL parsing functions, and the certificate\ncontains non NUL terminated ASN1_STRING structures). It can also occur in the\n`X509_get1_email()`, `X509_REQ_get1_email()` and `X509_get1_ocsp()` functions.\n\nIf a malicious actor can cause an application to directly construct an\nASN1_STRING and then process it through one of the affected OpenSSL functions\nthen this issue could be hit. This might result in a crash (causing a Denial of\nService attack). It could also result in the disclosure of private memory\ncontents (such as private keys, or sensitive plaintext).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0008",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-4203",
        "GHSA-w67w-mw4j-8qrv"
      ],
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.12"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# X.509 Name Constraints Read Buffer Overflow\n\nA read buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer.\n\nThe read buffer overrun might result in a crash which could lead to\na denial of service attack. In theory it could also result in the disclosure\nof private memory contents (such as private keys, or sensitive plaintext)\nalthough we are not aware of any working exploit leading to memory\ncontents disclosure as of the time of release of this advisory.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0062",
      "package": "futures-util",
      "aliases": [
        "CVE-2020-35908",
        "GHSA-5r9g-j7jj-hw6c"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-01-24",
      "url": "https://github.com/rust-lang/futures-rs/issues/2050",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency",
        "memory-corruption",
        "memory-management"
      ]
    },
    "affected": {
      "functions": {
        "futures_util::stream::FuturesUnordered": [
          ">= 0.3.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Improper `Sync` implementation on `FuturesUnordered` in futures-utils can cause data corruption\nAffected versions of the crate had an unsound `Sync` implementation on the `FuturesUnordered` structure, which used a `Cell` for\ninterior mutability without any code to handle synchronized access to the underlying task list's length and head safely.\n\nThis could of lead to data corruption since two threads modifying the list at once could see incorrect values due to the lack\nof access synchronization.\n\nThe issue was fixed by adding access synchronization code around insertion of tasks into the list.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0059",
      "package": "futures-util",
      "aliases": [
        "CVE-2020-35905",
        "GHSA-rh4w-94hh-9943"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-22",
      "url": "https://github.com/rust-lang/futures-rs/issues/2239",
      "categories": [
        "thread-safety"
      ],
      "keywords": [
        "concurrency",
        "memory-corruption",
        "memory-management"
      ]
    },
    "affected": {
      "functions": {
        "futures_util::lock::MutexGuard::map": [
          ">= 0.3.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.7"
      ],
      "unaffected": [
        "< 0.3.2"
      ]
    },
    "text": "\n\n# MutexGuard::map can cause a data race in safe code\nAffected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.\n\nThis could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.\n\nThe issue was fixed by fixing `Send` and `Sync` implementations, and by adding a `PhantomData<&'a mut U>` marker to the `MappedMutexGuard` type to tell the compiler that the guard is over\nU too.\n",
    "likely_poc": [
      "https://github.com/rust-lang/futures-rs/issues/2239"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0116",
      "package": "unicycle",
      "date": "2020-11-15",
      "url": "https://github.com/udoprog/unicycle/issues/8",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36436",
        "GHSA-686f-ch3r-xwmh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# PinSlab<T> and Unordered<T, S> need bounds on their Send/Sync traits\n\nAffected versions of this crate unconditionally implemented `Send` & `Sync` for types `PinSlab<T>` & `Unordered<T, S>`. This allows sending non-Send types to other threads and concurrently accessing non-Sync types from multiple threads.\n\nThis can result in a data race & memory corruption when types that provide internal mutability without synchronization are contained within `PinSlab<T>` or `Unordered<T, S>` and accessed concurrently from multiple threads.\n\nThe flaw was corrected in commits 92f40b4 & 6a6c367 by adding trait bound `T: Send` to `Send` impls for `PinSlab<T>` & `Unordered<T, S>` and adding `T: Sync` to `Sync` impls for `PinSlab<T>` & `Unordered<T, S>`.\n",
    "likely_poc": [
      "https://github.com/udoprog/unicycle/issues/8"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0007",
      "package": "rust-i18n-support",
      "date": "2024-01-19",
      "url": "https://github.com/longbridgeapp/rust-i18n/issues/71",
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "references": [
        "https://github.com/longbridgeapp/rust-i18n/pull/72",
        "https://github.com/longbridgeapp/rust-i18n/releases/tag/v3.0.1"
      ],
      "aliases": [
        "GHSA-c8v3-jhv9-4ppc"
      ]
    },
    "affected": {
      "functions": {
        "rust_i18n_support::AtomicStr::as_str": [
          "< 3.0.1, >= 3.0.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 3.0.1"
      ],
      "unaffected": [
        "< 3.0.0"
      ]
    },
    "text": "\n\n# Use-after-free when setting the locale\n\nVersion 3.0.0 introduced an `AtomicStr` type, that is used to store the current locale.\nIt stores the locale as a raw pointer to an `Arc<String>`.\nThe locale can be read with `AtomicStr::as_str()`.\n`AtomicStr::as_str()` does not increment the usage counter of the `Arc`.\n\nIf the locale is changed in one thread, another thread can have a stale -- possibly already freed --\nreference to the stored string.\n",
    "likely_poc": [
      "https://github.com/longbridgeapp/rust-i18n/issues/71",
      "https://github.com/longbridgeapp/rust-i18n/pull/72"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0029",
      "package": "truetype",
      "aliases": [
        "CVE-2021-28030",
        "GHSA-v7q4-97x4-4qw2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-02-17",
      "url": "https://github.com/bodoni/truetype/issues/11",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.30.1"
      ]
    },
    "text": "\n\n# Tape::take_bytes exposes uninitialized memory to a user-provided Read\n\nAffected versions of this crate passed an unininitialized buffer to a\nuser-provided `Read` instance in `Tape::take_bytes`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was corrected in commit `1f2dc7f37dd` by removing the unsafe block\nand zero-initializing the buffer.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0041",
      "aliases": [
        "CAN-2021-1000007",
        "CVE-2021-29932",
        "GHSA-qpgv-g792-wh6x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "package": "parse_duration",
      "date": "2021-03-18",
      "url": "https://github.com/zeta12ti/parse_duration/issues/21",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "parsing",
        "untrusted data"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "parse_duration::parse": [
          "*"
        ]
      }
    },
    "text": "\n\n# Denial of service through parsing payloads with too big exponent\n\nThe `parse_duration::parse` function allows for parsing duration strings with exponents like `5e5s` where under the hood, the [`BigInt` type along with the `pow` function are used for such payloads](https://github.com/zeta12ti/parse_duration/blob/26940ab5cd4e3a9d6bd97aa101f8d4bbfd18ee8c/src/parse.rs#L335). Passing an arbitrarily big exponent makes the `parse_duration::parse` function to process the payload for a very long time taking up CPU and memory.\n\nThis allows an attacker to cause a DoS if the `parse_duration::parse` function is used to process untrusted input.\n",
    "likely_poc": [
      "https://github.com/zeta12ti/parse_duration/issues/21"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0016",
      "package": "libdav1d-sys",
      "date": "2024-02-19",
      "url": "https://www.cvedetails.com/cve/CVE-2024-1580/",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "GHSA-mc39-h54g-pvw6"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# dav1d AV1 decoder integer overflow\n\nAn integer overflow in dav1d AV1 decoder that can occur when decoding videos with large frame size. This can lead to memory corruption within the AV1 decoder. We recommend upgrading to version 0.7.0 of libdav1d-sys, which includes dav1d 1.4.0\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0061",
      "package": "futures-task",
      "aliases": [
        "CVE-2020-35907",
        "GHSA-p9m5-3hj7-cp5r"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-05-03",
      "url": "https://github.com/rust-lang/futures-rs/issues/2091",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "NULL pointer dereference",
        "memory-management"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.5"
      ]
    },
    "affected": {
      "functions": {
        "futures_task::noop_waker_ref": [
          ">= 0.3.0"
        ]
      }
    },
    "text": "\n\n# futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer\n\nAffected versions of the crate used a `UnsafeCell` in thread-local storage to return a noop waker reference,\nassuming that the reference would never be returned from another thread.\n\nThis resulted in a segmentation fault crash if `Waker::wake_by_ref()` was called on a waker returned from another thread due to \nit attempting to dereference a pointer that wasn't accessible from the main thread.\n\nReproduction Example (from issue):\n```rust\nuse futures_task::noop_waker_ref;\nfn main() {\n    let waker = std::thread::spawn(|| noop_waker_ref()).join().unwrap();\n    waker.wake_by_ref();\n}\n```\n\nThe flaw was corrected by using a `OnceCell::Lazy<>` wrapper around the noop waker instead of thread-local storage.\n",
    "likely_poc": [
      "https://github.com/rust-lang/futures-rs/issues/2091"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0060",
      "package": "futures-task",
      "aliases": [
        "CVE-2020-35906",
        "GHSA-r93v-9p5q-vhpf"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-09-04",
      "url": "https://github.com/rust-lang/futures-rs/pull/2206",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "arbitrary code execution",
        "memory-corruption",
        "memory-management"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.6"
      ],
      "unaffected": [
        "<= 0.2.1"
      ]
    },
    "affected": {
      "functions": {
        "futures_task::waker": [
          ">= 0.3.0"
        ]
      }
    },
    "text": "\n\n# futures_task::waker may cause a use-after-free if used on a type that isn't 'static\n\nAffected versions of the crate did not properly implement a `'static` lifetime bound on the `waker` function.\nThis resulted in a use-after-free if `Waker::wake()` is called after original data had been dropped.\n\nThe flaw was corrected by adding `'static` lifetime bound to the data `waker` takes.\n",
    "likely_poc": [
      "https://github.com/rust-lang/futures-rs/pull/2206"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0096",
      "package": "im",
      "aliases": [
        "CVE-2020-36204",
        "GHSA-q9h2-4xhf-23xx"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-09",
      "url": "https://github.com/bodil/im-rs/issues/157",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 15.1.0"
      ],
      "unaffected": [
        "< 12.0.0"
      ]
    },
    "text": "\n\n# TreeFocus lacks bounds on its Send and Sync traits\n\nAffected versions of `im` contains `TreeFocus` that unconditionally implements `Send` and `Sync`.\n\nThis allows a data race in safe Rust code if `TreeFocus` is extracted from `Focus` type.\nTypical users that only use `Focus` type are not affected.\n",
    "likely_poc": [
      "https://github.com/bodil/im-rs/issues/157"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0112",
      "package": "buttplug",
      "aliases": [
        "CVE-2020-36218",
        "GHSA-r7rv-2rph-hvhj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-18",
      "url": "https://github.com/buttplugio/buttplug-rs/issues/225",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.4"
      ]
    },
    "text": "\n\n# ButtplugFutureStateShared allows data race to (!Send|!Sync) objects\n\n`ButtplugFutureStateShared<T>` implements `Send` & `Sync` regardless of `T`.\n\nIf `T: !Send` for `ButtplugFutureStateShared<T>`, it is possible to move non-Send types across thread boundaries (e.g. `T`=`Rc<T>`) and lead to undefined behavior.\nIf `T: !Sync` for `ButtplugFutureStateShared<T>`, it is possible to cause data race to `T` (e.g. `T`=`Arc<Cell<_>>`) and lead to undefined behavior.\n\nThe flaw was corrected in version 1.0.4 by removing manual implementations of `Send`/`Sync` for `ButtplugFutureStateShared<T>` to let rustc generate auto trait implementations with correct trait bounds on `T`.\n",
    "likely_poc": [
      "https://github.com/buttplugio/buttplug-rs/issues/225"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0033",
      "package": "stack_dst",
      "aliases": [
        "CVE-2021-28034",
        "CVE-2021-28035",
        "GHSA-45w7-7g63-2m5w",
        "GHSA-8mjx-h23h-w2pg"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-22",
      "url": "https://github.com/thepowersgang/stack_dst-rs/issues/5",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "affected": {
      "functions": {
        "stack_dst::StackA::push_cloned": [
          "< 0.6.1"
        ]
      }
    },
    "text": "\n\n# push_cloned can drop uninitialized memory or double free on panic\n\nAffected versions of `stack_dst` used a `push_inner` function that increased\nthe internal length of the array and then called `val.clone()`.\n\nIf the `val.clone()` call panics, the stack could drop an already dropped\nelement or drop uninitialized memory.\n\nThis issue was fixed in `2a4d538` by increasing the length of the array after\nelements are cloned.\n",
    "likely_poc": [
      "https://github.com/thepowersgang/stack_dst-rs/issues/5"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0167",
      "package": "pnet_packet",
      "date": "2020-06-19",
      "url": "https://github.com/libpnet/libpnet/issues/449",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
      "aliases": [
        "GHSA-cf4g-fcf8-3cr9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.27.2"
      ]
    },
    "text": "\n\n# `pnet_packet` buffer overrun in `set_payload` setters\n\nAs indicated by this [issue](https://github.com/libpnet/libpnet/issues/449#issuecomment-663355987), a buffer overrun is possible in the `set_payload` setter of the various mutable \"Packet\" struct setters. The offending `set_payload` functions were defined within the struct `impl` blocks in earlier versions of the package, and later by the `packet` macro.\n\nFixed in the `packet` macro by [this](https://github.com/libpnet/libpnet/pull/455) PR.\n",
    "likely_poc": [
      "https://github.com/libpnet/libpnet/issues/449"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0006",
      "package": "thread_local",
      "categories": [
        "memory-corruption"
      ],
      "date": "2022-01-23",
      "url": "https://github.com/Amanieu/thread_local-rs/issues/33",
      "aliases": [
        "GHSA-9hpw-r23r-xgm5"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.4"
      ]
    },
    "text": "\n\n# Data race in `Iter` and `IterMut`\n\nIn the affected version of this crate, `{Iter, IterMut}::next` used a weaker memory ordering when loading values than what was required, exposing a potential data race\nwhen iterating over a `ThreadLocal`'s values.\n\nCrates using `Iter::next`, or `IterMut::next` are affected by this issue.\n",
    "likely_poc": [
      "https://github.com/Amanieu/thread_local-rs/issues/33"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0040",
      "package": "owning_ref",
      "date": "2022-01-26",
      "url": "https://github.com/noamtashma/owning-ref-unsoundness",
      "references": [
        "https://github.com/Kimundi/owning-ref-rs/issues/49",
        "https://github.com/Kimundi/owning-ref-rs/issues/61",
        "https://github.com/Kimundi/owning-ref-rs/issues/71",
        "https://github.com/Kimundi/owning-ref-rs/issues/77"
      ],
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-9qxh-258v-666c"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple soundness issues in `owning_ref`\n\n- `OwningRef::map_with_owner` is [unsound](https://github.com/Kimundi/owning-ref-rs/issues/77) and may result in a use-after-free.\n- `OwningRef::map` is [unsound](https://github.com/Kimundi/owning-ref-rs/issues/71) and may result in a use-after-free.\n- `OwningRefMut::as_owner` and `OwningRefMut::as_owner_mut` are [unsound](https://github.com/Kimundi/owning-ref-rs/issues/61) and may result in a use-after-free.\n- The crate [violates Rust's aliasing rules](https://github.com/Kimundi/owning-ref-rs/issues/49), which may cause miscompilations on recent compilers that emit the LLVM `noalias` attribute.\n\n`safer_owning_ref` is a replacement crate which fixes these issues.\nNo patched versions of the original crate are available, and the maintainer is unresponsive.\n",
    "likely_poc": [
      "https://github.com/noamtashma/owning-ref-unsoundness",
      "https://github.com/Kimundi/owning-ref-rs/issues/49",
      "https://github.com/Kimundi/owning-ref-rs/issues/61",
      "https://github.com/Kimundi/owning-ref-rs/issues/71",
      "https://github.com/Kimundi/owning-ref-rs/issues/77"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0117",
      "package": "conqueue",
      "date": "2020-11-24",
      "url": "https://github.com/longshorej/conqueue/issues/9",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36437",
        "GHSA-368f-29c3-4f2r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# QueueSender<T>/QueueReceiver<T>: Send/Sync impls need `T: Send`\n\nAffected versions of this crate unconditionally implemented `Send`/`Sync` for `QueueSender<T>`,\nallowing to send non-Send `T` to other threads by invoking `(&QueueSender<T>).send()`.\n\nThis fails to prevent users from creating data races by sending types like `Rc<T>` or `Arc<Cell<T>>` to other threads, which can lead to memory corruption.\n\nThe flaw was corrected in commit 1e462c3 by imposing `T: Send` to both `Send`/`Sync` impls for `QueueSender<T>`/`QueueReceiver<T>`.\n",
    "likely_poc": [
      "https://github.com/longshorej/conqueue/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0098",
      "package": "rusb",
      "aliases": [
        "CVE-2020-36206",
        "GHSA-9mxw-4856-9cm5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-18",
      "url": "https://github.com/a1ien/rusb/issues/44",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ],
      "unaffected": []
    },
    "text": "\n\n# UsbContext trait did not require implementers to be Send and Sync.\n\nAffected versions of `rusb` did not require `UsbContext` to implement `Send`\nand `Sync`. However, through `Device` and `DeviceHandle` it is possible to use\n`UsbContext`s across threads.\n\nThis issue allows non-thread safe `UsbContext` types to be used concurrently\nleading to data races and memory corruption.\n\nThe issue was fixed by adding `Send` and `Sync` bounds to `UsbContext`.\n",
    "likely_poc": [
      "https://github.com/a1ien/rusb/issues/44"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0075",
      "package": "unsafe-libyaml",
      "date": "2023-12-20",
      "url": "https://github.com/dtolnay/unsafe-libyaml/issues/21",
      "informational": "unsound",
      "keywords": [
        "unaligned-write"
      ],
      "aliases": [
        "GHSA-r24f-hg58-vfrw"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.10"
      ]
    },
    "text": "\n\n# Unaligned write of u64 on 32-bit and 16-bit platforms\n\nAffected versions allocate memory using the alignment of `usize` and write data\nto it of type `u64`, without using `core::ptr::write_unaligned`. In platforms\nwith sub-64bit alignment for `usize` (including wasm32 and x86) these writes\nare insufficiently aligned some of the time.\n\nIf using an ordinary optimized standard library, the bug exhibits Undefined\nBehavior so may or may not behave in any sensible way, depending on\noptimization settings and hardware and other things. If using a Rust standard\nlibrary built with debug assertions enabled, the bug manifests deterministically\nin a crash (non-unwinding panic) saying _\"ptr::write requires that the pointer\nargument is aligned and non-null\"_.\n\nNo 64-bit platform is impacted by the bug.\n\nThe flaw was corrected by allocating with adequately high alignment on all\nplatforms.\n",
    "likely_poc": [
      "https://github.com/dtolnay/unsafe-libyaml/issues/21"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0003",
      "package": "protobuf",
      "aliases": [
        "CVE-2019-15544",
        "GHSA-mh6h-f25p-98f8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2019-06-08",
      "keywords": [
        "oom",
        "panic"
      ],
      "url": "https://github.com/stepancheg/rust-protobuf/issues/411"
    },
    "affected": {
      "functions": {
        "protobuf::stream::read_raw_bytes_into": [
          "< 2.6.0"
        ]
      }
    },
    "versions": {
      "patched": [
        "^1.7.5",
        ">= 2.6.0"
      ]
    },
    "text": "\n\n# Out of Memory in stream::read_raw_bytes_into()\n\nAffected versions of this crate called Vec::reserve() on user-supplied input.\n\nThis allows an attacker to cause an Out of Memory condition while calling the\nvulnerable method on untrusted data.\n",
    "likely_poc": [
      "https://github.com/stepancheg/rust-protobuf/issues/411"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0018",
      "package": "renderdoc",
      "aliases": [
        "CVE-2019-16142",
        "GHSA-vhfr-v4w9-45v8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-09-02",
      "keywords": [
        "undefined_behavior"
      ],
      "url": "https://github.com/ebkalderon/renderdoc-rs/pull/32"
    },
    "affected": {
      "functions": {
        "renderdoc::api::RenderDocV110::trigger_multi_frame_capture": [
          "< 0.5.0"
        ],
        "renderdoc::api::RenderDocV120::set_capture_file_comments": [
          "< 0.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# Internally mutating methods take immutable ref self\n\nAffected versions of this crate exposed several methods which took `self` by\nimmutable reference, despite the requesting the RenderDoc API to set a mutable\nvalue internally.\n\nThis is technically unsound and calling these methods from multiple threads\nwithout synchronization could lead to unexpected and unpredictable behavior.\n\nThe flaw was corrected in release 0.5.0.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0076",
      "package": "wasmtime",
      "date": "2022-11-10",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory",
        "allocator",
        "Wasm",
        "bounds",
        "sandbox",
        "paging"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "aliases": [
        "CVE-2022-39392",
        "GHSA-44mr-8vmm-wjhg"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.2, < 2.0.0",
        ">= 2.0.2"
      ]
    },
    "affected": {
      "functions": {
        "wasmtime::PoolingAllocationConfig::instance_memory_pages": [
          ">= 2.0.0, < 2.0.2"
        ],
        "wasmtime::Config::allocation_strategy": [
          "< 1.0.2"
        ]
      }
    },
    "text": "\n\n# Bug in Wasmtime implementation of pooling instance allocator\n\nBug in Wasmtime's implementation of its pooling instance allocator when the allocator is configured to give WebAssembly instances a maximum of zero pages of memory.\n\nIn this configuration, the virtual memory mapping for WebAssembly memories did not meet the compiler-required configuration requirements for safely executing WebAssembly modules. Wasmtime's default settings require virtual memory page faults to indicate that wasm reads/writes are out-of-bounds, but the pooling allocator's configuration would not create an appropriate virtual memory mapping for this meaning out of bounds reads/writes can successfully read/write memory unrelated to the wasm sandbox within range of the base address of the memory mapping created by the pooling allocator.\n\nThis bug is not applicable with the default settings of the `wasmtime` crate.\n\nThis bug can only be triggered by setting `InstanceLimits::memory_pages` to zero.\n\nThis is expected to be a very rare configuration since this means that wasm modules cannot allocate any pages of linear memory.\n\nAll wasm modules produced by all current toolchains are highly likely to use linear memory, so it's expected to be unlikely that this configuration is set to zero by any production embedding of Wasmtime.\n",
    "likely_poc": [
      "https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0110",
      "package": "wasmtime",
      "date": "2021-09-17",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf",
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49",
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "out-of-bounds read",
        "out-of-bounds write",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2021-39216",
        "CVE-2021-39218",
        "CVE-2021-39219",
        "GHSA-4873-36h9-wv49",
        "GHSA-q879-9g95-56mx",
        "GHSA-v4cp-h94r-m7xf"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.30.0"
      ],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "wasmtime::Store::gc": [
          "< 0.30.0"
        ],
        "wasmtime::Linker::func_wrap": [
          "< 0.30.0"
        ],
        "wasmtime::Linker::func_new": [
          "< 0.30.0"
        ]
      }
    },
    "text": "\n\n# Multiple Vulnerabilities in Wasmtime\n\n* [Use after free passing `externref`s to Wasm in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf)\n\n* [Out-of-bounds read/write and invalid free with `externref`s and GC safepoints\n  in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49)\n\n* [Wrong type for `Linker`-define functions when used across two\n  `Engine`s](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx)\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0016",
      "package": "wasmtime",
      "date": "2022-03-31",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2022-24791",
        "GHSA-gwc9-348x-qwv2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.35.2",
        ">= 0.34.2, < 0.35.0"
      ],
      "unaffected": [
        "< 0.34.0"
      ]
    },
    "affected": {
      "functions": {
        "wasmtime::Config::epoch_interruption": [
          "0.34.0",
          "0.34.1",
          "0.35.0",
          "0.35.1"
        ]
      }
    },
    "text": "\n\n# Use after free with `externref`s and epoch interruption in Wasmtime\n\n[Use after free with `externref`s and epoch interruption in Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2)\n",
    "likely_poc": [
      "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0075",
      "package": "wasmtime",
      "date": "2022-11-10",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
        "https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6"
      ],
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2022-39393",
        "GHSA-wh6w-3828-g9qf"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.2, < 2.0.0",
        ">= 2.0.2"
      ]
    },
    "text": "\n\n# Bug in pooling instance allocator\n\nbug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance.\n\nMitigations are described [here](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf).\n",
    "likely_poc": [
      "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
      "https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0015",
      "package": "ascii",
      "date": "2023-02-25",
      "url": "https://github.com/tomprogrammer/rust-ascii/issues/64",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "ascii"
      ],
      "aliases": [
        "GHSA-mrrw-grhq-86gf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.3"
      ],
      "unaffected": [
        "<= 0.6.0"
      ]
    },
    "text": "\n\n# Ascii allows out-of-bounds array indexing in safe code\n\nAffected version of this crate had implementation of `From<&mut AsciiStr>` for `&mut [u8]` and `&mut str`. This can result in out-of-bounds array indexing in safe code.\n\nThe flaw was corrected in commit [8a6c779](https://github.com/tomprogrammer/rust-ascii/pull/63/commits/8a6c7798c202766bd57d70fb8d12739dd68fb9dc) by removing those impls.\n",
    "likely_poc": [
      "https://github.com/tomprogrammer/rust-ascii/issues/64"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0104",
      "package": "gfwx",
      "aliases": [
        "CVE-2020-36211",
        "GHSA-xp6v-qx65-4pp7"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-08",
      "url": "https://github.com/Devolutions/gfwx-rs/issues/7",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# ImageChunkMut needs bounds on its Send and Sync traits\n\nIn the affected versions of this crate, `ImageChunkMut<'_, T>` unconditionally implements `Send` and `Sync`, allowing to create data races.\n\nThis can result in a memory corruption or undefined behavior when non thread-safe types are moved and referenced across thread boundaries.\n\nThe flaw was corrected in commit e7fb2f5 by adding `T: Send` bound to the `Send` impl and adding `T: Sync` bound to the `Sync` impl.\n",
    "likely_poc": [
      "https://github.com/Devolutions/gfwx-rs/issues/7"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0047",
      "package": "array-queue",
      "aliases": [
        "CVE-2020-35900",
        "GHSA-75cq-g75g-rxff"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
      "date": "2020-09-26",
      "keywords": [
        "memory-corruption",
        "uninitialized-memory",
        "use-after-free"
      ],
      "url": "https://github.com/raviqqe/array-queue/issues/2"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# array_queue pop_back() may cause a use-after-free\n\narray_queue implements a circular queue that wraps around an array. However, it\nfails to properly index into the array in the `pop_back` function allowing the\nreading of previously dropped or uninitialized memory.\n",
    "likely_poc": [
      "https://github.com/raviqqe/array-queue/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0027",
      "package": "traitobject",
      "aliases": [
        "CVE-2020-35881",
        "GHSA-j79j-cx3h-g27h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-06-01",
      "informational": "unsound",
      "url": "https://github.com/reem/rust-traitobject/issues/7"
    },
    "affected": {
      "functions": {
        "traitobject::data": [],
        "traitobject::data_mut": []
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# traitobject assumes the layout of fat pointers\n\nThis crate gets the data pointer from fat pointers assuming that the first\nelement in a fat pointer is the data pointer. This is currently true, but\nit may change in a future Rust version, leading to memory corruption.\n\nThis has been fixed in the master branch of the crate, but is has not\nbeen released into crates.io.\n",
    "likely_poc": [
      "https://github.com/reem/rust-traitobject/issues/7"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0033",
      "package": "alg_ds",
      "date": "2020-08-25",
      "url": "https://gitlab.com/dvshapkin/alg-ds/-/issues/1",
      "aliases": [
        "CVE-2020-36432",
        "GHSA-3vv3-frrq-6486"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Matrix::new() drops uninitialized memory\n\n`Matrix::new()` internally calls `Matrix::fill_with()` which uses `*ptr = value` pattern to initialize the buffer.\nThis pattern assumes that there is an initialized struct at the address and drops it, which results in dropping of uninitialized struct.\n",
    "likely_poc": [
      "https://gitlab.com/dvshapkin/alg-ds/-/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0164",
      "package": "cell-project",
      "date": "2020-08-27",
      "url": "https://github.com/RustyYato/cell-project/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "cell",
        "subtype",
        "variance"
      ],
      "informational": "unsound",
      "references": [
        "https://github.com/RustyYato/cell-project/issues/3",
        "https://github.com/RustyYato/cell-project/issues/4"
      ],
      "aliases": [
        "GHSA-p75v-367r-2v23"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.4"
      ]
    },
    "affected": {
      "functions": {
        "cell_project::cell_project": [
          "< 0.1.4"
        ],
        "cell_project::nightly_cell_project": [
          "< 0.1.4"
        ]
      }
    },
    "text": "\n\n# `cell-project` used incorrect variance when projecting through `&Cell<T>`\n\n## Overview\n\nThe issue lies in the implementation of the `cell_project` macro which used `field as *const _` instead of `field as *mut _`.\nThe problem being that `*const T` is covariant in `T` while `*mut T` is invariant in `T`. Keep in mind that `&Cell<T>` is invariant in `T`,\nso casting to `*const T` relaxed the variance, and lead to unsoundness, as shown in the example below.\n\n```rs\nuse std::cell::Cell;\nuse cell_project::cell_project as cp;\n\nstruct Foo<'a> {\n    x: Option<&'a Cell<Foo<'a>>>,\n}\n\nimpl<'a> Drop for Foo<'a> {\n    fn drop(&mut self) {\n        // `ourselves` is an &Cell<Self>.\n        // NB: `Drop` is unsound.\n        if let Some(ourselves) = self.x.as_ref() {\n            // replace `self` (but this doesn't actually replace `self`)\n            let is_x_none = ourselves.replace(Foo {\n                x: None,\n            }).x.as_ref().is_none();\n            // if we just moved out of `self`, and we had a `Some` originally,\n            // how come this is a `None`?\n            if is_x_none {\n                println!(\"how did we get a None?\");\n            }\n        }\n    }\n}\n\nfn main() {\n    let foo = Cell::new(Foo {\n        x: None,\n    });\n    let x = cp!(Foo<'_>, foo.x);\n    x.set(Some(&foo));\n}\n```\n\n### MIRI error\n\n```rs\n$ cargo +nightly miri run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `<snip>`\nerror: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <2472> (call 796)]\n   --> $RUST_STD_PATH/src/rust/library/core/src/cell.rs:404:31\n    |\n404 |         mem::replace(unsafe { &mut *self.value.get() }, val)\n    |                               ^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <2472> (call 796)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n\n    = note: inside `std::cell::Cell::<Foo>::replace` at $RUST_STD_PATH/src/rust/library/core/src/cell.rs:404:31\nnote: inside `<Foo as std::ops::Drop>::drop` at src/main.rs:14:29\n   --> src/main.rs:14:29\n    |\n14  |               let is_x_none = ourselves.replace(Foo {\n    |  _____________________________^\n15  | |                 x: None,\n16  | |             }).x.as_ref().is_none();\n    | |______________^\n    = note: inside `std::ptr::drop_in_place::<Foo> - shim(Some(Foo))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\n    = note: inside `std::ptr::drop_in_place::<std::cell::UnsafeCell<Foo>> - shim(Some(std::cell::UnsafeCell<Foo>))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\n    = note: inside `std::ptr::drop_in_place::<std::cell::Cell<Foo>> - shim(Some(std::cell::Cell<Foo>))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\nnote: inside `main` at src/main.rs:32:1\n   --> src/main.rs:32:1\n    |\n32  | }\n    | ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to previous error\n```\n\n## Affected Versions\n\nAll versions of the cell-project crate before `0.1.4` are affected.\n\n## Mitigation\n\nThis was fixed in [Issues/4], and released as version `0.1.4`.\nSo just updating to the latest version will include the fix (which may result in a compile error on unsound usage).\n\n## Acknowledgements\n\nThis was discovered and fixed by @SoniEx2 in cell-project: [Issues/3] and [Issues/4]\n\n[issues/3]: https://github.com/RustyYato/cell-project/issues/3\n[issues/4]: https://github.com/RustyYato/cell-project/issues/4\n",
    "likely_poc": [
      "https://github.com/RustyYato/cell-project/issues/3",
      "https://github.com/RustyYato/cell-project/issues/3",
      "https://github.com/RustyYato/cell-project/issues/4"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0070",
      "package": "secp256k1",
      "date": "2022-11-30",
      "url": "https://github.com/rust-bitcoin/rust-secp256k1/issues/543",
      "references": [
        "https://github.com/rust-bitcoin/rust-secp256k1/pull/548"
      ],
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "unsound-api",
        "invalid-free"
      ],
      "aliases": [
        "GHSA-969w-q74q-9j8v"
      ]
    },
    "affected": {
      "functions": {
        "secp256k1::Secp256k1::preallocated_gen_new": [
          "< 0.22.2",
          ">= 0.23.0, < 0.23.5",
          ">= 0.24.0, < 0.24.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.22.2, < 0.23.0",
        ">= 0.23.5, < 0.24.0",
        ">= 0.24.2"
      ],
      "unaffected": [
        "< 0.14.0"
      ]
    },
    "text": "\n\n# Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code\n\nBecause of incorrect bounds on method `Secp256k1::preallocated_gen_new` it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.\n\nThe method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses `unsafe` and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. `'static`). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.\n\nYou are unaffected if you either\n\n* don't call `Secp256k1::preallocated_gen_new`\n* manually checked that your usage of the method is sound\n* upgraded to the patched version of `secp256k1` (recommended)\n\nThe patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straightforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.\n\nSee the [GitHub issue](https://github.com/rust-bitcoin/rust-secp256k1/issues/543) for example \"exploit\" code and further discussion.\n",
    "likely_poc": [
      "https://github.com/rust-bitcoin/rust-secp256k1/issues/543",
      "https://github.com/rust-bitcoin/rust-secp256k1/pull/548"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0018",
      "package": "remove_dir_all",
      "date": "2023-02-24",
      "url": "https://github.com/XAMPPRocky/remove_dir_all/commit/7247a8b6ee59fc99bbb69ca6b3ca4bfd8c809ead",
      "references": [
        "https://github.com/advisories/GHSA-mc8h-8q98-g5hr"
      ],
      "keywords": [
        "TOCTOU"
      ],
      "aliases": [
        "GHSA-mc8h-8q98-g5hr"
      ]
    },
    "affected": {
      "functions": {
        "remove_dir_all::remove_dir_all": [
          "< 0.8.0"
        ],
        "remove_dir_all::remove_dir_contents": [
          "< 0.8.0"
        ],
        "remove_dir_all::ensure_empty_dir": [
          "< 0.8.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ]
    },
    "text": "\n\n# Race Condition Enabling Link Following and Time-of-check Time-of-use (TOCTOU)\n\nThe remove_dir_all crate is a Rust library that offers additional features over the Rust\nstandard library fs::remove_dir_all function.\n\nIt was possible to trick a privileged process doing a recursive delete in an\nattacker controlled directory into deleting privileged files, on all operating systems.\n\nFor instance, consider deleting a tree called 'etc' in a parent directory\ncalled 'p'. Between calling `remove_dir_all(\"a\")` and remove_dir_all(\"a\")\nactually starting its work, the attacker can move 'p' to 'p-prime', and\nreplace 'p' with a symlink to '/'. Then the privileged process deletes 'p/etc'\nwhich is actually /etc, and now your system is broken. There are some\nmitigations for this exact scenario, such as CWD relative file lookup, but\nthey are not guaranteed - any code using absolute paths will not have that\nprotection in place.\n\nThe same attack could be performed at any point in the directory tree being\ndeleted: if 'a' contains a child directory called 'etc', attacking the\ndeletion by replacing 'a' with a link is possible.\n\nThe new code in this release mitigates the attack within the directory tree\nbeing deleted by using file-handle relative operations: to open 'a/etc', the\npath 'etc' relative to 'a' is opened, where 'a' is represented by a file\ndescriptor (Unix) or handle (Windows). With the exception of the entry points\ninto the directory deletion logic, this is robust against manipulation of the\ndirectory hierarchy, and remove_dir_all will only delete files and directories\ncontained in the tree it is deleting.\n\nThe entry path however is a challenge - as described above, there are some\npotential mitigations, but since using them must be done by the calling code,\nit is hard to be confident about the security properties of the path based\ninterface.\n\nThe new extension trait `RemoveDir` provides an interface where it is much\nharder to get it wrong.\n\n`somedir.remove_dir_contents(\"name-of-child\")`.\n\nCallers can then make their own security evaluation about how to securely get\na directory handle. That is still not particularly obvious, and we're going to\nfollow up with a helper of some sort (probably in the `fs_at` crate). Once\nthat is available, the path based entry points will get deprecated.\n\nIn the interim, processes that might run with elevated privileges should\nfigure out how to securely identify the directory they are going to delete, to\navoid the initial race. Pragmatically, other processes should be fine with the\npath based entry points : this is the same interface `std::fs::remove_dir_all`\noffers, and an unprivileged process running in an attacker controlled\ndirectory can't do anything that the attacker can't already do.\n",
    "likely_poc": [
      "https://github.com/XAMPPRocky/remove_dir_all/commit/7247a8b6ee59fc99bbb69ca6b3ca4bfd8c809ead"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0092",
      "package": "messagepack-rs",
      "date": "2021-01-26",
      "url": "https://github.com/otake84/messagepack-rs/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2021-45690",
        "CVE-2021-45691",
        "CVE-2021-45692",
        "CVE-2021-45693",
        "GHSA-hr52-f9vp-582c",
        "GHSA-jqjj-r4qp-x2gh",
        "GHSA-jwfh-j623-m97h",
        "GHSA-m325-rxjv-pwph",
        "GHSA-vw5m-qw2r-m923"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Deserialization functions pass uninitialized memory to user-provided Read\n\nAffected versions of this crate passed an uninitialized buffer to a\nuser-provided `Read` instance in:\n\n* `deserialize_binary`\n* `deserialize_string`\n* `deserialize_extension_others`\n* `deserialize_string_primitive`\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0360",
      "package": "xmp_toolkit",
      "date": "2024-07-26",
      "url": "https://github.com/adobe/xmp-toolkit-rs/issues/233",
      "informational": "unsound",
      "keywords": [
        "xmp"
      ]
    },
    "affected": {
      "functions": {
        "xmp_toolkit::XmpFile::close": [
          "< 1.9.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.9.0"
      ]
    },
    "text": "\n\n# `XmpFile::close` can trigger UB\n\nAffected versions of the crate failed to catch C++ exceptions raised within the `XmpFile::close` function. If such an exception occured, it would trigger undefined behavior, typically a process abort.\n\nThis is best demonstrated in [issue #230](https://github.com/adobe/xmp-toolkit-rs/issues/230), where a race condition causes the `close` call to fail due to file I/O errors.\n\nThis was fixed in [PR #232](https://github.com/adobe/xmp-toolkit-rs/pull/232) (released as crate version 1.9.0), which now safely handles the exception.\n\nFor backward compatibility, the existing API ignores the error. A new API `XmpFile::try_close` was added to allow callers to receive and process the error result.\n\nUsers of all prior versions of `xmp_toolkit` are encouraged to update to version 1.9.0 to avoid undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0060",
      "package": "libwebp-sys2",
      "date": "2023-09-12",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "webp"
      ],
      "aliases": [
        "CVE-2023-4863",
        "CVE-2023-5129",
        "GHSA-j7hp-h8jx-5ppr"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.8"
      ]
    },
    "text": "\n\n# libwebp: OOB write in BuildHuffmanTable\n\n[Google](https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html) and [Mozilla](https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/) have released security advisories for RCE due to heap overflow in libwebp. Google warns the vulnerability has been exploited in the wild.\n\nlibwebp needs to be updated to 1.3.2 to include a patch for \"OOB write in BuildHuffmanTable\".\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0063",
      "package": "linked_list_allocator",
      "date": "2022-09-07",
      "url": "https://github.com/advisories/GHSA-xg8p-34w2-j49j",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2022-36086",
        "GHSA-xg8p-34w2-j49j"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.10.2"
      ],
      "unaffected": []
    },
    "text": "\n\n# Multiple vulnerabilities resulting in out-of-bounds writes\n\n* The heap initialization methods were missing a minimum size check for the given heap size argument. This could lead to **out-of-bound writes** when a heap was initialized with a size smaller than `3 * size_of::<usize>` because of metadata write operations.\n* When calling `Heap::extend` with a size smaller than two `usize`s (e.g., 16 on `x86_64`), the size was erroneously rounded up to the minimum size, which could result in an **out-of-bounds write**.\n* Calling `Heap::extend` on an empty heap tried to construct a heap starting at address 0, which is also an **out-of-bounds write**.\n  * One specific way to trigger this accidentally is to call `Heap::new` (or a similar constructor) with a heap size that is smaller than two `usize`s. This was treated as an empty heap as well.\n* Calling `Heap::extend` on a heap whose size is not a multiple of the size of two `usize`s resulted in unaligned writes. It also left the heap in an unexpected state, which might lead to subsequent issues. We did not find a way to exploit this undefined behavior yet (apart from DoS on platforms that fault on unaligned writes).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0017",
      "package": "cassandra-cpp",
      "date": "2024-02-28",
      "url": "https://github.com/Metaswitch/cassandra-rs/security/advisories/GHSA-x9xc-63hg-vcfq",
      "informational": "unsound",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory-safety",
        "use-after-free"
      ],
      "aliases": [
        "CVE-2024-27284",
        "GHSA-x9xc-63hg-vcfq"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.0.0"
      ]
    },
    "text": "\n\n# Non-idiomatic use of iterators leads to use after free\n\nCode that attempts to use an item (e.g., a row) returned by an iterator after the iterator has advanced to the next item will be accessing freed memory and experience undefined behaviour. Code that uses the item and then advances the iterator is unaffected. This problem has always existed.\n\nThis is a use-after-free bug, so it's rated high severity. If your code uses a pre-3.0.0 version of cassandra-rs, and uses an item returned by a cassandra-rs iterator after calling `next()` on that iterator, then it is vulnerable. However, such code will almost always fail immediately - so we believe it is unlikely that any code using this pattern would have reached production. For peace of mind, we recommend you upgrade anyway.\n\n## Patches\n\nThe problem has been fixed in version 3.0.0 (commit 299e6ac50f87eb2823a373baec37b590a74994ee). Users should upgrade to ensure their code cannot use the problematic pattern. There is an upgrade guide in the project README.\n\n## Workarounds\n\nEnsure all usage fits the expected pattern. For example, use `get_first_row()` rather than an iterator, or completely process an item before advancing the iterator with `next()`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0023",
      "package": "string-interner",
      "aliases": [
        "CVE-2019-16882",
        "GHSA-49fq-pw77-6qxj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2019-08-24",
      "keywords": [
        "use after free"
      ],
      "url": "https://github.com/Robbepop/string-interner/issues/9"
    },
    "versions": {
      "patched": [
        "^0.6.4",
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# Cloned interners may read already dropped strings\n\nAffected versions of this crate did not clone contained strings when an interner is cloned.\nInterners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned.\nIf a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.\n\nThis allows an attacker to read the already freed memory.\nThe dangling pointers are used by the interners to check a string is already interned.\nAn attacker can do brute force attack to get the data pointed by the dangling pointer.\n\nThe flaw was corrected by <https://github.com/Robbepop/string-interner/pull/10>.\nThis patch implements `Clone` manually to the interner type, so that the internal raw pointers always point the strings owned by the same interner.\n\nPR #10 was also backported to the 0.6 release line in\n<https://github.com/Robbepop/string-interner/pull/14> and was released in 0.6.4.\n",
    "likely_poc": [
      "https://github.com/Robbepop/string-interner/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0052",
      "package": "os_socketaddr",
      "date": "2022-08-26",
      "url": "https://github.com/a-ba/os_socketaddr/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-c439-chv8-8g2j"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.2"
      ]
    },
    "text": "\n\n# `os_socketaddr` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`os_socketaddr`](https://crates.io/crates/os_socketaddr) crate has assumed\n`std::net::SocketAddrV4` and `std::net::SocketAddrV6` have the same memory layout as the system C\nrepresentation `sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation.\n\nThese layout were [changed into idiomatic rust types](https://github.com/rust-lang/rust/pull/78802)\nin nightly `std`. Starting from rustc 1.64 the affected versions of this crate will have undefined\nbehaviour.\n\n",
    "likely_poc": [
      "https://github.com/a-ba/os_socketaddr/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0033",
      "package": "borsh",
      "date": "2023-04-12",
      "url": "https://github.com/near/borsh-rs/issues/19",
      "references": [
        "https://github.com/near/borsh-rs/pull/136"
      ],
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-fjx5-qpf4-xjf2"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 1.0.0-alpha.1",
        "^0.10.4"
      ]
    },
    "text": "\n\n# Parsing borsh messages with ZST which are not-copy/clone is unsound\n\nAffected versions of borsh cause undefined behavior when zero-sized-types (ZST) \nare parsed and the Copy/Clone traits are not implemented/derived.\nFor instance if 1000 instances of a ZST are deserialized, and the ZST is not copy \n(this can be achieved through a singleton), then accessing/writing to deserialized \ndata will cause a segmentation fault.\n\nThere is currently no way for borsh to read data without also providing a Rust type. \nTherefore, if not ZST are used for serialization, then you are not affected by this issue. \n",
    "likely_poc": [
      "https://github.com/near/borsh-rs/issues/19"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0359",
      "package": "gix-attributes",
      "date": "2024-07-24",
      "url": "https://github.com/Byron/gitoxide/issues/1460",
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.22.3"
      ]
    },
    "text": "\n\n# The kstring integration in gix-attributes is unsound\n\n`gix-attributes` (in [`state::ValueRef`](https://github.com/Byron/gitoxide/blob/gix-attributes-v0.22.2/gix-attributes/src/state.rs#L19-L27)) unsafely creates a `&str` from a `&[u8]` containing non-UTF8 data, with the justification that so long as nothing reads the `&str` and relies on it being UTF-8 in the `&str`, there is no UB:\n\n```rust\n// SAFETY: our API makes accessing that value as `str` impossible, so illformed UTF8 is never exposed as such.\n```\n\nThe problem is that the non-UTF8 `str` **is** exposed to outside code: first to the `kstring` crate itself, which requires UTF-8 in its documentation and may have UB as a consequence of this, but also to `serde`, where it propagates to e.g. `serde_json`, `serde_yaml`, etc., where the same problems occur.\n\nThis is not sound, and it could cause further UB down the line in these places that can view the `&str`.\n",
    "likely_poc": [
      "https://github.com/Byron/gitoxide/issues/1460"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0021",
      "package": "stb_image",
      "date": "2023-03-19",
      "url": "https://github.com/servo/rust-stb-image/pull/102",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "NULL-pointer-dereference"
      ],
      "aliases": [
        "GHSA-ppjr-267j-5p9x"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.5"
      ]
    },
    "text": "\n\n# NULL pointer dereference in `stb_image`\n\nA bug in error handling in the `stb_image` C library could cause a NULL pointer dereference when attempting to load an invalid or unsupported image file.  This is fixed in version 0.2.5 and later of the `stb_image` Rust crate, by patching the C code to correctly handle NULL pointers.\n\nThank you to GitHub user 0xdd96 for finding and fixing this vulnerability.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0347",
      "package": "zerovec",
      "date": "2024-07-01",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.4",
        ">= 0.9.7, <0.10.0"
      ]
    },
    "text": "\n\n# Incorrect usage of `#[repr(packed)]`\n\nThe affected versions make unsafe memory accesses under the assumption that `#[repr(packed)]` has a guaranteed field order. \n\nThe Rust specification does not guarantee this, and https://github.com/rust-lang/rust/pull/125360 (1.80.0-beta) starts \nreordering fields of `#[repr(packed)]` structs, leading to illegal memory accesses.\n\nThe patched versions `0.9.7` and `0.10.4` use `#[repr(C, packed)]`, which guarantees field order.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0079",
      "package": "elf_rs",
      "date": "2022-10-31",
      "url": "https://github.com/vincenthouyi/elf_rs/issues/11",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "elf",
        "header"
      ],
      "aliases": [
        "GHSA-g6pw-999w-j75m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "affected": {},
    "text": "\n\n# ELF header parsing library doesn't check for valid offset\n\nThe crate has several unsafe sections that don't perform proper pointer validation.\n\nAn example can be found in the following function:\n\n```\nfn section_header_raw(&self) -> &[ET::SectionHeader] {\n    let sh_off = self.elf_header().section_header_offset() as usize;\n    let sh_num = self.elf_header().section_header_entry_num() as usize;\n    unsafe {\n        let sh_ptr = self.content().as_ptr().add(sh_off);\n        from_raw_parts(sh_ptr as *const ET::SectionHeader, sh_num)\n    }\n}\n```\n\nWhile this will work perfectly fine *if* the ELF header is valid, malicious or\nmalformed input can contain a section header offset of an arbitrary size, meaning\nthat the resultant pointer in the unsafe block can point to an artibrary address\nin the address space of the process.\n\nThis can result in unpredictable behaviour, and in our fuzz testing, we discovered\nthat it's trivial to cause SIGABRT (signal 6), or SEGV (signal 11).\n\nThe function should either be marked as unsafe, with a note that the caller is responsible\nfor providing only valid inputs, or it should ideally do the due diligence to ensure that the\noffset doesn't exceed the bounds of the header (and add additional checks as necessary).\n\n",
    "likely_poc": [
      "https://github.com/vincenthouyi/elf_rs/issues/11"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0067",
      "package": "cranelift-codegen",
      "date": "2021-05-21",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "miscompile",
        "sandbox",
        "wasm"
      ],
      "aliases": [
        "CVE-2021-32629",
        "GHSA-hpqh-2wqx-7qp5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.73.1"
      ]
    },
    "affected": {
      "arch": [
        "x86"
      ]
    },
    "text": "\n\n# Memory access due to code generation flaw in Cranelift module\n\nThere is a bug in 0.73.0 of the Cranelift x64 backend that can create a\nscenario that could result in a potential sandbox escape in a WebAssembly\nmodule. Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1\nor 0.74 to remediate this vulnerability. Users of Cranelift prior to 0.73.0\nshould update to 0.73.1 or 0.74 if they were not using the old default backend.\n\nMore details can be found in the GitHub Security Advisory at:\n\n<https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5>\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0080",
      "package": "transpose",
      "date": "2023-12-18",
      "url": "https://github.com/ejmahler/transpose/issues/11",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-5gmm-6m36-r7jh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "affected": {
      "functions": {
        "transpose::transpose": [
          ">= 0.1.0"
        ]
      }
    },
    "text": "\n\n# Buffer overflow due to integer overflow in `transpose`\n\nGiven the function `transpose::transpose`:\n```rust\nfn transpose<T: Copy>(input: &[T], output: &mut [T], input_width: usize, input_height: usize)\n```\n\nThe safety check `input_width * input_height == output.len()` can fail due to `input_width * input_height` overflowing in such a way that it equals `output.len()`.\nAs a result of failing the safety check, memory past the end of `output` is written to. This only occurs in release mode since `*` panics on overflow in debug mode.\n\nExploiting this issue requires the caller to pass `input_width` and `input_height` arguments such that multiplying them overflows, and the overflown result equals the lengths of input and output slices.\n",
    "likely_poc": [
      "https://github.com/ejmahler/transpose/issues/11"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0047",
      "package": "slice-deque",
      "aliases": [
        "CVE-2021-29938",
        "GHSA-p9gf-gmfv-398m"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-02-19",
      "url": "https://github.com/gnzlbg/slice_deque/issues/90",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# SliceDeque::drain_filter can double drop an element if the predicate panics\n\nAffected versions of the crate incremented the current index of the drain filter\niterator *before* calling the predicate function `self.pred`.\n\nIf the predicate function panics, it is possible for the last element in the\niterator to be dropped twice.\n",
    "likely_poc": [
      "https://github.com/gnzlbg/slice_deque/issues/90"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0002",
      "package": "slice-deque",
      "date": "2019-05-07",
      "aliases": [
        "CVE-2019-15543",
        "GHSA-c3m3-c39q-pv23"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "related": [
        "RUSTSEC-2018-0008"
      ],
      "keywords": [
        "memory-corruption",
        "rce"
      ],
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Bug in SliceDeque::move_head_unchecked corrupts its memory\n\nAffected versions of this crate entered a corrupted state if\n`mem::size_of::<T>() % allocation_granularity() != 0` and a specific allocation\npattern was used: sufficiently shifting the deque elements over the mirrored\npage boundary.\n\nThis allows an attacker that controls controls both element insertion and\nremoval to corrupt the deque, such that reading elements from it would read\nbytes corresponding to other elements in the deque. (e.g. a read of T could read\nsome bytes from one value and some bytes from an adjacent one, resulting in a T\nwhose value representation is not meaningful). This is undefined behavior.\n \nThe flaw was corrected by using a pair of pointers to track the head and tail of\nthe deque instead of a pair of indices. This pair of pointers are represented\nusing a Rust slice.\n",
    "likely_poc": [
      "https://github.com/gnzlbg/slice_deque/issues/57"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0008",
      "package": "slice-deque",
      "aliases": [
        "CVE-2018-20995",
        "GHSA-hr3c-6mmp-6m39"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-12-05",
      "keywords": [
        "memory-corruption",
        "rce"
      ],
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    },
    "versions": {
      "patched": [
        ">= 0.1.16"
      ]
    },
    "text": "\n\n# Bug in SliceDeque::move_head_unchecked allows read of corrupted memory\n\nAffected versions of this crate did not properly update the\nhead and tail of the deque when inserting and removing elements from the front\nif, before insertion or removal, the tail of the deque was in the mirrored\nmemory region, and if, after insertion or removal, the head of the deque is\nexactly at the beginning of the mirrored memory region.\n\nAn attacker that controls both element insertion and removal into the deque\ncould put it in a corrupted state. Once the deque enters such an state, its head\nand tail are corrupted, but in bounds of the allocated memory. This can result\nin partial reads and writes, reads of uninitialized memory, reads of memory\ncontaining previously dropped objects, etc. An attacker could exploit this to\nalter program execution.\n\nThe flaw was corrected by properly updating the head and tail of the deque in\nthis case. \n",
    "likely_poc": [
      "https://github.com/gnzlbg/slice_deque/issues/57"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0374",
      "package": "ouch",
      "date": "2024-09-22",
      "url": "https://github.com/ouch-org/ouch/issues/707",
      "categories": [
        "memory-corruption"
      ]
    },
    "affected": {
      "functions": {
        "ouch::archive::zip::convert_zip_date_time": [
          "<=0.3.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">0.3.1"
      ]
    },
    "text": "\n# Segmentation fault due to use of uninitialized memory\nWhen trying to decompress a file using \"ouch\", we can reach the function \"ouch::archive::zip::convert_zip_date_time\".\nIn the function, there is a unsafe function, \"transmute\". Once the \"transmute\" function is called to convert the type of \"month\" object,\nthe address of the object is changed to the uninitialized memory region. \nAfter that, when other function tries to dereference \"month\", segmentation fault occurs.\n",
    "likely_poc": [
      "https://github.com/ouch-org/ouch/issues/707"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0138",
      "package": "mz-avro",
      "date": "2021-10-14",
      "url": "https://github.com/MaterializeInc/materialize/issues/8669",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-jwh2-vrr9-vcp2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# Incorrect use of `set_len` allows for un-initialized memory\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` \nimplementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure)\nand also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke\nundefined behavior.\n\nNote: there is only UB in the case where a user provides a struct whose `Read`\nimplementation inspects the buffer passed to `read_exact` before writing to it.\nThis is an unidiomatic (albeit possible) `Read` implementation.\n\nSee https://github.com/MaterializeInc/materialize/issues/8669 for details.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0011",
      "package": "rust-crypto",
      "date": "2022-02-28",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "aesni"
      ],
      "aliases": [
        "GHSA-jp3w-3q88-34cf"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Miscomputation when performing AES encryption in rust-crypto\n\nThe following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.\n\nFor these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.\n\n```rust\nuse crypto::{\n    aes, blockmodes, buffer,\n    buffer::{BufferResult, ReadBuffer, WriteBuffer},\n    symmetriccipher,\n};\n\nfn encrypt(\n    key: &[u8],\n    iv: &[u8],\n    data: &str,\n) -> Result<String, symmetriccipher::SymmetricCipherError> {\n    let mut encryptor =\n        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);\n\n    let mut encrypted_data = Vec::<u8>::new();\n    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());\n    let mut buffer = [0; 4096];\n    let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);\n\n    loop {\n        let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true)?;\n\n        encrypted_data.extend(\n            write_buffer\n                .take_read_buffer()\n                .take_remaining()\n                .iter()\n                .copied(),\n        );\n\n        match result {\n            BufferResult::BufferUnderflow => break,\n            BufferResult::BufferOverflow => {}\n        }\n    }\n\n    Ok(hex::encode(encrypted_data))\n}\n\nfn working() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // The copy here makes the code work.\n    let key_copy = key;\n    let key2: Vec<u8> = key_copy.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn broken() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // This operation shouldn't affect the contents of key at all.\n    let key2: Vec<u8> = key.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn main() {\n    working();\n    broken();\n}\n```\n\nThe output from this program:\n\n```shell\n     Running `target/host/debug/rust-crypto-test`\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 90462bbe32965c8e7ea0addbbed4cddb\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 26e847e5e7df1947bf82a650548a7d5b\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `\"26e847e5e7df1947bf82a650548a7d5b\"`,\n right: `\"90462bbe32965c8e7ea0addbbed4cddb\"`', src/main.rs:83:5\n```\n\nNotably, the X1 key in the `broken()` test changes every time after rerunning the program.\n\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0021",
      "package": "linea",
      "aliases": [
        "CVE-2019-16880",
        "GHSA-j52m-489x-v634"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-09-14",
      "keywords": [
        "double free"
      ],
      "url": "https://github.com/strake/linea.rs/issues/2"
    },
    "versions": {
      "patched": [
        "> 0.9.4"
      ]
    },
    "text": "\n\n# `Matrix::zip_elements` causes double free\n\nAffected versions of this crate did not properly implements the `Matrix::zip_elements` method, which causes an double free when the given trait implementation might panic.\n\nThis allows an attacker to corrupt or take control of the memory.\n \nThe flaw was corrected by Phosphorus15.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0082",
      "package": "vec-const",
      "date": "2021-08-14",
      "url": "https://github.com/Eolu/vec-const/issues/1#issuecomment-898908241",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45680",
        "GHSA-jmwx-r3gq-qq3p",
        "GHSA-x76r-966h-5qv9"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# vec-const attempts to construct a Vec from a pointer to a const slice\n\nAffected versions of this crate claimed to construct a const `Vec` with nonzero length and capacity, but that cannot be done because such a `Vec` requires a pointer from an allocator.\n\nThe implementation was later changed to just construct a `std::borrow::Cow`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0139",
      "package": "dces",
      "date": "2020-12-09",
      "url": "https://gitlab.redox-os.org/redox-os/dces-rust/-/issues/8",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36459",
        "GHSA-hxw9-jxqw-jc8j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# dces' World type can cause data races\n\nThe `World` type in `dces` is marked as `Send` without bounds on its\n`EntityStore` and `ComponentStore`.\n\nThis allows non-thread safe `EntityStore` and `ComponentStore`s to be sent\nacross threads and cause data races.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0067",
      "package": "lzf",
      "date": "2022-10-22",
      "url": "https://github.com/badboy/lzf-rs/issues/9",
      "informational": "unsound",
      "keywords": [
        "uninitialized-memory"
      ],
      "aliases": [
        "GHSA-5m39-wx2q-mxg3"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ]
    },
    "affected": {
      "functions": {
        "lzf::compress": [
          "< 0.3.2"
        ],
        "lzf::decompress": [
          "< 0.3.2"
        ]
      }
    },
    "text": "\n\n#  Invalid use of `mem::uninitialized` causes `use-of-uninitialized-value`\n\nThe compression and decompression function used `mem:uninitialized`\nto create an array of uninitialized values, to later write values into it.\nThis later leads to reads from uninitialized memory.\n\nThe flaw was corrected in commit b633bf265e41c60dfce3be7eac4e4dd5e18d06cf\nby using a heap-allocated `Vec` and removing out use of `mem::uninitialized`.\nThe fix was released in v0.3.2 and v1.0.0\n\nSubsequently the crate was deprecated and its use is discouraged.\n",
    "likely_poc": [
      "https://github.com/badboy/lzf-rs/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0068",
      "package": "iced-x86",
      "date": "2021-05-19",
      "url": "https://github.com/icedland/iced/issues/168",
      "keywords": [
        "soundness"
      ],
      "aliases": [
        "CVE-2021-38188",
        "GHSA-jjx5-3f36-6927"
      ]
    },
    "affected": {
      "functions": {
        "iced_x86::Decoder::new": [
          "<= 1.10.3"
        ]
      }
    },
    "versions": {
      "patched": [
        "> 1.10.3"
      ]
    },
    "text": "\n\n# Soundness issue in `iced-x86` versions <= 1.10.3 \n\nVersions of iced-x86 <= 1.10.3 invoke undefined behavior which may cause soundness\nissues in crates using the `iced_x86::Decoder` struct. The `Decoder::new()` function\nmade a call to `slice.get_unchecked(slice.length())` to get the end position of \nthe input buffer. The flaw was fixed with safe logic that does not invoke undefined\nbehavior.\n\nMore details can be found at <https://github.com/icedland/iced/issues/168>.\n",
    "likely_poc": [
      "https://github.com/icedland/iced/issues/168"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0038",
      "package": "ordnung",
      "aliases": [
        "CVE-2020-35890",
        "CVE-2020-35891",
        "GHSA-4wj3-p7hj-cvx8",
        "GHSA-qrwc-jxf5-g8x6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-03",
      "url": "https://github.com/maciejhirsz/ordnung/issues/8"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Memory safety issues in `compact::Vec`\n\n`compact::Vec` contains multiple memory safety issues.\n\n1. It mishandles large capacity and causes out-of-bound access in 32-bit / allocator layout mismatch in 64-bit.\n2. `remove()` is not panic-safe and causes double-free when an index larger than the length is provided.\n",
    "likely_poc": [
      "https://github.com/maciejhirsz/ordnung/issues/8"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0049",
      "package": "iana-time-zone",
      "date": "2022-08-15",
      "url": "https://github.com/strawlab/iana-time-zone/pull/54",
      "references": [
        "https://github.com/strawlab/iana-time-zone/pull/50#discussion_r945353515"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-3fg9-hcq5-vxrc"
      ]
    },
    "affected": {
      "os": [
        "ios",
        "macos"
      ],
      "functions": {
        "iana_time_zone::get_timezone": [
          "> 0.1.42, < 0.1.45"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.45"
      ],
      "unaffected": [
        "< 0.1.43"
      ]
    },
    "text": "\n\n# Use after free in MacOS / iOS implementation\n\nIn iana-time-zone v0.1.43 a use-after-free bug in the MacOS / iOS implementation was introduced.\n\nThe copied system time zone was released before its name was copied.\nIf the system time zone was changed between the call of `CFRelease` and `str::to_owned()`,\nrandom memory would be copied.\n",
    "likely_poc": [
      "https://github.com/strawlab/iana-time-zone/pull/54",
      "https://github.com/strawlab/iana-time-zone/pull/50#discussion_r945353515"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0107",
      "package": "hashconsing",
      "aliases": [
        "CVE-2020-36215",
        "GHSA-rw2c-c256-3r53"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/AdrienChampion/hashconsing/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.0"
      ]
    },
    "text": "\n\n# hashconsing's HConsed lacks Send/Sync bound for its Send/Sync trait.\n\nAffected versions of `hashconsing` implements `Send`/`Sync` for its `HConsed` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.\n",
    "likely_poc": [
      "https://github.com/AdrienChampion/hashconsing/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0157",
      "package": "vm-memory",
      "date": "2020-06-02",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2020-13759",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "aliases": [
        "CVE-2020-13759",
        "GHSA-mm4m-qg48-f7wc"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1",
        "^0.1.1"
      ]
    },
    "text": "\n\n# Improper Synchronization and Race Condition in vm-memory\n\nrust-vmm vm-memory before 0.1.1 and 0.2.x before 0.2.1 allows attackers to cause a denial of service (loss of IP networking) because read_obj and write_obj do not properly access memory. This affects aarch64 (with musl or glibc) and x86_64 (with musl).\n",
    "likely_poc": [
      "https://nvd.nist.gov/vuln/detail/CVE-2020-13759"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0056",
      "package": "vm-memory",
      "date": "2023-09-01",
      "url": "https://github.com/rust-vmm/vm-memory/issues/250",
      "references": [
        "https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8"
      ],
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:L",
      "aliases": [
        "CVE-2023-41051",
        "GHSA-49hh-fprx-m68g"
      ]
    },
    "affected": {
      "functions": {
        "vm_memory::volatile_memory::VolatileMemory::get_atomic_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::aligned_as_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::aligned_as_mut": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::get_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::get_array_ref": [
          "< 0.12.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.12.2"
      ]
    },
    "text": "\n\n# Default functions in VolatileMemory trait lack bounds checks, potentially leading to out-of-bounds memory accesses \n\nAn issue was discovered in the default implementations of the `VolatileMemory::{get_atomic_ref, aligned_as_ref, aligned_as_mut, get_ref, get_array_ref}` trait functions, which allows out-of-bounds memory access if the `VolatileMemory::get_slice` function returns a `VolatileSlice` whose length is less than the function\u2019s `count` argument. No implementations of `get_slice` provided in `vm_memory` are affected. Users of custom `VolatileMemory` implementations may be impacted if the custom implementation does not adhere to `get_slice`'s documentation.\n\nThe issue started in version 0.1.0 but was fixed in version 0.12.2 by inserting a check that verifies that the `VolatileSlice` returned by `get_slice` is of the correct length.\n",
    "likely_poc": [
      "https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0005",
      "package": "pancurses",
      "aliases": [
        "CVE-2019-15546",
        "GHSA-m57c-4vvx-gjgq"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2019-06-15",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    },
    "affected": {
      "functions": {
        "pancurses::mvprintw": [
          ">= 0"
        ],
        "pancurses::printw": [
          ">= 0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Format string vulnerabilities in `pancurses`\n\n`pancurses::mvprintw` and `pancurses::printw` passes a pointer from a rust `&str` to C,\nallowing hostile input to execute a format string attack, which trivially allows writing\narbitrary data to stack memory.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0007",
      "package": "qcell",
      "date": "2022-01-24",
      "url": "https://github.com/uazu/qcell/issues/20",
      "informational": "unsound",
      "keywords": [
        "unsound"
      ],
      "aliases": [
        "GHSA-9c9f-7x9p-4wqp"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# A malicious coder can get unsound access to TCell or TLCell memory\n\nThis is impossible to do by accident, but by carefully constructing\nmarker types to be covariant, a malicious coder can cheat the\nsingleton check in `TCellOwner` and `TLCellOwner`, giving unsound\naccess to cell memory.  This could take the form of getting two\nmutable references to the same memory, or a mutable reference and an\nimmutable reference.\n\nThe fix is for the crate to internally force the marker type to be\ninvariant.  This blocks the conversion between covariant types which\nRust normally allows.\n",
    "likely_poc": [
      "https://github.com/uazu/qcell/issues/20"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0034",
      "package": "h2",
      "date": "2023-04-14",
      "url": "https://github.com/hyperium/hyper/issues/2877",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "http",
        "http2",
        "h2"
      ],
      "aliases": [
        "CVE-2023-26964",
        "GHSA-f8vr-r385-rh5r"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.17"
      ]
    },
    "text": "\n\n# Resource exhaustion vulnerability in h2 may lead to Denial of Service (DoS)\n\nIf an attacker is able to flood the network with pairs of `HEADERS`/`RST_STREAM` frames, such that the `h2` application is not able to accept them faster than the bytes are received, the pending accept queue can grow in memory usage. Being able to do this consistently can result in excessive memory use, and eventually trigger Out Of Memory.\n\nThis flaw is corrected in [hyperium/h2#668](https://github.com/hyperium/h2/pull/668), which restricts remote reset stream count by default.\n",
    "likely_poc": [
      "https://github.com/hyperium/hyper/issues/2877"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0003",
      "package": "h2",
      "date": "2024-01-17",
      "references": [
        "https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "http",
        "http2",
        "h2"
      ],
      "related": [
        "CVE-2019-9514"
      ],
      "aliases": [
        "GHSA-8r5v-vm4m-4g25"
      ]
    },
    "versions": {
      "patched": [
        "^0.3.24",
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Resource exhaustion vulnerability in h2 may lead to Denial of Service (DoS)\n\nAn attacker with an HTTP/2 connection to an affected endpoint can send a steady stream of invalid frames to force the\ngeneration of reset frames on the victim endpoint.\nBy closing their recv window, the attacker could then force these resets to be queued in an unbounded fashion,\nresulting in Out Of Memory (OOM) and high CPU usage.\n\nThis fix is corrected in [hyperium/h2#737](https://github.com/hyperium/h2/pull/737), which limits the total number of\ninternal error resets emitted by default before the connection is closed.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0131",
      "package": "rcu_cell",
      "date": "2020-11-14",
      "url": "https://github.com/Xudong-Huang/rcu_cell/issues/3",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36451",
        "GHSA-686h-j8r8-wmfm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Send/Sync bound needed on T  for Send/Sync impl of RcuCell<T>\n\nAffected versions of this crate unconditionally implement Send/Sync for `RcuCell<T>`.\nThis allows users to send `T: !Send` to other threads (while `T` enclosed within `RcuCell<T>`), and allows users to concurrently access `T: !Sync` by using the APIs of `RcuCell<T>` that provide access to `&T`.\n\nThis can result in memory corruption caused by data races.\n",
    "likely_poc": [
      "https://github.com/Xudong-Huang/rcu_cell/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0047",
      "package": "lmdb-rs",
      "date": "2023-06-26",
      "informational": "unsound",
      "url": "https://github.com/vhbit/lmdb-rs/issues/67",
      "keywords": [
        "unsound"
      ],
      "aliases": [
        "GHSA-f9g6-fp84-fv92"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# impl `FromMdbValue` for bool is unsound\nThe implementation of `FromMdbValue` have several unsoundness issues. First of all, it allows to reinterpret arbitrary bytes as a bool and could make undefined behavior happen with safe function. Secondly, it allows transmuting pointer without taking memory layout into consideration. The details of reproducing the bug were included in url above.\n",
    "likely_poc": [
      "https://github.com/vhbit/lmdb-rs/issues/67"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0055",
      "package": "axum-core",
      "date": "2022-08-31",
      "url": "https://github.com/tokio-rs/axum/pull/1346",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "ddos",
        "oom"
      ],
      "aliases": [
        "CVE-2022-3212",
        "GHSA-m77f-652q-wwp4"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.8, < 0.3.0-rc.1",
        ">= 0.3.0-rc.2"
      ]
    },
    "text": "\n\n# No default limit put on request bodies\n\n`<bytes::Bytes as axum_core::extract::FromRequest>::from_request` would not, by\ndefault, set a limit for the size of the request body. That meant if a malicious\npeer would send a very large (or infinite) body your server might run out of\nmemory and crash.\n\nThis also applies to these extractors which used `Bytes::from_request`\ninternally:\n- `axum::extract::Form`\n- `axum::extract::Json`\n- `String`\n\nThe fix is also in `axum-core` `0.3.0.rc.2` but `0.3.0.rc.1` _is_ vulnerable.\n\nBecause `axum` depends on `axum-core` it is vulnerable as well. The vulnerable\nversions of `axum` are `<= 0.5.15` and `0.6.0.rc.1`. `axum` `>= 0.5.16` and\n`>= 0.6.0.rc.2` does have the fix and are not vulnerable.\n\nThe patched versions will set a 2 MB limit by default.\n",
    "likely_poc": [
      "https://github.com/tokio-rs/axum/pull/1346"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0010",
      "package": "libflate",
      "aliases": [
        "CVE-2019-15552",
        "GHSA-rpcm-whqc-jfw8"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-07-04",
      "keywords": [
        "drop",
        "use-after-free"
      ],
      "url": "https://github.com/sile/libflate/issues/35"
    },
    "affected": {
      "functions": {
        "libflate::gzip::MultiDecoder::read": [
          "< 0.1.25, >= 0.1.14"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.25"
      ],
      "unaffected": [
        "< 0.1.14"
      ]
    },
    "text": "\n\n# MultiDecoder::read() drops uninitialized memory of arbitrary type on panic in client code\n\nAffected versions of libflate have set a field of an internal structure with a generic type to an uninitialized value in `MultiDecoder::read()` and reverted it to the original value after the function completed. However, execution of `MultiDecoder::read()` could be interrupted by a panic in caller-supplied `Read` implementation. This would cause `drop()` to be called on uninitialized memory of a generic type implementing `Read`.\n\nThis is equivalent to a use-after-free vulnerability and could allow an attacker to gain arbitrary code execution.\n\nThe flaw was corrected by aborting immediately instead of unwinding the stack in case of panic within `MultiDecoder::read()`. The issue was discovered and fixed by Shnatsel.\n",
    "likely_poc": [
      "https://github.com/sile/libflate/issues/35"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0090",
      "package": "thex",
      "aliases": [
        "CVE-2020-35927",
        "GHSA-j42v-6wpm-r847"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-08",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Thex<T> allows data races of non-Send types across threads\n\n`thex::Thex<T>` implements `Sync` for all types `T`. However, it is missing a\nbound for `T: Send`.\n\nThis allows non-Send types such as `Rc` to be sent across thread boundaries\nwhich can trigger undefined behavior and memory corruption.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0005",
      "package": "threadalone",
      "date": "2024-01-07",
      "url": "https://github.com/cr0sh/threadalone/issues/1",
      "informational": "unsound",
      "aliases": [
        "GHSA-w59h-378f-2frm"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# Unsound sending of non-Send types across threads\n\nAffected versions can run the `Drop` impl of a non-Send type on a different\nthread than it was created on.\n\nThe flaw occurs when a stderr write performed by the `threadalone` crate fails,\nfor example because stderr is redirected to a location on a filesystem that is\nfull, or because stderr is a pipe that has been closed by the reader.\n\nDropping a non-Send type on the wrong thread is unsound. If used with a type\nsuch as a pthread-based `MutexGuard`, [the consequence is undefined\nbehavior][mutexguard]. If used with `Rc`, there would be a data race on the\nreference count, which is likewise undefined behavior.\n\n[mutexguard]: https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326\n\n",
    "likely_poc": [
      "https://github.com/cr0sh/threadalone/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0012",
      "package": "cdr",
      "aliases": [
        "CVE-2021-26305",
        "GHSA-37jj-wp7g-7wj4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-02",
      "url": "https://github.com/hrektts/cdr-rs/issues/10",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.4"
      ]
    },
    "text": "\n\n# Reading uninitialized memory can cause UB (`Deserializer::read_vec`)\n\n`Deserializer::read_vec()` created an uninitialized buffer and passes it to a user-provided `Read` implementation (`Deserializer.reader.read_exact()`).\n\nPassing an uninitialized buffer to an arbitrary `Read` implementation is currently defined as undefined behavior in Rust. Official documentation for the `Read` trait explains the following: \"It is your responsibility to make sure that buf is initialized before calling read. Calling read with an uninitialized buf (of the kind one obtains via MaybeUninit<T>) is not safe, and can lead to undefined behavior.\"\n\nThe flaw was corrected in commit ce310f7 by zero-initializing the newly allocated buffer before handing it to `Deserializer.reader.read_exact()`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0020",
      "package": "const-cstr",
      "date": "2023-03-12",
      "url": "https://github.com/abonander/const-cstr",
      "informational": "unsound"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# const-cstr is Unmaintained\n\nLast release was about five years ago.\n\nThe maintainer(s) have been unreachable to respond to any issues that may or may not include security issues.\n\nThe repository is now archived and there is no security policy in place to contact the maintainer(s) otherwise.\n\nNo direct fork exist.\n\n# const-cstr is Unsound\n\nThe crate violates the safety contract of [ffi::CStr::from_bytes_with_nul_unchecked](https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked) used in `ConstCStr::as_cstr`\n\nNo interior nul bytes checking is done either by the constructor or the canonical macro to create the `ConstCStr`\n\n# const-cstr Panic\n\nAdditionally the crate may cause runtime panics if statically compiled and ran with any untrusted data that is not nul-terminated.\n\nThis is however unlikely but the the crate should not be used for untrusted data in context where panic may create a DoS vector.\n\n## Possible Alternatives\n\nThe below may or may not provide alternative(s)\n\n- [const_str::cstr!](https://docs.rs/const-str/latest/const_str/macro.cstr.html)\n- [cstr::cstr!](https://crates.io/crates/cstr)\n",
    "likely_poc": [
      "https://github.com/abonander/const-cstr"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0092",
      "package": "rmp-serde",
      "date": "2022-04-13",
      "url": "https://github.com/3Hren/msgpack-rust/issues/305",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-255r-3prx-mf99"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.1"
      ]
    },
    "text": "\n\n# `rmp-serde` `Raw` and `RawRef` unsound\n\nIt was found that `Raw::from_utf8` expects valid UTF-8. If invalid UTF-8 is received it can cause the process to crash.\n",
    "likely_poc": [
      "https://github.com/3Hren/msgpack-rust/issues/305"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0101",
      "package": "conquer-once",
      "aliases": [
        "CVE-2020-36208",
        "GHSA-3jc5-5hc5-33gj"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-22",
      "url": "https://github.com/oliver-giersch/conquer-once/issues/3",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ],
      "unaffected": []
    },
    "text": "\n\n# conquer-once's OnceCell lacks Send bound for its Sync trait.\n\nAffected versions of `conquer-once` implements `Sync` for its `OnceCell` type\nwithout restricting it to `Send`able types.\n\nThis allows non-`Send` but `Sync` types such as `MutexGuard` to be sent across\nthreads leading to undefined behavior and memory corruption in concurrent\nprograms.\n\nThe issue was fixed by adding a `Send` constraint to `OnceCell`.\n",
    "likely_poc": [
      "https://github.com/oliver-giersch/conquer-once/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0008",
      "package": "bra",
      "aliases": [
        "CVE-2021-25905",
        "GHSA-j8qq-58cr-8cc7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "date": "2021-01-02",
      "url": "https://github.com/Enet4/bra-rs/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.1"
      ]
    },
    "text": "\n\n# reading on uninitialized buffer can cause UB (`impl<R> BufRead for GreedyAccessReader<R>`)\n\nAffected versions of this crate creates an uninitialized buffer and passes it to user-provided `Read` implementation.\n\nThis is unsound, because it allows safe Rust code to exhibit an undefined behavior (read from uninitialized memory).\n\nThe flaw was corrected in version 0.1.1 by zero-initializing a newly allocated buffer\nbefore handing it to a user-provided `Read` implementation. \n",
    "likely_poc": [
      "https://github.com/Enet4/bra-rs/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0132",
      "package": "array-tools",
      "date": "2020-12-31",
      "url": "https://github.com/L117/array-tools/issues/2",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2020-36452",
        "GHSA-6wp2-fw3v-mfmc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ]
    },
    "text": "\n\n# `FixedCapacityDequeLike::clone()` can cause dropping uninitialized memory\n\nAffected versions of this crate don't guard against panics, so that partially uninitialized buffer is dropped when user-provided `T::clone()` panics in `FixedCapacityDequeLike<T, A>::clone()`. This causes memory corruption.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0128",
      "package": "rusqlite",
      "date": "2021-12-07",
      "url": "https://github.com/rusqlite/rusqlite/issues/1048",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "incorrect-lifetime"
      ],
      "aliases": [
        "CVE-2021-45713",
        "CVE-2021-45714",
        "CVE-2021-45715",
        "CVE-2021-45716",
        "CVE-2021-45717",
        "CVE-2021-45718",
        "CVE-2021-45719",
        "GHSA-4qr3-m7ww-hh9g",
        "GHSA-87xh-9q6h-r5cc",
        "GHSA-92cx-4xm7-jr9m",
        "GHSA-cm8g-544f-p9x9",
        "GHSA-f6f2-3w33-54r9",
        "GHSA-g4g4-3pqw-8m7f",
        "GHSA-g87r-23vw-7f87",
        "GHSA-q89g-4vhh-mvvm"
      ]
    },
    "affected": {
      "functions": {
        "rusqlite::Connection::create_scalar_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_aggregate_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_window_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_collation": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::commit_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::rollback_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::update_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.26.2",
        "0.25.4"
      ],
      "unaffected": [
        "< 0.25.0"
      ]
    },
    "text": "\n\n# Incorrect Lifetime Bounds on Closures in `rusqlite`\n\nThe lifetime bound on several closure-accepting `rusqlite` functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.\n\nThe impacted functions are:\n\n- Under `cfg(feature = \"functions\")`: `Connection::create_scalar_function`, `Connection::create_aggregate_function` and `Connection::create_window_function`.\n- Under `cfg(feature = \"hooks\")`: `Connection::commit_hook`, `Connection::rollback_hook` and `Connection::update_hook`.\n- Under `cfg(feature = \"collation\")`: `Connection::create_collation`.\n\nThe issue exists in all `0.25.*` versions prior to `0.25.4`, and all `0.26.*` versions prior to 0.26.2 (specifically: `0.25.0`, `0.25.1`, `0.25.2`, `0.25.3`, `0.26.0`, and `0.26.1`).\n\nThe fix is available in versions `0.26.2` and newer, and also has been back-ported to `0.25.4`. As it does not exist in `0.24.*`, all affected versions should have an upgrade path to a semver-compatible release.\n",
    "likely_poc": [
      "https://github.com/rusqlite/rusqlite/issues/1048"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0014",
      "package": "rusqlite",
      "aliases": [
        "CVE-2020-35866",
        "CVE-2020-35867",
        "CVE-2020-35868",
        "CVE-2020-35869",
        "CVE-2020-35870",
        "CVE-2020-35871",
        "CVE-2020-35872",
        "CVE-2020-35873",
        "GHSA-28ph-f7gx-fqj8",
        "GHSA-3cgf-9m6x-pwwr",
        "GHSA-6q5w-m3c5-rv95",
        "GHSA-8h4j-vm3r-vcq3",
        "GHSA-8r7q-r9mx-35rh",
        "GHSA-g4w7-3qr8-5623",
        "GHSA-q3cc-7p7g-392c",
        "GHSA-rjh8-p66p-jrh5"
      ],
      "date": "2020-04-23",
      "url": "https://github.com/rusqlite/rusqlite/releases/tag/0.23.0"
    },
    "affected": {
      "functions": {
        "rusqlite::Connection::get_aux": [
          "< 0.23.0"
        ],
        "rusqlite::Connection::set_aux": [
          "< 0.23.0"
        ],
        "rusqlite::session::Session::attach": [
          "< 0.23.0"
        ],
        "rusqlite::session::Session::diff": [
          "< 0.23.0"
        ],
        "rusqlite::trace::log": [
          "< 0.23.0"
        ],
        "rusqlite::vtab::create_module": [
          "< 0.23.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.23.0"
      ]
    },
    "text": "\n\n# Various memory safety issues\n\nSeveral memory safety issues have been uncovered in an audit of\nrusqlite.\n\nSee https://github.com/rusqlite/rusqlite/releases/tag/0.23.0 for a complete list.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0035",
      "package": "websocket",
      "date": "2022-08-01",
      "url": "https://github.com/websockets-rs/rust-websocket/security/advisories/GHSA-qrjv-rf5q-qpxc",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "websocket"
      ],
      "aliases": [
        "CVE-2022-35922",
        "GHSA-qrjv-rf5q-qpxc"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.26.5"
      ]
    },
    "text": "\n\n# Unbounded memory allocation based on untrusted length\n\n## Impact\nUntrusted websocket connections can cause an out-of-memory (OOM) process abort in a client or a server.\nThe root cause of the issue is during dataframe parsing.\nAffected versions would allocate a buffer based on the declared dataframe size, which may come from an untrusted source.\nWhen `Vec::with_capacity` fails to allocate, the default Rust allocator will abort the current process, killing all threads. This affects only sync (non-Tokio) implementation. Async version also does not limit memory, but does not use `with_capacity`, so DoS can happen only when bytes for oversized dataframe or message actually got delivered by the attacker.\n\nThis is a security concern for you, if\n- your server application handles untrusted websocket connections\n- OR your client application connects to untrusted websocket servers\n\n## Patches\nThe crashes are fixed in version **0.26.5** by imposing default dataframe size limits.\nAffected users are advised to update to this version.\n\nNote that default memory limits are rather large (100MB dataframes and 200 MB messages), so they can still cause DoS in some environments (i.e. 32-bit). New API has been added to fine tune those limits for specific applications.\n\n### Workarounds\n\n* Migrate your project to another, maintained Websocket library like Tungstenite.\n* Accept only trusted WebSocket traffic.\n* Filter the WebSocket traffic though some kind of proxy that ensures sanity limits on messages.\n* Handle process aborts gracefully and limit process memory using OS tools.\n\n\n## Credits\nThis issue was reported by [Evan Richter](https://github.com/evanrichter) at ForAllSecure and found with [Mayhem](https://forallsecure.com/mayhem-for-code) and [Cargo Fuzz](https://github.com/rust-fuzz/cargo-fuzz).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0004",
      "package": "lucet-runtime-internals",
      "aliases": [
        "CVE-2020-35859",
        "GHSA-3933-wvjf-pcvc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "date": "2020-01-24",
      "url": "https://github.com/bytecodealliance/lucet/pull/401"
    },
    "versions": {
      "patched": [
        "< 0.5.0, >= 0.4.3",
        ">= 0.5.1"
      ]
    },
    "text": "\n\n# sigstack allocation bug can cause memory corruption or leak\n\nAn embedding using affected versions of lucet-runtime configured to use\nnon-default Wasm globals sizes of more than 4KiB, or compiled in debug mode\nwithout optimizations, could leak data from the signal handler stack to guest\nprograms. This can potentially cause data from the embedding host to leak to\nguest programs or cause corruption of guest program memory.\n\nThis flaw was resolved by correcting the sigstack allocation logic.\n",
    "likely_poc": [
      "https://github.com/bytecodealliance/lucet/pull/401"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0102",
      "package": "late-static",
      "aliases": [
        "CVE-2020-36209",
        "GHSA-wr55-mf5c-hhwm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/Richard-W/late-static/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# LateStatic has incorrect Sync bound\n\nAffected versions of this crate implemented `Sync` for `LateStatic` with `T: Send`, so that it is possible to create a data race to a type `T: Send + !Sync` (e.g. `Cell<T>`).\n\nThis can result in a memory corruption or other kinds of undefined behavior.\n\nThe flaw was corrected in commit 11f396c by replacing the `T: Send` bound to `T: Sync` bound in the `Sync` impl for `LateStatic<T>`.\n",
    "likely_poc": [
      "https://github.com/Richard-W/late-static/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0344",
      "package": "curve25519-dalek",
      "date": "2024-06-18",
      "categories": [
        "crypto-failure"
      ],
      "url": "https://github.com/dalek-cryptography/curve25519-dalek/pull/659"
    },
    "versions": {
      "patched": [
        ">= 4.1.3"
      ]
    },
    "text": "\n\n# Timing variability in `curve25519-dalek`'s `Scalar29::sub`/`Scalar52::sub`\n\nTiming variability of any kind is problematic when working with  potentially secret values such as\nelliptic curve scalars, and such issues can potentially leak private keys and other secrets. Such a\nproblem was recently discovered in `curve25519-dalek`.\n\nThe `Scalar29::sub` (32-bit) and `Scalar52::sub` (64-bit) functions contained usage of a mask value\ninside a loop where LLVM saw an opportunity to insert a branch instruction (`jns` on x86) to\nconditionally bypass this code section when the mask value is set to zero as can be seen in godbolt:\n\n- 32-bit (see L106): <https://godbolt.org/z/zvaWxzvqv>\n- 64-bit (see L48): <https://godbolt.org/z/PczYj7Pda>\n\nA similar problem was recently discovered in the Kyber reference implementation:\n\n<https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hqbtIGFKIpU/m/cnE3pbueBgAJ>\n\nAs discussed on that thread, one portable solution, which is also used in this PR, is to introduce a\nvolatile read as an optimization barrier, which prevents the compiler from optimizing it away.\n\nThe fix can be validated in godbolt here:\n\n- 32-bit: <https://godbolt.org/z/jc9j7eb8E>\n- 64-bit: <https://godbolt.org/z/x8d46Yfah>\n\nThe problem was discovered and the solution independently verified by \nAlexander Wagner <alexander.wagner@aisec.fraunhofer.de> and Lea Themint <lea.thiemt@tum.de> using\ntheir DATA tool:\n\n<https://github.com/Fraunhofer-AISEC/DATA>\n",
    "likely_poc": [
      "https://github.com/dalek-cryptography/curve25519-dalek/pull/659"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0124",
      "package": "async-coap",
      "date": "2020-12-08",
      "url": "https://github.com/google/rust-async-coap/issues/33",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36444",
        "GHSA-9j8q-m9x5-9g6j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# ArcGuard's Send and Sync should have bounds on RC\n\nAffected versions of this crate implement Send/Sync for `ArcGuard<RC, T>` with no trait bounds on `RC`. This allows users to send `RC: !Send` to other threads and also allows users to concurrently access `Rc: !Sync` from multiple threads.\n\nThis can result in memory corruption from data race or other undefined behavior caused by sending `T: !Send` to other threads (e.g. dropping `MutexGuard<T>` in another thread that didn't lock its mutex).\n",
    "likely_poc": [
      "https://github.com/google/rust-async-coap/issues/33"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0004",
      "package": "claxon",
      "aliases": [
        "CVE-2018-20992",
        "GHSA-8c6g-4xc5-w96c"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
      "date": "2018-08-25",
      "keywords": [
        "uninitialized-memory"
      ],
      "url": "https://github.com/ruuda/claxon/commit/8f28ec275e412dd3af4f3cda460605512faf332c"
    },
    "versions": {
      "patched": [
        "^0.3.2",
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# Malicious input could cause uninitialized memory to be exposed\n\nAffected versions of Claxon made an invalid assumption about the decode buffer\nsize being a multiple of a value read from the bitstream. This could cause parts\nof the decode buffer to not be overwritten. If the decode buffer was newly\nallocated and uninitialized, this uninitialized memory could be exposed.\n\nThis allows an attacker to observe parts of the uninitialized memory in the\ndecoded audio stream.\n\nThe flaw was corrected by checking that the value read from the bitstream divides\nthe decode buffer size, and returning a format error if it does not. If an error\nis returned, the decode buffer is not exposed. Regression tests and an\nadditional fuzzer have been added to prevent similar flaws in the future.\n",
    "likely_poc": [
      "https://github.com/ruuda/claxon/commit/8f28ec275e412dd3af4f3cda460605512faf332c"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0006",
      "package": "bumpalo",
      "aliases": [
        "CVE-2020-35861",
        "GHSA-vqx7-pw4r-29rr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "categories": [
        "memory-exposure"
      ],
      "date": "2020-03-24",
      "url": "https://github.com/fitzgen/bumpalo/issues/69"
    },
    "versions": {
      "patched": [
        ">= 3.2.1"
      ],
      "unaffected": [
        "< 3.0.0"
      ]
    },
    "text": "\n\n# Flaw in `realloc` allows reading unknown memory\n\nWhen `realloc`ing, if we allocate new space, we need to copy the old\nallocation's bytes into the new space. There are `old_size` number of bytes in\nthe old allocation, but we were accidentally copying `new_size` number of bytes,\nwhich could lead to copying bytes into the realloc'd space from past the chunk\nthat we're bump allocating out of, from unknown memory.\n\nIf an attacker can cause `realloc`s, and can read the `realoc`ed data back,\nthis could allow them to read things from other regions of memory that they\nshouldn't be able to. For example, if some crypto keys happened to live in\nmemory right after a chunk we were bump allocating out of, this could allow\nthe attacker to read the crypto keys.\n\nBeyond just fixing the bug and adding a regression test, I've also taken two\nadditional steps:\n\n1. While we were already running the testsuite under `valgrind` in CI, because\n   `valgrind` exits with the same code that the program did, if there are\n   invalid reads/writes that happen not to trigger a segfault, the program can\n   still exit OK and we will be none the wiser. I've enabled the\n   `--error-exitcode=1` flag for `valgrind` in CI so that tests eagerly fail\n   in these scenarios.\n\n2. I've written a quickcheck test to exercise `realloc`. Without the bug fix\n   in this patch, this quickcheck immediately triggers invalid reads when run\n   under `valgrind`. We didn't previously have quickchecks that exercised\n   `realloc` because `realloc` isn't publicly exposed directly, and instead\n   can only be indirectly called. This new quickcheck test exercises `realloc`\n   via `bumpalo::collections::Vec::resize` and\n   `bumpalo::collections::Vec::shrink_to_fit` calls.\n",
    "likely_poc": [
      "https://github.com/fitzgen/bumpalo/issues/69"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0078",
      "package": "bumpalo",
      "date": "2022-01-14",
      "url": "https://github.com/fitzgen/bumpalo/blob/main/CHANGELOG.md#3111",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-f85w-wvc7-crwc"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.11.1"
      ],
      "unaffected": [
        "< 1.1.0"
      ]
    },
    "affected": {
      "functions": {
        "bumpalo::collections::vec::Vec::into_iter": [
          "< 3.11.1"
        ]
      }
    },
    "text": "\n\n# Use-after-free due to a lifetime error in `Vec::into_iter()`\n\nIn affected versions of this crate, the lifetime of the iterator produced by\n`Vec::into_iter()` is not constrained to the lifetime of the `Bump` that\nallocated the vector's memory. Using the iterator after the `Bump` is dropped\ncauses use-after-free accesses.\n\nThe following example demonstrates memory corruption arising from a misuse of\nthis unsoundness.\n\n```rust\nuse bumpalo::{collections::Vec, Bump};\n\nfn main() {\n    let bump = Bump::new();\n    let mut vec = Vec::new_in(&bump);\n    vec.extend([0x01u8; 32]);\n    let into_iter = vec.into_iter();\n    drop(bump);\n\n    for _ in 0..100 {\n        let reuse_bump = Bump::new();\n        let _reuse_alloc = reuse_bump.alloc([0x41u8; 10]);\n    }\n\n    for x in into_iter {\n        print!(\"0x{:02x} \", x);\n    }\n    println!();\n}\n```\n\nThe issue was corrected in version 3.11.1 by adding a lifetime to the `IntoIter`\ntype, and updating the signature of `Vec::into_iter()` to constrain this\nlifetime.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0100",
      "package": "sys-info",
      "date": "2020-05-31",
      "url": "https://github.com/FillZpp/sys-info-rs/issues/63",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency",
        "double free"
      ],
      "aliases": [
        "CVE-2020-36434",
        "GHSA-2f5j-3mhq-xv58"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ],
      "unaffected": []
    },
    "affected": {
      "os": [
        "linux"
      ],
      "functions": {
        "sys_info::disk_info": [
          "<= 0.1.1"
        ]
      }
    },
    "text": "\n\n# Double free when calling `sys_info::disk_info` from multiple threads\n\nAffected versions of `sys-info` use a static, global, list to store temporary disk information while running. The function that cleans up this list,\n`DFCleanup`, assumes a single threaded environment and will try to free the same memory twice in a multithreaded environment.\n\nThis results in consistent double-frees and segfaults when calling `sys_info::disk_info` from multiple threads at once.\n\nThe issue was fixed by moving the global variable into a local scope.\n\n## Safer Alternatives:\n - [`sysinfo`](https://crates.io/crates/sysinfo)\n",
    "likely_poc": [
      "https://github.com/FillZpp/sys-info-rs/issues/63"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0149",
      "package": "appendix",
      "date": "2020-11-15",
      "url": "https://github.com/krl/appendix/issues/6",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36469",
        "GHSA-fvhr-7j8m-3cvc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Data race and memory safety issue in `Index`\n\nThe `appendix` crate implements a key-value mapping data structure called\n`Index<K, V>` that is stored on disk. The crate allows for any type to inhabit\nthe generic `K` and `V` type parameters and implements Send and Sync for them\nunconditionally.\n\nUsing a type that is not marked as `Send` or `Sync` with `Index` can allow it\nto be used across multiple threads leading to data races. Additionally using\nreference types for the keys or values will lead to the segmentation faults\nin the crate's code.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0019",
      "package": "xcb",
      "aliases": [
        "CVE-2021-26955",
        "CVE-2021-26956",
        "CVE-2021-26957",
        "CVE-2021-26958",
        "GHSA-2xpg-3hx4-fm9r",
        "GHSA-3288-cwgw-ch86",
        "GHSA-3cj3-jrrp-9rxf",
        "GHSA-mp6r-fgw2-rxfx"
      ],
      "date": "2021-02-04",
      "url": "https://github.com/RustSec/advisory-db/issues/653",
      "references": [
        "https://github.com/rust-x-bindings/rust-xcb/issues/78",
        "https://github.com/rust-x-bindings/rust-xcb/issues/94",
        "https://github.com/rust-x-bindings/rust-xcb/issues/95",
        "https://github.com/rust-x-bindings/rust-xcb/issues/96"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n## Calls `std::str::from_utf8_unchecked()` without any checks\n\nThe function `xcb::xproto::GetAtomNameReply::name()` calls\n`std::str::from_utf8_unchecked()` on the raw bytes that were received from the\nX11 server without any validity checks. The X11 server only prevents interior\nnull bytes, but otherwise allows any X11 client to create an atom for arbitrary\nbytes.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/96\n\n## `xcb::xproto::GetPropertyReply::value()` allows arbitrary return types\n\nThe function `xcb::xproto::GetPropertyReply::value()` returns a slice of type\n`T` where `T` is an unconstrained type parameter. The raw bytes received from\nthe X11 server are interpreted as the requested type.\n\nThe users of the `xcb` crate are advised to only call this function with the\nintended types. These are `u8`, `u16`, and `u32`.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/95\n\n## Out of bounds read in `xcb::xproto::change_property()`\n\n`xcb::xproto::change_property` has (among others) the arguments `format: u8` and\n`data: &[T]`. The intended use is one of the following cases:\n- `format = 8` and `T = u8`\n- `format = 16` and `T = u16`\n- `format = 32` and `T = u32`\nHowever, this constraint is not enforced. For example, it is possible to call\nthe function with `format = 32` and `T = u8`. In this case, a read beyond the\nend of the `data` slice is performed and the bytes are sent to the X11 server.\n\nThe users of the `xcb` crate are advised to only call this function with one of\nthe intended argument combinations.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/94\n\n## 'Safe' wrapper around `std::mem::transmute()`\n\nThe function `xcb::base::cast_event()` takes a reference to a\n`xcb::base::GenericEvent` and returns a reference to an arbitrary type, as\nrequested by the caller (or found via type interference). The function is\nimplemented as a direct call to `std::mem::transmute()`. Since the return type\nis not constrained, this allows transmution to an incorrect type or a type that\nis larger than the X11 event that was passed in.\n\nX11 events are mostly always 32 bytes large and this function works as intended.\n\nUsers are advised to only cast to the event structs provided by the `xcb` crate\n(and hope for the best).\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/78\n",
    "likely_poc": [
      "https://github.com/RustSec/advisory-db/issues/653",
      "https://github.com/rust-x-bindings/rust-xcb/issues/78",
      "https://github.com/rust-x-bindings/rust-xcb/issues/94",
      "https://github.com/rust-x-bindings/rust-xcb/issues/95",
      "https://github.com/rust-x-bindings/rust-xcb/issues/96"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0097",
      "package": "xcb",
      "aliases": [
        "CVE-2020-36205",
        "GHSA-c8hq-x4mm-p6q6"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-10",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/93",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 1.0"
      ]
    },
    "text": "\n\n# Soundness issue with base::Error\n\n`base::Error` type contains public field named `ptr`.\nWith this definition, it is possible to create a `base::Error` with an invalid pointer and trigger memory safety errors\nsuch as use-after-free or double-free with safe Rust.\n\nThe users of `xcb` crate are advised not to manipulate the field.\n",
    "likely_poc": [
      "https://github.com/rust-x-bindings/rust-xcb/issues/93"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0045",
      "package": "adtensor",
      "aliases": [
        "CVE-2021-29936",
        "GHSA-rg4m-gww5-7p47"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-11",
      "url": "https://github.com/charles-r-earp/adtensor/issues/4",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# FromIterator implementation for Vector/Matrix can drop uninitialized memory\n\nThe `FromIterator<T>` methods for `Vector` and `Matrix` rely on the type\nparameter `N` to allocate space in the iterable.\n\nIf the passed in `N` type parameter is larger than the number of items returned\nby the iterator, it can lead to uninitialized memory being left in the\n`Vector` or `Matrix` type which gets dropped.\n",
    "likely_poc": [
      "https://github.com/charles-r-earp/adtensor/issues/4"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0037",
      "package": "pnet",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
      "date": "2019-06-11",
      "keywords": [
        "segfault"
      ],
      "url": "https://github.com/libpnet/libpnet/issues/449",
      "aliases": [
        "CVE-2019-25054",
        "GHSA-24g6-5rx7-58wj",
        "GHSA-r6ff-2q3c-v3pv"
      ]
    },
    "affected": {
      "functions": {
        "pnet::transport::IcmpTransportChannelIterator": [
          "< 0.27.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.27.2"
      ]
    },
    "text": "\n\n# Compiler optimisation for next_with_timeout in pnet::transport::IcmpTransportChannelIterator flaws to SEGFAULT\n\nAffected versions of this crate were optimized out by compiler,\nwhich caused dereference of uninitialized file descriptor which caused segfault.\n",
    "likely_poc": [
      "https://github.com/libpnet/libpnet/issues/449"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0022",
      "package": "yottadb",
      "aliases": [
        "CVE-2021-27377",
        "GHSA-9658-c26v-7qvf"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-09",
      "url": "https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/40",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.0"
      ]
    },
    "affected": {
      "functions": {
        "yottadb::Key::sub_next_self_st": [
          "< 1.2.0"
        ],
        "yottadb::Key::sub_prev_self_st": [
          "< 1.2.0"
        ],
        "yottadb::KeyContext::sub_next_self_st": [
          "< 1.2.0"
        ],
        "yottadb::KeyContext::sub_prev_self_st": [
          "< 1.2.0"
        ]
      }
    },
    "text": "\n\n# Use-after-free in `subscript_next` and `subscript_prev` wrappers\n\nAffected versions of this crate had an unsound implementation which could pass\na pointer to freed memory to `ydb_subscript_next_st` and\n`ydb_subscript_prev_st` if the variable and subscripts did not have enough\nmemory allocated on the first call to hold the next variable in the database.\n\nFor example, the following code had undefined behavior:\n\n```rust\nlet mut key = Key::variable(String::from(\"a\"));\nKey::variable(\"averylongkeywithlotsofletters\")\n    .set_st(YDB_NOTTP, Vec::new(), b\"some val\")\n    .unwrap();\nkey.sub_next_self_st(YDB_NOTTP, Vec::new()).unwrap();\n```\n\n`yottadb` has no reverse-dependencies on crates.io and there are no known\ninstances of this API being used incorrectly in practice. The fix is backwards\ncompatible.\n\nThe flaw was corrected by recalculating the pointer each time it was reallocated.\n",
    "likely_poc": [
      "https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/40"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0088",
      "package": "csv-sniffer",
      "date": "2021-01-05",
      "url": "https://github.com/jblondin/csv-sniffer/issues/1",
      "references": [
        "https://github.com/jblondin/csv-sniffer/pull/2"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45686",
        "GHSA-9783-42pm-x5jq",
        "GHSA-r67p-m7g9-gxw6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# `Read` on uninitialized memory may cause UB (fn preamble_skipcount())\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (within `fn preamble_skipcount()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": [
      "https://github.com/jblondin/csv-sniffer/pull/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0039",
      "package": "endian_trait",
      "aliases": [
        "CVE-2021-29929",
        "GHSA-vpw8-43wm-rxw5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-04",
      "url": "https://gitlab.com/myrrlyn/endian_trait/-/issues/1",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# panic in user-provided `Endian` impl triggers double drop of T\n\nAffected versions of the crate does not guard against panic from user-provided impl of `Endian` trait, which is a safe trait that users can implement.\nIf a user-provided implementation of the `Endian` trait panics, double-drop is triggered due to the duplicated ownership of `T` created by `ptr::read()`.\n\nDouble-drop (or double free) can cause memory corruption in the heap.\n",
    "likely_poc": [
      "https://gitlab.com/myrrlyn/endian_trait/-/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0081",
      "package": "json",
      "date": "2022-02-01",
      "url": "https://github.com/maciejhirsz/json-rust/issues/205",
      "references": [
        "https://github.com/maciejhirsz/json-rust/issues/196"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# json is unmaintained\n\nLast release was almost 3 years ago.\n\nThe maintainer is unresponsive with outstanding issues.\n\nOne of the outstanding issues include [a possible soundness issue](https://github.com/maciejhirsz/json-rust/issues/196).\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n- [jzon](https://crates.io/crates/jzon) maintained fork of json\n- [serde_json](https://crates.io/crates/serde_json)\n- [json-deserializer](https://crates.io/crates/json-deserializer)\n- [simd-json](https://crates.io/crates/simd-json)\n",
    "likely_poc": [
      "https://github.com/maciejhirsz/json-rust/issues/196"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0066",
      "package": "conduit-hyper",
      "date": "2022-10-30",
      "url": "https://github.com/conduit-rust/conduit-hyper/security/advisories/GHSA-9398-5ghf-7pr6",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "GHSA-9398-5ghf-7pr6",
        "CVE-2022-39294"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ],
      "unaffected": [
        "< 0.2.0-alpha.3"
      ]
    },
    "text": "\n\n# Denial of Service from unchecked request length\n\nPrior to version 0.4.2, `conduit-hyper` did not check any limit on a request's\nlength before calling `hyper::body::to_bytes`. An attacker could send a\nmalicious request with an abnormally large `Content-Length`, which could lead\nto a panic if memory allocation failed for that request.\n\nIn version 0.4.2, `conduit-hyper` sets an internal limit of 128 MiB per\nrequest, otherwise returning status 400 (\"Bad Request\").\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0051",
      "package": "lz4-sys",
      "date": "2022-08-25",
      "url": "https://github.com/lz4/lz4/pull/972",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "keywords": [
        "integer-overflow",
        "out-of-bounds"
      ],
      "related": [
        "CVE-2021-3520"
      ],
      "aliases": [
        "GHSA-9q5j-jm53-v7vr"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.9.4"
      ]
    },
    "text": "\n\n# Memory corruption in liblz4\n\nlz4-sys up to v1.9.3 bundles a version of liblz4 that is vulnerable to\n[CVE-2021-3520](https://nvd.nist.gov/vuln/detail/CVE-2021-3520).\n\nAttackers could craft a payload that triggers an integer overflow upon\ndecompression, causing an out-of-bounds write.\n\nThe flaw has been corrected in version v1.9.4 of liblz4, which is included\nin lz4-sys 1.9.4.\n",
    "likely_poc": [
      "https://github.com/lz4/lz4/pull/972"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0046",
      "package": "telemetry",
      "aliases": [
        "CVE-2021-29937",
        "GHSA-hpcx-3pw8-g3j2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-17",
      "url": "https://github.com/Yoric/telemetry.rs/issues/45",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# misc::vec_with_size() can drop uninitialized memory if clone panics\n\n`misc::vec_with_size` creates a vector of the provided `size` and immediately\ncalls `vec.set_len(size)` on it, initially filling it with uninitialized memory.\nIt then inserts elements using `vec[i] = value.clone()`.\n\nIf the `value.clone()` call panics, uninitialized items in the vector will be\ndropped leading to undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0138",
      "package": "lexer",
      "date": "2020-11-10",
      "url": "https://gitlab.com/nathanfaucett/rs-lexer/-/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36458",
        "GHSA-f997-8gxg-r354"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# ReaderResult should be bounded by Sync\n\nAffected versions of this crate implements `Sync` for `ReaderResult<T, E>` with the trait bound `T: Send, E: Send`.\n\nSince matching on the public enum `ReaderResult<T, E>` provides access to `&T` & `&E`,\nallowing data race to a non-Sync type `T` or `E`.\nThis can result in a memory corruption when multiple threads concurrently access `&T` or `&E`.\n\nSuggested fix for the bug is change the trait bounds imposed on `T` & `E` to be `T: Sync, E: Sync`.\n",
    "likely_poc": [
      "https://gitlab.com/nathanfaucett/rs-lexer/-/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0041",
      "package": "crossbeam-utils",
      "date": "2022-02-05",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/781",
      "aliases": [
        "GHSA-qc84-gqf4-9926",
        "CVE-2022-23639"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.7"
      ]
    },
    "text": "\n\n# Unsoundness of AtomicCell<*64> arithmetics on 32-bit targets that support Atomic*64\n\n## Impact\n\nAffected versions of this crate incorrectly assumed that the alignment of {i,u}64 was always the same as Atomic{I,U}64.\n\nHowever, the alignment of {i,u}64 on a 32-bit target can be smaller than Atomic{I,U}64.\n\nThis can cause the following problems:\n\n- Unaligned memory accesses\n- Data race\n\nCrates using fetch_* methods with AtomicCell<{i,u}64> are affected by this issue.\n\n32-bit targets without Atomic{I,U}64 and 64-bit targets are not affected by this issue.\n\n32-bit targets with Atomic{I,U}64 and {i,u}64 have the same alignment are also not affected by this issue.\n\nThe following is a complete list of the builtin targets that may be affected. (last update: nightly-2022-02-11)\n\n- armv7-apple-ios (tier 3)\n- armv7s-apple-ios (tier 3)\n- i386-apple-ios (tier 3)\n- i586-unknown-linux-gnu\n- i586-unknown-linux-musl\n- i686-apple-darwin (tier 3)\n- i686-linux-android\n- i686-unknown-freebsd\n- i686-unknown-haiku (tier 3)\n- i686-unknown-linux-gnu\n- i686-unknown-linux-musl\n- i686-unknown-netbsd (tier 3)\n- i686-unknown-openbsd (tier 3)\n- i686-wrs-vxworks (tier 3)\n\n([script to get list](https://gist.github.com/taiki-e/3c7891e8c5f5e0cbcb44d7396aabfe10))\n\n## Patches\n\nThis has been fixed in crossbeam-utils 0.8.7.\n\nAffected 0.8.x releases have been yanked.\n\nThanks to @taiki-e\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/781"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0099",
      "package": "aovec",
      "aliases": [
        "CVE-2020-36207",
        "GHSA-g489-xrw3-3v8w"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Aovec<T> lacks bound on its Send and Sync traits allowing data races\n\n`aovec::Aovec<T>` is a vector type that implements `Send` and `Sync` for all\ntypes `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0048",
      "package": "intaglio",
      "date": "2023-07-26",
      "url": "https://github.com/artichoke/intaglio/pull/236",
      "references": [
        "https://github.com/artichoke/intaglio/issues/235",
        "https://github.com/artichoke/intaglio/pull/236",
        "https://github.com/artichoke/intaglio/releases/tag/v1.9.0"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-gch5-hwqf-mxhp"
      ]
    },
    "affected": {
      "functions": {
        "intaglio::SymbolTable::intern": [
          "< 1.9.0"
        ],
        "intaglio::bytes::SymbolTable::intern": [
          "< 1.9.0"
        ],
        "intaglio::cstr::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ],
        "intaglio::osstr::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ],
        "intaglio::path::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.9.0"
      ]
    },
    "text": "\n\n# Unsoundness in `intern` methods on `intaglio` symbol interners\n\nAffected versions of this crate have a stacked borrows violation when creating\nreferences to interned contents. All interner types are affected.\n\nThe flaw was corrected in version 1.9.0 by reordering move and borrowing\noperations and storing interned contents by raw pointer instead of as a `Box`.\n",
    "likely_poc": [
      "https://github.com/artichoke/intaglio/pull/236",
      "https://github.com/artichoke/intaglio/issues/235",
      "https://github.com/artichoke/intaglio/pull/236"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0074",
      "package": "zerocopy",
      "date": "2023-12-14",
      "url": "https://github.com/google/zerocopy/issues/716",
      "keywords": [
        "ref",
        "refcell",
        "mutable-aliasing"
      ],
      "aliases": [
        "GHSA-3mv5-343c-w2qg",
        "GHSA-rjhf-4mh8-9xjq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.9, < 0.3.0",
        ">= 0.3.2, < 0.4.0",
        ">= 0.4.1, < 0.5.0",
        ">= 0.5.2, < 0.6.0",
        ">= 0.6.6, < 0.7.0",
        ">= 0.7.31"
      ],
      "unaffected": [
        "< 0.2.2"
      ]
    },
    "affected": {
      "functions": {
        "zerocopy::Ref::into_ref": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_mut": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_slice": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_mut_slice": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ]
      }
    },
    "text": "\n\n# Some Ref methods are unsound with some type parameters\n\nThe `Ref` methods `into_ref`, `into_mut`, `into_slice`, and `into_slice_mut` are unsound\nand may allow safe code to exhibit undefined behavior when used with `Ref<B, T>` where `B`\nis [`cell::Ref`](https://doc.rust-lang.org/core/cell/struct.Ref.html) or\n[`cell::RefMut`](https://doc.rust-lang.org/core/cell/struct.RefMut.html). Note that these\nmethods remain sound when used with `B` types other than `cell::Ref` or `cell::RefMut`.\n\nSee https://github.com/google/zerocopy/issues/716 for a more in-depth analysis.\n\nThe current plan is to yank the affected versions soon. See\nhttps://github.com/google/zerocopy/issues/679 for more detail.\n",
    "likely_poc": [
      "https://github.com/google/zerocopy/issues/716"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0121",
      "package": "crypto2",
      "date": "2021-10-08",
      "url": "https://github.com/shadowsocks/crypto2/issues/27",
      "informational": "unsound",
      "keywords": [
        "crypto",
        "alignment",
        "unsound"
      ],
      "aliases": [
        "CVE-2021-45709",
        "GHSA-9hfg-pxr6-q4vp",
        "GHSA-pmcv-mgcf-rvxg"
      ]
    },
    "affected": {
      "functions": {
        "crypto2::streamcipher::Chacha20::encrypt_slice": [
          "*"
        ],
        "crypto2::streamcipher::Chacha20::decrypt_slice": [
          "*"
        ],
        "crypto2::streamcipher::xor_si512_inplace": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Non-aligned u32 read in Chacha20 encryption and decryption\nThe implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to `std::slice::from_raw_parts_mut`, which breaks the contract and introduces undefined behavior.\n\nThis affects Chacha20 encryption and decryption in crypto2.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0011",
      "package": "fil-ocl",
      "aliases": [
        "CVE-2021-25908",
        "GHSA-x3v2-fgr6-3wmm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-04",
      "url": "https://github.com/cogciprocate/ocl/issues/194",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.12.0"
      ]
    },
    "text": "\n\n# EventList's From<EventList> conversions can double drop on panic.\n\nAffected versions of this crate read from a container using `ptr::read` in\n`From<EventList>`, and then call a user specified `Into<Event>` function.\n\nThis issue can result in a double-free if the user provided function panics.\n",
    "likely_poc": [
      "https://github.com/cogciprocate/ocl/issues/194"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0066",
      "package": "evm-core",
      "date": "2021-05-11",
      "url": "https://github.com/rust-blockchain/evm",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "GHSA-773q-5334-5gf9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.26.1",
        "0.25.1",
        "0.24.1",
        "0.23.1",
        "0.21.1"
      ]
    },
    "text": "\n\n# Denial of service on EVM execution due to memory over-allocation\n\nPrior to the patch, when executing specific EVM opcodes related\nto memory operations that use `evm_core::Memory::copy_large`, the\ncrate can over-allocate memory when it is not needed, making it\npossible for an attacker to perform denial-of-service attack.\n\nThe flaw was corrected in commit `19ade85`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0010",
      "package": "enum-map",
      "date": "2022-02-17",
      "url": "https://gitlab.com/KonradBorowski/enum-map/-/blob/master/CHANGELOG.md#version-202",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-rxhx-9fj6-6h2m"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.2"
      ],
      "unaffected": [
        "< 2.0.0-2"
      ]
    },
    "text": "\n\n# enum_map macro can cause UB when `Enum` trait is incorrectly implemented\n\nAffected versions of this crate did not properly check the length of an enum when using `enum_map!` macro, trusting user-provided length.\n\nWhen the `LENGTH` in the `Enum` trait does not match the array length in the `EnumArray` trait, this can result in the initialization of the enum map with uninitialized types, which in turn can allow an attacker to execute arbitrary code.\n\nThis problem can only occur with a manual implementation of the Enum trait, it will never occur for enums that use `#[derive(Enum)]`.\n\nExample code that triggers this vulnerability looks like this:\n\n```rust\nenum E {\n    A,\n    B,\n    C,\n}\n\nimpl Enum for E {\n    const LENGTH: usize = 2;\n\n    fn from_usize(value: usize) -> E {\n        match value {\n            0 => E::A,\n            1 => E::B,\n            2 => E::C,\n            _ => unimplemented!(),\n        }\n    }\n\n    fn into_usize(self) -> usize {\n        self as usize\n    }\n}\n\nimpl<V> EnumArray<V> for E {\n    type Array = [V; 3];\n}\n\nlet _map: EnumMap<E, String> = enum_map! { _ => \"Hello, world!\".into() };\n```\n\nThe flaw was corrected in commit [b824e23](https://gitlab.com/KonradBorowski/enum-map/-/commit/b824e232f2fb47837740070096ac253df8e80dfc) by putting `LENGTH` property on sealed trait for macro to read.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0118",
      "package": "tiny_future",
      "date": "2020-12-08",
      "url": "https://github.com/KizzyCode/tiny_future/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36438",
        "GHSA-fg42-vwxx-xx5j",
        "GHSA-m296-j53x-xv95"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Future<T> lacks bounds on Send and Sync.\n\n`tiny_future` contains a light-weight implementation of `Future`s. The `Future`\ntype it has lacked bound on its `Send` and `Sync` traits.\n\nThis allows for a bug where non-thread safe types such as `Cell` can be used in\n`Future`s and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `c791919` by adding trait bounds to `Future`'s\n`Send` and `Sync`.\n",
    "likely_poc": [
      "https://github.com/KizzyCode/tiny_future/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0083",
      "package": "derive-com-impl",
      "date": "2021-01-20",
      "url": "https://github.com/Connicpu/com-impl/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "com",
        "queryinterface",
        "addref"
      ],
      "aliases": [
        "CVE-2021-45681",
        "GHSA-9rg7-3j4f-cf4x",
        "GHSA-w4cc-pc2h-whcj"
      ]
    },
    "affected": {
      "functions": {
        "derive_com_impl::derive_com_impl": [
          "<= 0.1.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.2"
      ]
    },
    "text": "\n\n# QueryInterface should call AddRef before returning pointer\n\nAffected version of this crate, which is a required dependency in com-impl, \nprovides a faulty implementation of the `IUnknown::QueryInterface` method.\n\n`QueryInterface` implementation must call `IUnknown::AddRef` before returning the pointer,\nas describe in this documentation:\n<https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)>\n\nAs it is not incrementing the refcount as expected, the following calls to `IUnknown::Release` method \nwill cause WMI to drop reference to the interface, and can lead to invalid reference.\n\nThis is documented in <https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting>\n\nThere is no simple workaround, as you can't know how many time QueryInterface will be called.\nThe only way to quick fix this is to use the macro expanded version of the code and modify \nthe QueryInterface method to add the AddRef call yourself.\n\nThe issue was corrected in commit `9803f31fbd1717d482d848f041044d061fca6da7`.\n",
    "likely_poc": [
      "https://github.com/Connicpu/com-impl/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0007",
      "package": "av-data",
      "aliases": [
        "CVE-2021-25904",
        "GHSA-352p-rhvq-7g78"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-07",
      "url": "https://github.com/rust-av/rust-av/issues/136",
      "categories": [
        "memory-exposure",
        "privilege-escalation"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# `Frame::copy_from_raw_parts` can lead to segfault without `unsafe`\n\n`fn Frame::copy_from_raw_parts()` is a safe API that can take a\nraw pointer and dereference it. It is possible to read arbitrary memory address\nwith an arbitrarily fed pointer. This allows the safe API to access & read\narbitrary address in memory. Feeding an invalid memory address pointer to\nthe API may also cause the program to segfault.\n\nThe flaw was corrected in https://github.com/rust-av/rust-av/pull/137,\nby removing the API `fn Frame::copy_from_raw_parts()`.\n\n",
    "likely_poc": [
      "https://github.com/rust-av/rust-av/issues/136"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0022",
      "package": "temporary",
      "date": "2018-08-22",
      "url": "https://github.com/stainless-steel/temporary/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "uninitialized-memory"
      ],
      "aliases": [
        "GHSA-2jq9-6xx7-3h29"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.4"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Use of uninitialized memory in temporary\n\nUninit memory is used as a RNG seed in temporary\n\nThe following function is used as a way to get entropy from the system, which does operations on and exposes uninit memory, which is UB.\n\n```rust\nfn random_seed(_: &Path, _: &str) -> [u64; 2] {\n    use std::mem::uninitialized as rand;\n    unsafe { [rand::<u64>() ^ 0x12345678, rand::<u64>() ^ 0x87654321] }\n}\n```\n\nThis has been resolved in the 0.6.4 release.\n\nThe crate is not intended to be used outside of a testing environment.\n\nFor a general purpose crate to create temporary directories, [`tempfile`](https://crates.io/crates/tempfile) is an alternative for this crate.\n",
    "likely_poc": [
      "https://github.com/stainless-steel/temporary/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0050",
      "package": "reorder",
      "aliases": [
        "CVE-2021-29941",
        "CVE-2021-29942",
        "GHSA-3h87-v52r-p9rg",
        "GHSA-jpwg-6gf5-5vh9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-24",
      "url": "https://github.com/tiby312/reorder/issues/1",
      "keywords": [
        "memory-corruption",
        "out-of-bounds"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.0"
      ]
    },
    "text": "\n\n# swap_index can write out of bounds and return uninitialized memory\n\n`swap_index` takes an iterator and swaps the items with their corresponding\nindexes. It reserves capacity and sets the length of the vector based on the\n`.len()` method of the iterator.\n\nIf the `len()` returned by the iterator is larger than the actual number of\nelements yielded, then `swap_index` creates a vector containing uninitialized\nmembers. If the `len()` returned by the iterator is smaller than the actual\nnumber of members yielded, then `swap_index` can write out of bounds past\nits allocated vector.\n\nAs noted by the Rust documentation, [`len()`](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len)\nand `size_hint()` are primarily meant for optimization and incorrect values\nfrom their implementations should not lead to memory safety violations.\n\n\n# Patch\n\nA new version crate was pushed that marks this function as unsafe.\n\nreorder = \"1.1.0\"\n\nPrevious versions have also been yanked from crates.io.\n",
    "likely_poc": [
      "https://github.com/tiby312/reorder/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0054",
      "package": "wee_alloc",
      "date": "2022-05-11",
      "url": "https://github.com/rustwasm/wee_alloc/issues/107",
      "references": [
        "https://www.reddit.com/r/rust/comments/x1cle0/dont_use_wee_alloc_in_production_code_targeting/",
        "https://github.com/rustwasm/wee_alloc/issues/85",
        "https://github.com/rustwasm/wee_alloc/issues/106"
      ],
      "informational": "unmaintained",
      "aliases": [
        "GHSA-rc23-xxgq-x27g"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# wee_alloc is Unmaintained\n\nTwo of the maintainers have indicated that the crate may not be maintained.\n\nThe crate has open issues including memory leaks and may not be suitable for production use.\n\nIt may be best to switch to the default Rust standard allocator on wasm32 targets.\n\nLast release seems to have been three years ago.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - Rust standard [default allocator] on wasm32-target\n\n## Honorable Mention(s)\n\n The below may serve to educate on potential future alternatives:\n\n - [lol_alloc](https://crates.io/crates/lol_alloc)\n\n[default allocator]: https://github.com/alexcrichton/dlmalloc-rs\n",
    "likely_poc": [
      "https://github.com/rustwasm/wee_alloc/issues/107",
      "https://github.com/rustwasm/wee_alloc/issues/85",
      "https://github.com/rustwasm/wee_alloc/issues/106"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0089",
      "package": "raw-cpuid",
      "date": "2021-01-20",
      "url": "https://github.com/gz/rust-cpuid/issues/43",
      "categories": [
        "memory-corruption",
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2021-45687",
        "GHSA-jf5h-cf95-w759",
        "GHSA-w428-f65r-h4q2"
      ]
    },
    "versions": {
      "patched": [
        ">= 9.1.1"
      ],
      "unaffected": [
        "<= 3.1.0"
      ]
    },
    "text": "\n\n# Optional `Deserialize` implementations lacking validation\n\nWhen activating the non-default feature `serialize`, most structs implement\n`serde::Deserialize` without sufficient validation. This allows breaking\ninvariants in safe code, leading to:\n\n* Undefined behavior in `as_string()` methods (which use\n  `std::str::from_utf8_unchecked()` internally).\n* Panics due to failed assertions.\n\nSee https://github.com/gz/rust-cpuid/issues/43.\n",
    "likely_poc": [
      "https://github.com/gz/rust-cpuid/issues/43"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0013",
      "package": "raw-cpuid",
      "aliases": [
        "CVE-2021-26306",
        "CVE-2021-26307",
        "GHSA-hvqc-pc78-x9wh",
        "GHSA-jrf8-cmgg-gv2m"
      ],
      "date": "2021-01-20",
      "url": "https://github.com/RustSec/advisory-db/pull/614",
      "categories": [
        "memory-corruption",
        "denial-of-service"
      ]
    },
    "versions": {
      "patched": [
        ">= 9.0.0"
      ]
    },
    "affected": {
      "arch": [
        "x86",
        "x86_64"
      ]
    },
    "text": "\n\n# Soundness issues in `raw-cpuid`\n\n## Undefined behavior in `as_string()` methods\n\n`VendorInfo::as_string()`, `SoCVendorBrand::as_string()`,\nand `ExtendedFunctionInfo::processor_brand_string()` construct byte slices\nusing `std::slice::from_raw_parts()`, with data coming from\n`#[repr(Rust)]` structs. This is always undefined behavior.\n\nSee https://github.com/gz/rust-cpuid/issues/40.\n\nThis flaw has been fixed in v9.0.0, by making the relevant structs\n`#[repr(C)]`.\n\n## `native_cpuid::cpuid_count()` is unsound\n\n`native_cpuid::cpuid_count()` exposes the unsafe `__cpuid_count()` intrinsic\nfrom `core::arch::x86` or `core::arch::x86_64` as a safe function, and uses\nit internally, without checking the\n[safety requirement](https://doc.rust-lang.org/core/arch/index.html#overview):\n\n> The CPU the program is currently running on supports the function being\n> called.\n\nCPUID is available in most, but not all, x86/x86_64 environments. The crate\ncompiles only on these architectures, so others are unaffected.\n\nThis issue is mitigated by the fact that affected programs are expected\nto crash deterministically every time.\n\nSee https://github.com/gz/rust-cpuid/issues/41.\n\nThe flaw has been fixed in v9.0.0, by intentionally breaking compilation\nwhen targeting SGX or 32-bit x86 without SSE. This covers all affected CPUs.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0130",
      "package": "lru",
      "date": "2021-12-21",
      "url": "https://github.com/jeromefroe/lru-rs/issues/120",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ],
      "aliases": [
        "CVE-2021-45720",
        "GHSA-qqmc-hwqp-8g2w",
        "GHSA-v362-2895-h9r2"
      ]
    },
    "affected": {
      "functions": {
        "lru::LruCache::iter": [
          "< 0.7.1"
        ],
        "lru::LruCache::iter_mut": [
          "< 0.7.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# Use after free in lru crate\n\nLru crate has use after free vulnerability.\n\nLru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.\n",
    "likely_poc": [
      "https://github.com/jeromefroe/lru-rs/issues/120"
    ]
  },
  {
    "advisory": {
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "date": "2020-05-11",
      "id": "RUSTSEC-2020-0021",
      "package": "rio",
      "aliases": [
        "CVE-2020-35876",
        "GHSA-8rc5-mr4f-m243"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "url": "https://github.com/spacejam/rio/issues/11"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# rio allows a use-after-free buffer access when a future is leaked\n\nWhen a `rio::Completion` is leaked, its drop code will not run. The drop code\nis responsible for waiting until the kernel completes the I/O operation into, or\nout of, the buffer borrowed by `rio::Completion`. Leaking the struct will allow\none to access and/or drop the buffer, which can lead to a use-after-free,\ndata races or leaking secrets.\n\nUpstream is not interested in fixing the issue.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0005",
      "package": "cbox",
      "aliases": [
        "CVE-2020-35860",
        "GHSA-3vjm-36rr-7qrq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-03-19",
      "url": "https://github.com/TomBebbington/cbox-rs/issues/2"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# CBox API allows to de-reference raw pointers without `unsafe` code\n\n`CBox` and `CSemiBox` are part of the public API of the cbox crate\nand they allow to create smart pointers from raw pointers and de-reference\nthem without the need of `unsafe` code.\n",
    "likely_poc": [
      "https://github.com/TomBebbington/cbox-rs/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0029",
      "package": "crossbeam",
      "date": "2022-06-07",
      "categories": [
        "thread-safety",
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/98",
      "aliases": [
        "GHSA-rwf4-gx62-rqfw"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# `MsQueue` `push`/`pop` use the wrong orderings\n\nAffected versions of this crate use orderings which are too weak to support this data structure.\nIt is likely this has caused memory corruption in the wild: <https://github.com/crossbeam-rs/crossbeam/issues/97#issuecomment-412785919>.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/98"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0009",
      "package": "crossbeam",
      "aliases": [
        "CVE-2018-20996",
        "GHSA-c3cw-c387-pj65"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-12-09",
      "keywords": [
        "concurrency",
        "memory-management",
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam-epoch/issues/82"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# MsQueue and SegQueue suffer from double-free\n\nEven if an element is popped from a queue, crossbeam would run its\ndestructor inside the epoch-based garbage collector. This is a source\nof double frees.\n\nThe flaw was corrected by wrapping elements inside queues in a\n`ManuallyDrop`.\n\nThanks to @c0gent for reporting the issue.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam-epoch/issues/82"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0020",
      "package": "crossbeam",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-8gj8-hv75-gp94"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# `SegQueue` creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/458"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0004",
      "package": "lazy-init",
      "aliases": [
        "CVE-2021-25901",
        "GHSA-w47j-hqpf-qw9w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
      "date": "2021-01-17",
      "categories": [
        "memory-corruption"
      ],
      "url": "https://github.com/khuey/lazy-init/issues/9"
    },
    "versions": {
      "patched": [
        "> 0.4.0"
      ]
    },
    "text": "\n\n# Missing Send bound for Lazy\n\nAll current versions of this crate allow causing data races in safe code.\n\nThe flaw will be fixed in the next release.\n",
    "likely_poc": [
      "https://github.com/khuey/lazy-init/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0072",
      "package": "futures-intrusive",
      "aliases": [
        "CVE-2020-35915",
        "GHSA-4hjg-cx88-g9f9"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-31",
      "url": "https://github.com/Matthias247/futures-intrusive/issues/53",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# GenericMutexGuard allows data races of non-Sync types across threads\n\n`GenericMutexGuard<T>` was given the `Sync` auto trait as long as `T` is `Send`\ndue to its contained members. However, since the guard is supposed to represent\nan **acquired lock** and allows concurrent access to the underlying data from\ndifferent threads, it should only be `Sync` when the underlying data is.\n\nThis is a soundness issue and allows data races, potentially leading to crashes\nand segfaults from safe Rust code.\n\nThe flaw was corrected by adding a `T: Send + Sync` bound for\n`GenericMutexGuard`'s `Sync` trait.\n\nThis bug is [similar to one](https://github.com/rust-lang/rust/issues/41622) in\n`std::sync::Mutex`.\n",
    "likely_poc": [
      "https://github.com/Matthias247/futures-intrusive/issues/53"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0021",
      "package": "crossbeam-queue",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-6888-wf7j-34jq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "text": "\n\n# `SegQueue` creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/458"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0086",
      "package": "flumedb",
      "date": "2021-01-07",
      "url": "https://github.com/sunrise-choir/flumedb-rs/issues/10",
      "references": [
        "https://github.com/sunrise-choir/flumedb-rs/pull/12"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45684",
        "GHSA-p46c-w9m3-7qr2",
        "GHSA-p56p-gq3f-whg8"
      ]
    },
    "versions": {
      "patched": [
        ">=0.1.6"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB ( `read_entry()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\nThere are two of such cases (`go_offset_log::read_entry()` & `offset_log::read_entry()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": [
      "https://github.com/sunrise-choir/flumedb-rs/pull/12"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0087",
      "package": "try-mutex",
      "aliases": [
        "CVE-2020-35924",
        "GHSA-64j8-7gp2-xjx5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-17",
      "url": "https://github.com/mpdn/try-mutex/issues/2",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# TryMutex<T> allows sending non-Send type across threads\n\nAffected versions of this crate unconditionally implemented Sync trait for `TryMutex<T>` type.\n\nThis allows users to put non-Send `T` type in `TryMutex` and send it to another thread, which can cause a data race.\n\nThe flaw was corrected in the 0.3.0 release by adding `T: Send` bound for the Sync trait implementation.\n",
    "likely_poc": [
      "https://github.com/mpdn/try-mutex/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0044",
      "package": "atom",
      "aliases": [
        "CVE-2020-35897",
        "GHSA-9cg2-2j2h-59v9"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-21",
      "informational": "unsound",
      "url": "https://github.com/slide-rs/atom/issues/13",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.6"
      ]
    },
    "text": "\n\n# Unsafe Send implementation in Atom allows data races\n\nThe `atom` crate contains a security issue revolving around its implementation\nof the Send trait. It incorrectly allows any arbitrary type to be sent across\nthreads potentially leading to use-after-free issues through memory races.\n",
    "likely_poc": [
      "https://github.com/slide-rs/atom/issues/13"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0023",
      "package": "rulinalg",
      "aliases": [
        "CVE-2020-35879",
        "GHSA-q2gj-9r85-p832"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-02-11",
      "url": "https://github.com/AtheMathmo/rulinalg/issues/201"
    },
    "affected": {
      "functions": {
        "rulinalg::matrix::RowMut::raw_slice": [
          ">= 0.4.0"
        ],
        "rulinalg::matrix::RowMut::raw_slice_mut": [
          ">= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Lifetime boundary for `raw_slice` and `raw_slice_mut` are incorrect\n\nThe affected version of `rulinalg` has incorrect lifetime boundary definitions\nfor `RowMut::raw_slice` and `RowMut::raw_slice_mut`. They do not conform with\nRust's borrowing rule and allows the user to create multiple mutable references\nto the same location. This may result in unexpected calculation result and data\nrace if both references are used at the same time.\n",
    "likely_poc": [
      "https://github.com/AtheMathmo/rulinalg/issues/201"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0151",
      "package": "generator",
      "aliases": [
        "CVE-2020-36471",
        "GHSA-w3g5-2848-2v8r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-16",
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/27",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# Generators can cause data races if non-Send types are used in their generator functions\n\nThe `Generator` type is an iterable which uses a generator function that yields\nvalues. In affected versions of the crate, the provided function yielding values\nhad no `Send` bounds despite the `Generator` itself implementing `Send`.\n\nThe generator function lacking a `Send` bound means that types that are\ndangerous to send across threads such as `Rc` could be sent as part of a\ngenerator, potentially leading to data races.\n\nThis flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)\nby enforcing that the generator function be bound by `Send`.\n",
    "likely_poc": [
      "https://github.com/Xudong-Huang/generator-rs/issues/27"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0020",
      "package": "generator",
      "date": "2019-09-06",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/9",
      "aliases": [
        "CVE-2019-16144",
        "GHSA-6c65-xcf5-299x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.6.18"
      ]
    },
    "text": "\n\n# fix unsound APIs that could lead to UB\n\nAffected versions of this crate API could use uninitialized memory with some APIs in special\ncases, like use the API in none generator context. This could lead to UB.\nThe flaw was corrected by <https://github.com/Xudong-Huang/generator-rs/issues/9>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/11>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/13>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/14>                                                  \nThis patch fixes all those issues above.\n",
    "likely_poc": [
      "https://github.com/Xudong-Huang/generator-rs/issues/9"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0074",
      "package": "prettytable-rs",
      "date": "2022-12-02",
      "url": "https://github.com/phsym/prettytable-rs/issues/145",
      "informational": "unsound",
      "keywords": [
        "tab",
        "table",
        "format",
        "pretty",
        "print"
      ],
      "aliases": [
        "GHSA-gfgm-chr3-x6px"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.0"
      ]
    },
    "text": "\n\n# Force cast a &Vec<T> to &[T]\n\nIn function `Table::as_ref`, a reference of vector is force cast to slice. There are multiple problems here:\n1. To guarantee the size is correct, we have to first do `Vec::shrink_to_fit`. The function requires a mutable reference, so we have to force cast from immutable to mutable, which is UB.\n2. Even if (1) is sound, `&Vec<T>` and `&[T]` still might not have the same layout. Treating them equally may lead to UB.\n",
    "likely_poc": [
      "https://github.com/phsym/prettytable-rs/issues/145"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0372",
      "package": "ic-cdk",
      "date": "2024-09-05",
      "url": "https://github.com/dfinity/cdk-rs/pull/509",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "canister",
        "icp",
        "cdk"
      ],
      "aliases": [
        "CVE-2024-7884",
        "GHSA-rwq6-crjg-9cpw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        "^0.8.2",
        "^0.9.3",
        "^0.10.1",
        "^0.11.6",
        "^0.12.2",
        "^0.13.5",
        "^0.14.1",
        "^0.15.1",
        ">= 0.16.0"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n# Memory leak when calling a canister method via `ic_cdk::call`\n\nWhen a canister method is called via `ic_cdk::call*`, a new Future `CallFuture` is created  and can be awaited by the caller to get the execution result. Internally, the state of the Future is tracked and stored in a struct called `CallFutureState`.  A bug in the polling implementation of the `CallFuture` allows multiple references to be held for this internal state and not all references were dropped before the `Future` is resolved. Since we have unaccounted references held, a copy of the internal state ended up being persisted in the canister's heap and thus causing a memory leak. \n\n### Impact\nCanisters built in Rust with `ic_cdk` and `ic_cdk_timers` are affected. If these canisters call a canister method, use timers or heartbeat, they will likely leak a small amount of memory on every such operation. **In the worst case, this could lead to heap memory exhaustion triggered by an attacker.**\n\nMotoko based canisters are not affected by the bug.\n\n### Patches\nThe patch has been backported to all minor versions between `>= 0.8.0, <= 0.15.0`. The patched versions available are `0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1` and their previous versions have been yanked. \n\n### Workarounds\nThere are no known workarounds at the moment. Developers are recommended to upgrade their canister as soon as possible to the latest available patched version of `ic_cdk` to avoid running out of Wasm heap memory. \n\n> Upgrading the canisters (without updating `ic_cdk`) also frees the leaked memory but it's only a temporary solution.\n\n### Referencesas\n- [dfinity/cdk-rs/pull/509](https://github.com/dfinity/cdk-rs/pull/509)\n- [ic_cdk docs](https://docs.rs/ic-cdk/latest/ic_cdk/)\n- [Internet Computer Specification](https://internetcomputer.org/docs/current/references/ic-interface-spec)\n\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0079",
      "package": "socket2",
      "date": "2020-11-06",
      "url": "https://github.com/rust-lang/socket2-rs/issues/119",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-35919",
        "CVE-2020-35920",
        "GHSA-458v-4hrf-g3m4",
        "GHSA-c79c-gwph-gqfm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.16"
      ]
    },
    "text": "\n\n# `socket2` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`socket2`](https://crates.io/crates/socket2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0022",
      "package": "portaudio-rs",
      "aliases": [
        "CVE-2019-16881",
        "GHSA-qpjr-ch72-2qq4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "date": "2019-09-14",
      "keywords": [
        "audio",
        "ffi"
      ],
      "url": "https://github.com/mvdnes/portaudio-rs/issues/20"
    },
    "versions": {
      "patched": [
        "> 0.3.1"
      ]
    },
    "text": "\n\n# Stream callback function is not unwind safe\n\nAffected versions of this crate is not panic safe within callback functions `stream_callback` and `stream_finished_callback`.\n\nThe call to user-provided closure might panic before a `mem::forget` call, which then causes a use after free that grants attacker to control the callback function pointer.\n\nThis allows an attacker to construct an arbitrary code execution .\n \nThe flaw was reported by Phosphorus15.\n",
    "likely_poc": [
      "https://github.com/mvdnes/portaudio-rs/issues/20"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0018",
      "package": "qwutils",
      "aliases": [
        "CVE-2021-26954",
        "GHSA-68p4-pjpf-xwcq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
      "date": "2021-02-03",
      "url": "https://github.com/qwertz19281/rust_utils/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "affected": {
      "functions": {
        "qwutils::imp::vec::VecExt::insert_slice_clone": [
          "< 0.3.1"
        ]
      }
    },
    "text": "\n\n# insert_slice_clone can double drop if Clone panics.\n\nAffected versions of this crate used `ptr::copy` when inserting into the middle\nof a `Vec`. When ownership was temporarily duplicated during this copy, it calls\nthe clone method of a user provided element.\n\nThis issue can result in an element being double-freed if the clone call panics.\n\nCommit `20cb73d` fixed this issue by adding a `set_len(0)` call before\noperating on the vector to avoid dropping the elements during a panic.\n",
    "likely_poc": [
      "https://github.com/qwertz19281/rust_utils/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0111",
      "package": "may_queue",
      "aliases": [
        "CVE-2020-36217",
        "GHSA-pphf-f93w-gc84"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/Xudong-Huang/may/issues/88",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# may_queue's Queue lacks Send/Sync bound for its Send/Sync trait.\n\nAffected versions of `may_queue` implements `Send`/`Sync` for its `Queue` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.\n",
    "likely_poc": [
      "https://github.com/Xudong-Huang/may/issues/88"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0103",
      "package": "autorand",
      "aliases": [
        "CVE-2020-36210",
        "GHSA-cgmg-2v6m-fjg7"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-31",
      "url": "https://github.com/mersinvald/autorand-rs/issues/5",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "text": "\n\n# `impl Random` on arrays can lead to dropping uninitialized memory\n\nAffected versions of this crate had a panic safety issue to drop partially uninitialized array of `T` upon panic in a user provided function `T::random()`. Dropping uninitialized `T` can potentially cause memory corruption or undefined behavior.\n\nThe flaw was corrected in commit 565d508 by using `MaybeUninit<T>` to avoid possible dropping of uninitialized memory upon panic.\n",
    "likely_poc": [
      "https://github.com/mersinvald/autorand-rs/issues/5"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0016",
      "package": "partial_sort",
      "date": "2023-02-20",
      "url": "https://github.com/sundy-li/partial_sort/issues/7",
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "out-of-bounds read"
      ],
      "aliases": [
        "GHSA-5x36-7567-3cw6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Possible out-of-bounds read in release mode\n\nAffected versions of this crate were using a debug assertion to validate the\n`last` parameter of `partial_sort()`. This would allow invalid inputs to cause\nan out-of-bounds read instead of immediately panicking, when compiled without\ndebug assertions.\n\nAll writes are bounds-checked, so the out-of-bounds memory access is read-only.\nThis also means that the first attempted out-of-bounds write will panic,\nlimiting the possible reads.\n\nThe accessible region is further limited by an initial bounds-checked read\nat `(last / 2) - 1`, i.e., it is proportional to the size of the vector.\n\nThis bug has been fixed in v0.2.0.\n",
    "likely_poc": [
      "https://github.com/sundy-li/partial_sort/issues/7"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0070",
      "package": "nalgebra",
      "date": "2021-06-06",
      "url": "https://github.com/dimforge/nalgebra/issues/883",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory-safety"
      ],
      "aliases": [
        "CVE-2021-38190",
        "GHSA-3w8g-xr3f-2mp8"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.27.1"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# VecStorage Deserialize Allows Violation of Length Invariant\n\nThe `Deserialize` implementation for `VecStorage` did not maintain the invariant that the number of elements must equal `nrows * ncols`. Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.\n\nThis flaw was introduced in v0.11.0 ([`086e6e`](https://github.com/dimforge/nalgebra/commit/086e6e719f53fecba6dadad2e953a487976387f5)) due to the addition of an automatically derived implementation of `Deserialize` for `MatrixVec`. `MatrixVec` was later renamed to `VecStorage` in v0.16.13 ([`0f66403`](https://github.com/dimforge/nalgebra/commit/0f66403cbbe9eeac15cedd8a906c0d6a3d8841f2)) and continued to use the automatically derived implementation of `Deserialize`.\n\nThis flaw was corrected in commit [`5bff536`](https://github.com/dimforge/nalgebra/commit/5bff5368bf38ddfa31416e4ae9897b163031a513) by returning an error during deserialization if the number of elements does not exactly match the expected size.\n",
    "likely_poc": [
      "https://github.com/dimforge/nalgebra/issues/883"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0366",
      "package": "cosmwasm-vm",
      "date": "2024-08-27",
      "url": "https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2023-004.md",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "resource-consumption",
        "crash",
        "deadlock"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.8, < 1.3.0",
        ">= 1.3.4, < 1.4.0",
        ">= 1.4.2, < 1.5.0",
        ">= 1.5.1"
      ]
    },
    "text": "\n\n# CWA-2023-004: Excessive number of function parameters in compiled Wasm\n\nA specifically crafted Wasm file can cause the VM to consume excessive amounts of memory when compiling a contract.\nThis can lead to high memory usage, slowdowns, potentially a crash and can poison a lock in the VM,\npreventing any further interaction with contracts.\n\nFor more information, see [CWA-2023-004](https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2023-004.md).\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0002",
      "package": "vmm-sys-util",
      "date": "2024-01-02",
      "url": "https://github.com/advisories/GHSA-875g-mfp6-g7f9",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L",
      "aliases": [
        "CVE-2023-50711",
        "GHSA-875g-mfp6-g7f9"
      ]
    },
    "affected": {
      "functions": {
        "vmm_sys_util::fam::FamStructWrapper::deserialize": [
          "< 0.12.0, >= 0.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.12.0"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "text": "\n\n# `serde` deserialization for `FamStructWrapper` lacks bound checks that could potentially lead to out-of-bounds memory access\n\n## Impact\n\nAn issue was discovered in the `FamStructWrapper::deserialize` implementation\nprovided by the crate for `vmm_sys_util::fam::FamStructWrapper`, which can lead\nto out of bounds memory accesses. The deserialization does not check that the\nlength stored in the header matches the flexible array length. Mismatch in the\nlengths might allow out of bounds memory access through Rust-safe methods.\n\nImpacted versions: >= 0.5.0\n\n## Patches\n\nThe issue was corrected in version 0.12.0 by inserting a check that verifies\nthe lengths of compared flexible arrays are equal for any deserialized header\nand aborting deserialization otherwise. Moreover, the API was changed so that\nheader length can only be modified through Rust-unsafe code. This ensures that\nusers cannot trigger out-of-bounds memory access from Rust-safe code.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0042",
      "package": "insert_many",
      "aliases": [
        "CVE-2021-29933",
        "GHSA-29hg-r7c7-54fr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-26",
      "url": "https://github.com/rphmeier/insert_many/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# insert_many can drop elements twice on panic\n\nAffected versions of `insert_many` used `ptr::copy` to move over items in a\nvector to make space before inserting, duplicating their ownership. It then\niterated over a provided `Iterator` to insert the new items.\n\nIf the iterator's `.next()` method panics then the vector would drop the same\nelements twice.\n",
    "likely_poc": [
      "https://github.com/rphmeier/insert_many/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0148",
      "package": "cgc",
      "date": "2020-12-10",
      "url": "https://github.com/playXE/cgc/issues/5",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "aliasing",
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36466",
        "CVE-2020-36467",
        "CVE-2020-36468",
        "GHSA-f3mq-99jr-ww4r",
        "GHSA-f9xr-3m55-5q2v",
        "GHSA-pwhf-7427-9vv2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple soundness issues in `Ptr`\n\nAffected versions of this crate have the following issues:\n\n1. `Ptr` implements `Send` and `Sync` for all types, this can lead to data\n   races by sending non-thread safe types across threads.\n\n2. `Ptr::get` violates mutable alias rules by returning multiple mutable\n   references to the same object.\n\n3. `Ptr::write` uses non-atomic writes to the underlying pointer. This means\n   that when used across threads it can lead to data races.\n",
    "likely_poc": [
      "https://github.com/playXE/cgc/issues/5"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0074",
      "package": "pyo3",
      "aliases": [
        "CVE-2020-35917",
        "GHSA-2vx6-fcw6-hpr6"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-28",
      "url": "https://github.com/PyO3/pyo3/pull/1297",
      "keywords": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.12.4"
      ],
      "unaffected": [
        "< 0.12.0"
      ]
    },
    "text": "\n\n# Reference counting error in `From<Py<T>>`\n\nA bug in `From<Py<T>>` would lead to an extra reference count decrement, often\nleading to use-after-free issues.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0037",
      "package": "crayon",
      "aliases": [
        "CVE-2020-35889",
        "GHSA-m833-jv95-mfjh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-08-31",
      "informational": "unsound",
      "url": "https://github.com/shawnscode/crayon/issues/87"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Misbehaving `HandleLike` implementation can lead to memory safety violation\n\nUnsafe code in `ObjectPool` has time-of-check to time-of-use (TOCTOU) bug that\ncan eventually lead to a memory safety violation. `ObjectPool` and `HandlePool`\nimplicitly assumes that `HandleLike` trait methods are pure, i.e., they always\nreturn the same value. However, this assumption is unsound since `HandleLike`\nis a safe, public trait that allows a custom implementation.\n",
    "likely_poc": [
      "https://github.com/shawnscode/crayon/issues/87"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0018",
      "package": "crayon",
      "date": "2024-02-27",
      "url": "https://github.com/shawnscode/crayon/issues/109",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "std::mem::uninitialized",
        "address-sanitizer"
      ],
      "aliases": [
        "GHSA-xfhw-6mc4-mgxf"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.6.0"
      ]
    },
    "affected": {
      "functions": {
        "crayon::utils::object_pool::ObjectPool<H,T>::free": [
          ">=0.6.0"
        ]
      }
    },
    "text": "\n\n# ObjectPool creates uninitialized memory when freeing objects\n\nAs of version 0.6.0, the ObjectPool explicitly creates an uninitialized instance of its\ntype parameter when it attempts to free an object, and swaps it into the storage. This\ncauses instant undefined behavior due to reading the uninitialized memory in order to\nwrite it to the pool storage.\n\nExtremely basic usage of the crate can trigger this issue, e.g. this code from a doctest:\n\n```rust\nuse crayon::prelude::*;\napplication::oneshot().unwrap();\n\nlet mut params = MeshParams::default();\n\nlet mesh = video::create_mesh(params, None).unwrap();\n\n// Deletes the mesh object.\nvideo::delete_mesh(mesh); // <-- UB\n```\n\nThe Clippy warning for this code was silenced in commit c2fde19caf6149d91faa504263f0bc5cafc35de5.\n\nDiscovered via https://asan.saethlin.dev/ub?crate=crayon&version=0.7.1\n",
    "likely_poc": [
      "https://github.com/shawnscode/crayon/issues/109"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0152",
      "package": "max7301",
      "date": "2020-12-18",
      "url": "https://github.com/edarc/max7301/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36472",
        "GHSA-rmff-f8w9-c9rm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# ImmediateIO and TransactionalIO can cause data races\n\nThe `ImmediateIO` and `TransactionalIO` types implement `Sync` for all contained\n`Expander<EI>` types regardless of if the `Expander` itself is safe to use\nacross threads.\n\nAs the `IO` types allow retrieving the `Expander`, this can lead to non-thread\nsafe types being sent across threads as part of the `Expander` leading to data\nraces.\n",
    "likely_poc": [
      "https://github.com/edarc/max7301/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0085",
      "package": "binjs_io",
      "date": "2021-01-03",
      "url": "https://github.com/binast/binjs-ref/issues/460",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45683",
        "GHSA-c6px-4grw-hrjr",
        "GHSA-cw4j-cf6c-mmfv"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# 'Read' on uninitialized memory may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. The crate currently contains 4 occurrences of such cases.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0051",
      "package": "outer_cgi",
      "aliases": [
        "CVE-2021-30454",
        "GHSA-6vmq-jh76-hq43"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-31",
      "url": "https://github.com/SolraBizna/outer_cgi/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# KeyValueReader passes uninitialized memory to Read instance\n\nThe `KeyValueReader` type in affected versions of this crate set up an\nuninitialized memory buffer and passed them to be read in to a user-provided\n`Read` instance.\n\nThe `Read` instance could read uninitialized memory and cause undefined\nbehavior and miscompilations.\n\nThis issue was fixed in commit [dd59b30](https://github.com/SolraBizna/outer_cgi/commit/dd59b3066e616a08e756f72de8dc3ab11b7036c4)\nby zero-initializing the buffers before passing them.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0091",
      "package": "gfx-auxil",
      "date": "2021-01-07",
      "url": "https://github.com/gfx-rs/gfx/issues/3567",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45689",
        "GHSA-28p5-7rg4-8v99",
        "GHSA-ff2r-xpwq-6whj"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Reading on uninitialized buffer may cause UB ( `gfx_auxil::read_spirv()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": [
      "https://github.com/gfx-rs/gfx/issues/3567"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0093",
      "package": "crossbeam-deque",
      "aliases": [
        "GHSA-pqqp-xmhj-wgcw",
        "CVE-2021-32810"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2021-07-30",
      "url": "https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-pqqp-xmhj-wgcw"
    },
    "versions": {
      "patched": [
        ">= 0.7.4, < 0.8.0",
        ">= 0.8.1"
      ]
    },
    "text": "\n\n# Data race in crossbeam-deque\n\nIn the affected version of this crate, the result of the race condition is that one or more tasks in the worker queue can be popped twice instead of other tasks that are forgotten and never popped. If tasks are allocated on the heap, this can cause double free and a memory leak. If not, this still can cause a logical bug.\n\nCrates using `Stealer::steal`, `Stealer::steal_batch`, or `Stealer::steal_batch_and_pop` are affected by this issue.\n\nCredits to @kmaork for discovering, reporting and fixing the bug.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0052",
      "package": "id-map",
      "aliases": [
        "CVE-2021-30455",
        "CVE-2021-30456",
        "CVE-2021-30457",
        "GHSA-8gmx-cpcg-f8h5",
        "GHSA-rccq-j2m7-8fwr",
        "GHSA-vfqx-hv88-f9cv"
      ],
      "date": "2021-02-26",
      "url": "https://github.com/andrewhickman/id-map/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple functions can cause double-frees\n\nThe following functions in the crate are affected:\n\n## `IdMap::clone_from`\n\nThe `clone_from` implementation for `IdMap` drops the values present in the\nmap and then begins cloning values from the other map. If a `.clone()` call\npancics, then the afformentioned dropped elements can be freed again.\n\n## `get_or_insert`\n\n`get_or_insert` reserves space for a value, before calling the user provided\ninsertion function `f`. If the function `f` panics then uninitialized or\npreviously freed memory can be dropped.\n\n## `remove_set`\n\nWhen removing a set of elements, `ptr::drop_in_place` is called on each of the\nelement to be removed. If the `Drop` impl of one of these elements panics then\nthe previously dropped elements can be dropped again.\n",
    "likely_poc": [
      "https://github.com/andrewhickman/id-map/issues/3"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0126",
      "package": "signal-simple",
      "date": "2020-11-15",
      "url": "https://github.com/kitsuneninetails/signal-rust/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36446",
        "GHSA-36cg-4jff-5863",
        "GHSA-8892-84wf-cg8f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# SyncChannel<T> can move 'T: !Send' to other threads\n\nAffected versions of this crate unconditionally implement Send/Sync for `SyncChannel<T>`.\n`SyncChannel<T>` doesn't provide access to `&T` but merely serves as a channel that consumes and returns owned `T`.\n\nUsers can create UB in safe Rust by sending `T: !Send` to other threads with `SyncChannel::send/recv` APIs. Using `T = Arc<Cell<_>` allows to create data races (which can lead to memory corruption), and using `T = MutexGuard<T>` allows to unlock a mutex from a thread that didn't lock the mutex.\n",
    "likely_poc": [
      "https://github.com/kitsuneninetails/signal-rust/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0038",
      "package": "fltk",
      "aliases": [
        "CVE-2021-28306",
        "CVE-2021-28307",
        "CVE-2021-28308",
        "GHSA-5pg8-h4gv-m3p8",
        "GHSA-7qcc-g2m9-8533",
        "GHSA-vjmg-pc8h-p6p8"
      ],
      "date": "2021-03-06",
      "keywords": [
        "undefined_behavior"
      ],
      "url": "https://github.com/MoAlyousef/fltk-rs/issues/519"
    },
    "affected": {
      "functions": {
        "fltk::prelude::WidgetExt::set_label_type": [
          "< 0.15.2"
        ],
        "fltk::prelude::WindowExt::set_icon": [
          "< 0.14.12"
        ],
        "fltk::image::Pixmap::new": [
          "< 0.15.2, >= 0.14.12"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.15.3"
      ]
    },
    "text": "\n\n# Multiple memory safety issues\n\nAffected versions contain multiple memory safety issues, such as:\n\n - Setting a multi label type where an image doesn't exist would lead to a NULL pointer dereference.\n - Setting a window icon using a non-raster image (which FLTK rasterizes lazily) would lead to a NULL dereference.\n - Pixmap constructor would not check for correct pixmaps which could lead to out-of bound reads.\n",
    "likely_poc": [
      "https://github.com/MoAlyousef/fltk-rs/issues/519"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0127",
      "package": "v9",
      "date": "2020-12-18",
      "url": "https://github.com/purpleposeidon/v9/issues/1",
      "references": [
        "https://github.com/purpleposeidon/v9/commit/18847c50e5d36561cc91c996c3539ddb1eacf6c7"
      ],
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36447",
        "GHSA-3837-87vh-xq3w",
        "GHSA-pfjq-935c-4895"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.43"
      ]
    },
    "text": "\n\n# SyncRef's clone() and debug() allow data races\n\nAffected versions of this crate unconditionally implement `Sync` for `SyncRef<T>`.\nThis definition allows data races if `&T` is accessible through `&SyncRef`.\n\n`SyncRef<T>` derives `Clone` and `Debug`, and the default implementations of those traits access `&T` by invoking `T::clone()` & `T::fmt()`. It is possible to create data races & undefined behavior by concurrently invoking `SyncRef<T>::clone()` or `SyncRef<T>::fmt()` from multiple threads with `T: !Sync`.\n",
    "likely_poc": [
      "https://github.com/purpleposeidon/v9/issues/1"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0161",
      "package": "array-macro",
      "date": "2020-05-07",
      "url": "https://gitlab.com/KonradBorowski/array-macro/-/commit/01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-83gg-pwxf-jr89"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.5"
      ],
      "unaffected": [
        "< 0.1.2"
      ]
    },
    "text": "\n\n# `array!` macro is unsound in presence of traits that implement methods it calls internally\n\nAffected versions of this crate called some methods using auto-ref. The affected code looked like this.\n\n```rust\nlet mut arr = $crate::__core::mem::MaybeUninit::uninit();\nlet mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);\n```\n\nIn this case, the problem is that `as_mut_ptr` is a method of `&mut MaybeUninit`, not `MaybeUninit`. This made it possible for traits to hijack the method calls in order to cause unsoundness.\n\n```rust\ntrait AsMutPtr<T> {\n    fn as_mut_ptr(&self) -> *mut T;\n}\nimpl<T> AsMutPtr<T> for std::mem::MaybeUninit<T> {\n    fn as_mut_ptr(&self) -> *mut T {\n        std::ptr::null_mut()\n    }\n}\narray![0; 1];\n```\n\nThe flaw was corrected by explicitly referencing variables in macro body in order to avoid auto-ref.\n",
    "likely_poc": [
      "https://gitlab.com/KonradBorowski/array-macro/-/commit/01940637dd8f3bfeeee3faf9639fa9ae52f19f4d"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0017",
      "package": "array-macro",
      "date": "2022-04-27",
      "url": "https://gitlab.com/KonradBorowski/array-macro/-/issues/5",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-7v4j-8wvr-v55r"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.1.2"
      ],
      "unaffected": [
        "< 2.1.0"
      ]
    },
    "text": "\n\n# `array!` macro is unsound when its length is impure constant\n\nAffected versions of this crate did substitute the array length provided by an user at compile-time multiple times.\n\nWhen an impure constant expression is passed as an array length (such as a result of an impure procedural macro), this can result in the initialization of an array with uninitialized types, which in turn can allow an attacker to execute arbitrary code.\n\nThe flaw was corrected in commit [d5b63f72](https://gitlab.com/KonradBorowski/array-macro/-/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d) by making sure that array length is substituted just once.\n",
    "likely_poc": [
      "https://gitlab.com/KonradBorowski/array-macro/-/issues/5"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0025",
      "package": "bigint",
      "aliases": [
        "CVE-2020-35880",
        "GHSA-wgx2-6432-j3fw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-05-07",
      "informational": "unmaintained",
      "url": "https://github.com/paritytech/bigint/commit/7e71521a61b009afc94c91135353102658550d42"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# bigint is unmaintained, use uint instead\n\nThe `bigint` crate is not maintained any more and contains several known bugs (including a soundness bug);\nuse [`uint`](https://crates.io/crates/uint) instead.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0016",
      "package": "chttp",
      "aliases": [
        "CVE-2019-16140",
        "GHSA-5rrv-m36h-qwf8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-09-01",
      "keywords": [
        "memory-management",
        "memory-corruption"
      ],
      "url": "https://github.com/sagebind/isahc/issues/2"
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ],
      "unaffected": [
        "< 0.1.1"
      ]
    },
    "text": "\n\n# Use-after-free in buffer conversion implementation\n\nThe From<Buffer> implementation for Vec<u8> was not properly implemented,\nreturning a vector backed by freed memory. This could lead to memory corruption\nor be exploited to cause undefined behavior.\n \nA fix was published in version 0.1.3.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0052",
      "package": "crossbeam-channel",
      "aliases": [
        "CVE-2020-15254",
        "CVE-2020-35904",
        "GHSA-m8h8-v6jh-c762",
        "GHSA-v5m7-53cv-f3hx"
      ],
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-06-26",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/533"
    },
    "versions": {
      "patched": [
        ">= 0.4.4"
      ],
      "unaffected": [
        "< 0.4.3"
      ]
    },
    "text": "\n\n# Undefined Behavior in bounded channel\n\nThe affected version of this crate's the `bounded` channel incorrectly assumes that `Vec::from_iter` has allocated capacity that same as the number of iterator elements. `Vec::from_iter` does not actually guarantee that and may allocate extra memory. The destructor of the `bounded` channel reconstructs `Vec` from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when `Vec::from_iter` has allocated different sizes with the number of iterator elements.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/533"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0019",
      "package": "crossbeam-channel",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-9g55-pg62-m8hh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# Channel creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n",
    "likely_poc": [
      "https://github.com/crossbeam-rs/crossbeam/pull/458"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0008",
      "package": "windows",
      "date": "2022-01-02",
      "url": "https://github.com/microsoft/windows-rs/issues/1409",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [],
      "informational": "unsound",
      "aliases": [
        "GHSA-x4mq-m75f-mx8m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.32.0"
      ],
      "unaffected": [
        "< 0.1.2"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "text": "\n\n# Delegate functions are missing `Send` bound\n\nAffected versions of this crate did not require event handlers to have `Send` bound despite there being no guarantee of them being called on any particular thread, which can potentially lead to data races and undefined behavior.\n\nThe flaw was corrected in commit [afe3252](https://github.com/microsoft/windows-rs/commit/afe32525c22209aa8f632a0f4ad607863b51796a) by adding `Send` bounds.\n",
    "likely_poc": [
      "https://github.com/microsoft/windows-rs/issues/1409"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0081",
      "package": "mio",
      "aliases": [
        "CVE-2020-35922",
        "GHSA-pf3p-x6qj-6j7q"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-02",
      "url": "https://github.com/tokio-rs/mio/issues/1386",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.7.6"
      ],
      "unaffected": [
        "< 0.7.0"
      ]
    },
    "text": "\n\n# `mio` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`mio`](https://crates.io/crates/mio) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n",
    "likely_poc": [
      "https://github.com/tokio-rs/mio/issues/1386"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0008",
      "package": "simd-json",
      "aliases": [
        "CVE-2019-15550",
        "GHSA-gwfj-pw2x-h6c2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-06-24",
      "keywords": [
        "simd"
      ],
      "url": "https://github.com/Licenser/simdjson-rs/pull/27"
    },
    "affected": {
      "arch": [
        "x86",
        "x86_64"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.15"
      ],
      "unaffected": [
        "<= 0.1.13"
      ]
    },
    "text": "\n\n# Flaw in string parsing can lead to crashes due to invalid memory access.\n\nThe affected version of this crate did not guard against accessing memory\nbeyond the range of its input data. A pointer cast to read the data into\na 256-bit register could lead to a segmentation fault when the end plus\nthe 32 bytes (256 bit) read would overlap into the next page during string\nparsing.\n\n```\npage   |  ...  page 1  ...  | ... page 2  ... |\ndata   | x[n * 32 byte]xx__ |                 |\naccess | ..][ 32 byte ]     |                 |\nsegflt |               [ 32 | byte ]          |\n```\n\nThis allows an attacker to eventually crash a service.\n\nThe flaw was corrected by using a padding buffer for the last read from the\ninput. So that we are we never read over the boundary of the input data.\n",
    "likely_poc": [
      "https://github.com/Licenser/simdjson-rs/pull/27"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0070",
      "package": "self_cell",
      "date": "2023-11-10",
      "url": "https://github.com/Voultapher/self_cell/issues/49",
      "categories": [],
      "keywords": [
        "unsound",
        "self_cell",
        "self-referential"
      ],
      "aliases": [
        "GHSA-48m6-wm5p-rr6h"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.3, < 1.0.0",
        ">= 1.0.2"
      ]
    },
    "text": "\n\n# Insufficient covariance check makes self_cell unsound\n\nAll public versions prior to `1.02` used an insufficient check to ensure that\nusers correctly marked the dependent type as either `covariant` or\n`not_covariant`. This allowed users to mark a dependent as covariant even though\nits type was not covariant but invariant, for certain invariant types involving\ntrait object lifetimes. One example for such a dependent type is `type\nDependent<'a> = RefCell<Box<dyn fmt::Display + 'a>>`. Such a type allowed\nunsound usage in purely safe user code that leads to undefined behavior. The\npatched versions now produce a compile time error if such a type is marked as\n`covariant`.\n",
    "likely_poc": [
      "https://github.com/Voultapher/self_cell/issues/49"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0084",
      "package": "bronzedb-protocol",
      "date": "2021-01-03",
      "url": "https://github.com/Hexilee/BronzeDB/issues/1",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45682",
        "GHSA-5phc-849h-vcxg",
        "GHSA-jv2r-jx6q-89jg"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Read` on uninitialized buffer can cause UB (impl of `ReadKVExt`)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0120",
      "package": "libsbc",
      "date": "2020-11-10",
      "url": "https://github.com/mvertescher/libsbc-rs/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36440",
        "GHSA-f6g6-54hm-fhxv"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.5"
      ]
    },
    "text": "\n\n# `Decoder<R>` can carry `R: !Send` to other threads\n\nAffected versions of this crate implements `Send` for `Decoder<R>` for any `R: Read`. This allows `Decoder<R>` to contain `R: !Send` and carry (move) it to another thread.\n\nThis can result in undefined behavior such as memory corruption from data race on `R`, or dropping `R = MutexGuard<_>` from a thread that didn't lock the mutex.\n\nThe flaw was corrected in commit a34d6e1 by adding trait bound `R: Send` to the `Send` impl for `Decoder<R>`.\n",
    "likely_poc": [
      "https://github.com/mvertescher/libsbc-rs/issues/4"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0034",
      "package": "http",
      "aliases": [
        "CVE-2019-25009",
        "GHSA-6rhx-hqxm-8p36"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-11-16",
      "keywords": [
        "memory-safety",
        "double-free",
        "unsound"
      ]
    },
    "affected": {
      "functions": {
        "http::header::HeaderMap::drain": [
          "< 0.1.20"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.20"
      ]
    },
    "text": "\n\n# HeaderMap::Drain API is unsound\n\nAffected versions of this crate incorrectly used raw pointer,\nwhich introduced unsoundness in its public safe API.\n\n[Failing to drop the Drain struct causes double-free](https://github.com/hyperium/http/issues/354),\nand [it is possible to violate Rust's alias rule and cause data race with Drain's Iterator implementation](https://github.com/hyperium/http/issues/355).\n\nThe flaw was corrected in 0.1.20 release of `http` crate.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0013",
      "package": "spin",
      "aliases": [
        "CVE-2019-16137",
        "GHSA-hv7x-f3pv-gpwr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-08-27",
      "keywords": [
        "atomic",
        "ordering",
        "spin",
        "lock",
        "mutex",
        "rwlock"
      ],
      "url": "https://github.com/mvdnes/spin-rs/issues/65"
    },
    "affected": {
      "functions": {
        "spin::RwLock::new": [
          "< 0.5.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "text": "\n\n# Wrong memory orderings in RwLock potentially violates mutual exclusion\n\nWrong memory orderings inside the RwLock implementation allow for two writers to acquire the lock at the same time. The drop implementation used Ordering::Relaxed, which allows the compiler or CPU to reorder a mutable access on the locked data after the lock has been yielded.\n\nOnly users of the RwLock implementation are affected. Users of Once (including users of lazy_static with the `spin_no_std` feature enabled) are NOT affected.\n\nOn strongly ordered CPU architectures like x86, the only real way that this would lead to a memory corruption is if the compiler reorders an access after the lock is yielded, which is possible but in practice unlikely. It is a more serious issue on weakly ordered architectures such as ARM which, except in the presence of certain instructions, allow the hardware to decide which accesses are seen at what times. Therefore on an ARM system it is likely that using the wrong memory ordering would result in a memory corruption, even if the compiler itself doesn't reorder the memory accesses in a buggy way.\n\nThe flaw was corrected by https://github.com/mvdnes/spin-rs/pull/66.\n",
    "likely_poc": [
      "https://github.com/mvdnes/spin-rs/issues/65"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0031",
      "package": "spin",
      "date": "2023-03-31",
      "informational": "unsound",
      "url": "https://github.com/mvdnes/spin-rs/issues/148",
      "aliases": [
        "GHSA-2qv5-7mw5-j3cg"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.8"
      ],
      "unaffected": [
        "< 0.9.3"
      ]
    },
    "text": "\n\n# Initialisation failure in `Once::try_call_once` can lead to undefined behaviour for other initialisers\n\n`Once::try_call_once` is unsound if invoked more than once concurrently and any call fails to initialise successfully.\n",
    "likely_poc": [
      "https://github.com/mvdnes/spin-rs/issues/148"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0005",
      "package": "glsl-layout",
      "aliases": [
        "CVE-2021-25902",
        "GHSA-cx4j-fxr7-jxg8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-10",
      "url": "https://github.com/rustgd/glsl-layout/pull/10",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Double drop upon panic in 'fn map_array()'\n\nAffected versions of this crate did not guard against panic within the user-provided function `f` (2nd parameter of `fn map_array`), and thus panic within `f` \ncauses double drop of a single object.\n\nThe flaw was corrected in the 0.4.0 release by wrapping the object vulnerable\nto a double drop within `ManuallyDrop<T>`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0165",
      "package": "mozjpeg",
      "date": "2020-07-04",
      "keywords": [
        "type confusion"
      ],
      "url": "https://github.com/ImageOptim/mozjpeg-rust/issues/10",
      "categories": [
        "memory-corruption"
      ],
      "references": [
        "https://github.com/kornelski/rust-rgb/issues/35",
        "https://rustsec.org/advisories/RUSTSEC-2020-0029.html"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-v8gq-5grq-9728"
      ]
    },
    "affected": {
      "functions": {
        "mozjpeg::DecompressScanlines::read_scanlines": [
          "< 0.8.19"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.8.19"
      ]
    },
    "text": "\n\n# mozjpeg DecompressScanlines::read_scanlines is Unsound\n\nThis issue and vector is similar to [RUSTSEC-2020-0029] of `rgb` crate which `mozjpeg` depends on.\n\nAffected versions of `mozjpeg` crate allow creating instances of any type `T` from bytes,\nand do not correctly constrain `T` to the types for which it is safe to do so.\n\nExamples of safety violation possible for a type `T`:\n\n* `T` contains a reference type, and it constructs a pointer to an invalid, arbitrary memory address.\n* `T` requires a safety and/or validity invariant for its construction that may be violated.\n\nThe issue was fixed in 0.8.19 by using safer types and involving `rgb` dependency bump.\n\n[RUSTSEC-2020-0029]: https://rustsec.org/advisories/RUSTSEC-2020-0029.html\n",
    "likely_poc": [
      "https://github.com/ImageOptim/mozjpeg-rust/issues/10",
      "https://github.com/kornelski/rust-rgb/issues/35"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0145",
      "package": "heapless",
      "date": "2020-11-02",
      "url": "https://github.com/japaric/heapless/issues/181",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36464",
        "GHSA-qgwf-r2jj-2ccv"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "affected": {
      "functions": {
        "heapless::vec::IntoIter::clone": [
          "<= 0.6"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Use-after-free when cloning a partially consumed `Vec` iterator\n\nThe `IntoIter` `Clone` implementation clones the whole underlying `Vec`.\nIf the iterator is partially consumed the consumed items will be copied, thus creating a use-after-free access.\n\nA proof of concept is available in the original bug report.\n",
    "likely_poc": [
      "https://github.com/japaric/heapless/issues/181"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0039",
      "package": "simple-slab",
      "aliases": [
        "CVE-2020-35892",
        "CVE-2020-35893",
        "GHSA-438g-fx34-4h9m",
        "GHSA-hqc8-j86x-2764"
      ],
      "date": "2020-09-03",
      "url": "https://github.com/nathansizemore/simple-slab/issues/2"
    },
    "versions": {
      "patched": [
        ">= 0.3.3"
      ]
    },
    "text": "\n\n# `index()` allows out-of-bound read and `remove()` has off-by-one error\n\n`Slab::index()` does not perform the boundary checking, which leads to out-of-bound read access. `Slab::remove()` copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.\n",
    "likely_poc": [
      "https://github.com/nathansizemore/simple-slab/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0135",
      "package": "slock",
      "date": "2020-11-17",
      "url": "https://github.com/BrokenLamp/slock-rs/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36455",
        "GHSA-83r8-p8v6-6gfm",
        "GHSA-mc36-5m36-hjh5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Slock<T> allows sending non-Send types across thread boundaries\n\n`Slock<T>` unconditionally implements `Send`/`Sync`.\n\nAffected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.\n",
    "likely_poc": [
      "https://github.com/BrokenLamp/slock-rs/issues/2"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0009",
      "package": "flatbuffers",
      "aliases": [
        "CVE-2020-35864",
        "GHSA-c9h5-hf8r-m97x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-04-11",
      "url": "https://github.com/google/flatbuffers/issues/5825"
    },
    "affected": {
      "functions": {
        "flatbuffers::read_scalar": [
          ">= 0.4.0"
        ],
        "flatbuffers::read_scalar_at": [
          ">= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# `read_scalar` and `read_scalar_at` allow transmuting values without `unsafe` blocks\n\nThe `read_scalar` and `read_scalar_at` functions are unsound\nbecause they allow transmuting values without `unsafe` blocks.\n\nThe following example shows how to create a dangling reference:\n\n```\nfn main() {\n    #[derive(Copy, Clone, PartialEq, Debug)]\n    struct S(&'static str);\n    impl flatbuffers::EndianScalar for S {\n        fn to_little_endian(self) -> Self { self }\n        fn from_little_endian(self) -> Self { self }\n    }\n    println!(\"{:?}\", flatbuffers::read_scalar::<S>(&[1; std::mem::size_of::<S>()]));\n}\n```\n",
    "likely_poc": [
      "https://github.com/google/flatbuffers/issues/5825"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0028",
      "package": "flatbuffers",
      "aliases": [
        "CVE-2019-25004",
        "GHSA-gx73-2498-r55c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-10-20",
      "url": "https://github.com/google/flatbuffers/issues/5530"
    },
    "affected": {
      "functions": {
        "flatbuffers::Follow::follow": [
          ">= 0.4.0",
          "<= 0.6.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Unsound `impl Follow for bool`\n\nThe implementation of `impl Follow for bool` allows to reinterpret arbitrary bytes as a `bool`.\n\nIn Rust `bool` has stringent requirements for its in-memory representation. Use of this function\nallows to violate these requirements and invoke undefined behaviour in safe code.\n",
    "likely_poc": [
      "https://github.com/google/flatbuffers/issues/5530"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0045",
      "package": "actix-utils",
      "aliases": [
        "CVE-2020-35898",
        "GHSA-hhw2-pqhf-vmx2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-08",
      "informational": "unsound",
      "url": "https://github.com/actix/actix-net/issues/160"
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# bespoke Cell implementation allows obtaining several mutable references to the same data\n\nThe custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.\n",
    "likely_poc": [
      "https://github.com/actix/actix-net/issues/160"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0095",
      "package": "mopa",
      "date": "2021-06-01",
      "url": "https://github.com/chris-morgan/mopa/issues/13",
      "categories": [
        "memory-corruption",
        "memory-exposure",
        "code-execution"
      ],
      "keywords": [
        "transmute",
        "dyn"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45695",
        "GHSA-2gxj-qrp2-53jv",
        "GHSA-8mv5-7x95-7wcf"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `mopa` is technically unsound\nThe `mopa` crate redefines the deprecated `TraitObject` struct from `core::raw` like so:\n```rust\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n```\nThis is done to then transmute a reference to a trait object (`&dyn Trait` for any trait `Trait`) into this struct and retrieve the `data` field for the purpose of downcasting. This is used to implement `downcast_ref_unchecked()`, in terms of which `downcast_ref()` is also implemented. Same goes for mutable reference downcasting and `Box` downcasting.\n\nThe Rust compiler explicitly reserves the right to change the memory layout of `&dyn Trait` for any trait `Trait`. The worst case scenario is that it swaps `data` and `vtable`, making an executable location breach and compromisation of ASLR possible, since reads from `data` would read `vtable` instead. Likewise, arbitrary code execution is also theoretically possible if reads of `vtable` generated by the compiler read `data` instead.\n\nWhile, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.\n\nA potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.\n",
    "likely_poc": [
      "https://github.com/chris-morgan/mopa/issues/13"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0044",
      "package": "rocket",
      "aliases": [
        "CVE-2021-29935",
        "GHSA-vcw4-8ph6-7vw8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-09",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1534",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "use-after-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.7"
      ]
    },
    "text": "\n\n# Use after free possible in `uri::Formatter` on panic\n\nAffected versions of this crate transmuted a `&str` to a `&'static str` before\npushing it into a `StackVec`, this value was then popped later in the same\nfunction.\n\nThis was assumed to be safe because the reference would be valid while the\nmethod's stack was active. In between the push and the pop, however, a function\n`f` was called that could invoke a user provided function.\n\nIf the user provided panicked, then the assumption used by the function was no\nlonger true and the transmute to `&'static` would create an illegal static\nreference to the string. This could result in a freed string being used during\n(such as in a `Drop` implementation) or after (e.g through `catch_unwind`) the\npanic unwinding.\n\nThis flaw was corrected in commit [e325e2f](https://github.com/SergioBenitez/Rocket/commit/e325e2fce4d9f9f392761e9fb58b418a48cef8bb)\nby using a guard object to ensure that the `&'static str` was dropped inside\nthe function.\n",
    "likely_poc": [
      "https://github.com/SergioBenitez/Rocket/issues/1534"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0028",
      "package": "rocket",
      "aliases": [
        "CVE-2020-35882",
        "GHSA-8q2v-67v7-6vc6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-05-27",
      "informational": "unsound",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1312"
    },
    "affected": {
      "functions": {
        "rocket::local::LocalRequest::clone": [
          "< 0.4.5, >= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.5"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# `LocalRequest::clone` creates multiple mutable references to the same object\n\nThe affected version of `rocket` contains a `Clone` trait implementation of\n`LocalRequest` that reuses the pointer to inner `Request` object.\nThis causes data race in rare combinations of APIs if the original and the\ncloned objects are modified at the same time.\n",
    "likely_poc": [
      "https://github.com/SergioBenitez/Rocket/issues/1312"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0112",
      "package": "tectonic_xdv",
      "date": "2021-02-17",
      "url": "https://github.com/tectonic-typesetting/tectonic/issues/752",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45703",
        "GHSA-6692-8qqf-79jc",
        "GHSA-qwvx-c8j7-5g75"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.12"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB ('tectonic_xdv' crate)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe problem was fixed in commit `cdff034` by zero-initializing the buffer before passing it to a user-provided `Read` implementation.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0136",
      "package": "toolshed",
      "date": "2020-11-15",
      "url": "https://github.com/ratel-rust/toolshed/issues/12",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36456",
        "GHSA-2r6q-6c8c-g762"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# CopyCell lacks bounds on its Send trait allowing for data races\n\n`CopyCell<T>` is a `Cell`-like type that is implemented for any type `T` that\nis `Copy`able. It's `Send` trait has no bounds on the contained type.\n\nAs not all `Copy`able types are thread safe, for example non-mutable references\nimplement the `Copy` trait, it is possible to send references to types with\ninterior mutability such as `Cell` across threads and cause data races.\n",
    "likely_poc": [
      "https://github.com/ratel-rust/toolshed/issues/12"
    ]
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0017",
      "package": "postscript",
      "aliases": [
        "CVE-2021-26953",
        "GHSA-fhvc-gp6c-h2wx"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-30",
      "url": "https://github.com/bodoni/postscript/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.14.0"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB (`impl Walue for Vec<u8>`)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 8026286 by zero-initializing the buffer before handing to a user-provided `Read`.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0011",
      "package": "arrayfire",
      "aliases": [
        "CVE-2018-20998",
        "GHSA-69fv-gw6g-8ccg"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2018-12-18",
      "keywords": [
        "enum",
        "repr"
      ],
      "url": "https://github.com/arrayfire/arrayfire-rust/pull/177"
    },
    "affected": {
      "arch": [
        "x86_64"
      ],
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.6.0"
      ],
      "unaffected": [
        "<= 3.5.0"
      ]
    },
    "text": "\n\n# Enum repr causing potential memory corruption\n\nThe attribute repr() added to enums to be compatible with C-FFI caused\nmemory corruption on MSVC toolchain.\n\narrayfire crates <= version 3.5.0 do not have this issue when used with\nRust versions 1.27 or earlier. The issue only started to appear since\nRust version 1.28.\n\nThe issue seems to be interlinked with which version of Rust is being used.\n\nThe issue was fixed in crate 3.6.0.\n",
    "likely_poc": []
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0017",
      "package": "maligned",
      "date": "2023-03-04",
      "url": "https://github.com/tylerhawkes/maligned/issues/5",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "unsound",
        "alloc",
        "align"
      ],
      "aliases": [
        "GHSA-wm8x-php5-hvq6"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "maligned::align_first": [
          "*"
        ],
        "maligned::align_first_boxed": [
          "*"
        ],
        "maligned::align_first_boxed_cloned": [
          "*"
        ],
        "maligned::align_first_boxed_default": [
          "*"
        ]
      }
    },
    "text": "\n\n# `maligned::align_first` causes incorrect deallocation\n\n`maligned::align_first` manually allocates with an alignment larger than T, and then uses `Vec::from_raw_parts` on that allocation to get a `Vec<T>`.\n\n[`GlobalAlloc::dealloc`](https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc) requires that the `layout` argument must be the same layout that was used to allocate that block of memory.\n\nWhen deallocating, `Box` and `Vec` may not respect the specified alignment and can cause undefined behavior.\n",
    "likely_poc": [
      "https://github.com/tylerhawkes/maligned/issues/5"
    ]
  }
]