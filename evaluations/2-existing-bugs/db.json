[
  {
    "advisory": {
      "id": "RUSTSEC-2020-0089",
      "package": "nanorand",
      "aliases": [
        "CVE-2020-35926",
        "GHSA-m9m5-cg5h-r582"
      ],
      "date": "2020-12-09",
      "url": "https://twitter.com/aspenluxxxy/status/1336684692284772352",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
      "keywords": [
        "rng"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.1"
      ]
    },
    "text": "\n\n# nanorand 0.5.0 - RNGs failed to generate properly for non-64-bit numbers\n\nIn versions of `nanorand` prior to 0.5.1, `RandomGen` implementations for standard unsigned integers could\nfail to properly generate numbers, due to using bit-shifting to truncate a 64-bit number, rather than just\nan `as` conversion.\n\nThis often manifested as RNGs returning nothing but 0, including the cryptographically secure `ChaCha` random\nnumber generator..\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0114",
      "package": "nanorand",
      "date": "2021-09-23",
      "url": "https://github.com/Absolucy/nanorand-rs/issues/28",
      "keywords": [
        "memory-safety",
        "aliasing"
      ],
      "aliases": [
        "CVE-2021-45705",
        "GHSA-p6gj-gpc8-f8xw",
        "GHSA-r57r-j98g-587f"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "affected": {
      "functions": {
        "nanorand::tls::tls_rand": [
          ">= 0.5.0",
          "<= 0.6.0"
        ]
      }
    },
    "text": "\n\n# Aliased mutable references from `tls_rand` & `TlsWyRand`\n\n`TlsWyRand`'s implementation of `Deref` unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0129",
      "package": "kekbit",
      "date": "2020-12-18",
      "url": "https://github.com/motoras/kekbit/issues/34",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36449",
        "GHSA-g83m-67wh-whpw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.4"
      ]
    },
    "text": "\n\n# ShmWriter allows sending non-Send type across threads\n\nAffected versions of this crate implement `Send` for `ShmWriter<H>` without requiring `H: Send`. This allows users to send `H: !Send` to other threads, which can potentially lead to data races and undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0014",
      "package": "marc",
      "aliases": [
        "CVE-2021-26308",
        "GHSA-3mf3-2gv9-h39j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-26",
      "url": "https://github.com/blackbeam/rust-marc/issues/7",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# Record::read : Custom `Read` on uninitialized buffer may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. (`Record::read()`)\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 6299af0 by zero-initializing the newly allocated memory (via `data.resize(len, 0)`) instead of exposing uninitialized memory (`unsafe { data.set_len(len) }`).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0133",
      "package": "scottqueue",
      "date": "2020-11-15",
      "url": "https://github.com/rossdylan/rust-scottqueue/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36453",
        "GHSA-gvvv-w559-2hg6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Queue<T> should have a Send bound on its Send/Sync traits\n\nAffected versions of this crate unconditionally implements `Send`/`Sync` for `Queue<T>`.\n\nThis allows (1) creating data races to a `T: !Sync` and (2) sending `T: !Send` to other threads, resulting in memory corruption or other undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0113",
      "package": "metrics-util",
      "date": "2021-04-07",
      "url": "https://github.com/metrics-rs/metrics/issues/190",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2021-45704",
        "GHSA-3hxh-7jxm-59x4",
        "GHSA-cwvc-87xq-pc5m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# AtomicBucket<T> unconditionally implements Send/Sync\n\nIn the affected versions of the crate, `AtomicBucket<T>` unconditionally implements `Send`/`Sync` traits. Therefore, users can create a data race to the inner\n`T: !Sync` by using the `AtomicBucket::data_with()` API.\nSuch data races can potentially cause memory corruption or other undefined behavior.\n\nThe flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct `Block<T>` (which is a data type contained inside `AtomicBucket<T>`).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0320",
      "package": "yaml-rust",
      "date": "2024-03-20",
      "informational": "unmaintained",
      "url": "https://github.com/rustsec/advisory-db/issues/1921"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# yaml-rust is unmaintained.\n\nThe maintainer seems [unreachable](https://github.com/chyh1990/yaml-rust/issues/197).\n\nMany issues and pull requests have been submitted over the years\nwithout any [response](https://github.com/chyh1990/yaml-rust/issues/160).\n\n## Alternatives\n\nConsider switching to the actively maintained `yaml-rust2` fork of the original project:\n\n- [yaml-rust2](https://github.com/Ethiraric/yaml-rust2)\n- [yaml-rust2 @ crates.io](https://crates.io/crates/yaml-rust2))\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0006",
      "package": "yaml-rust",
      "aliases": [
        "CVE-2018-20993",
        "GHSA-hv87-47h9-jcvq"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2018-09-17",
      "keywords": [
        "crash"
      ],
      "url": "https://github.com/chyh1990/yaml-rust/pull/109"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# Uncontrolled recursion leads to abort in deserialization\n\nAffected versions of this crate did not prevent deep recursion while\ndeserializing data structures.\n\nThis allows an attacker to make a YAML file with deeply nested structures\nthat causes an abort while deserializing it.\n\nThe flaw was corrected by checking the recursion depth.\n\nNote: `clap 2.33` is not affected by this because it uses `yaml-rust`\nin a way that doesn't trigger the vulnerability. More specifically:\n\n1. The input to the YAML parser is always trusted - is included at compile\ntime via `include_str!`.\n\n2. The nesting level is never deep enough to trigger the overflow in practice\n(at most 5).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0134",
      "package": "parc",
      "date": "2020-11-14",
      "url": "https://github.com/hyyking/rustracts/pull/6",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36454",
        "GHSA-29v7-3v4c-gf38",
        "GHSA-xwxc-j97j-84gf"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `LockWeak<T>` allows to create data race to `T`.\n\nIn the affected versions of this crate, `LockWeak<T>` unconditionally implemented `Send` with no trait bounds on `T`. `LockWeak<T>` doesn't own `T` and only provides `&T`.\n\nThis allows concurrent access to a non-Sync `T`, which can cause undefined behavior like data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0154",
      "package": "buffoon",
      "date": "2020-12-31",
      "url": "https://github.com/carllerche/buffoon/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36512",
        "GHSA-hmx9-jm3v-33hv",
        "GHSA-v938-qcc9-rwv8"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# InputStream::read_exact : `Read` on uninitialized buffer causes UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0081",
      "package": "actix-http",
      "date": "2021-06-16",
      "keywords": [
        "smuggling",
        "http",
        "reverse proxy",
        "request smuggling"
      ],
      "aliases": [
        "CVE-2021-38512",
        "GHSA-8928-2fgm-6x9x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
    },
    "versions": {
      "patched": [
        "^ 2.2.1",
        ">= 3.0.0-beta.9"
      ]
    },
    "text": "\n\n# Potential request smuggling capabilities due to lack of input validation\n\nAffected versions of this crate did not properly detect invalid requests that could allow HTTP/1 request smuggling (HRS) attacks when running alongside a vulnerable front-end proxy server. This can result in leaked internal and/or user data, including credentials, when the front-end proxy is also vulnerable.\n\nPopular front-end proxies and load balancers already mitigate HRS attacks so it is recommended that they are also kept up to date; check your specific set up. You should upgrade even if the front-end proxy receives exclusively HTTP/2 traffic and connects to the back-end using HTTP/1; several downgrade attacks are known that can also expose HRS vulnerabilities.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0048",
      "package": "actix-http",
      "aliases": [
        "CVE-2020-35901",
        "GHSA-v3j6-xf77-8r9c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-24",
      "url": "https://github.com/actix/actix-web/issues/1321"
    },
    "versions": {
      "patched": [
        ">= 2.0.0-alpha.1"
      ]
    },
    "text": "\n\n# Use-after-free in BodyStream due to lack of pinning\n\nAffected versions of this crate did not require the buffer wrapped in `BodyStream` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the trait `MessageBody` require `Unpin`\nand making `poll_next()` function accept `Pin<&mut Self>` instead of `&mut self`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0141",
      "package": "dotenv",
      "date": "2021-12-24",
      "url": "https://github.com/dotenv-rs/dotenv/issues/74",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# dotenv is Unmaintained\n\ndotenv by description is meant to be used in development or testing only.\n\nUsing this in production may or may not be advisable.\n\n## Alternatives\n\nThe below may or may not be feasible alternative(s):\n- [dotenvy](https://crates.io/crates/dotenvy)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0015",
      "package": "calamine",
      "aliases": [
        "CVE-2021-26951",
        "GHSA-ppqp-78xx-3r38"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-06",
      "url": "https://github.com/tafia/calamine/issues/199",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.17.0"
      ]
    },
    "text": "\n\n# `Sectors::get` accesses unclaimed/uninitialized memory\n\nAffected versions of this crate arbitrarily calls `Vec::set_len` to increase length of a vector without claiming more memory for the vector. Affected versions of this crate\nalso calls user-provided `Read` on the uninitialized memory of the vector that was\nextended with `Vec::set_len`.\n\nThis can overwrite active entities in adjacent heap memory and seems to be a major security issue. Also, calling user-provided `Read` on uninitialized memory is defined as UB in Rust.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0336",
      "package": "rustls",
      "date": "2024-04-19",
      "url": "https://github.com/rustls/rustls/security/advisories/GHSA-6g7w-8wpp-frhj",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2024-32650",
        "GHSA-6g7w-8wpp-frhj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.23.5",
        ">= 0.22.4, < 0.23.0",
        ">= 0.21.11, < 0.22.0"
      ]
    },
    "affected": {
      "functions": {
        "rustls::ConnectionCommon::complete_io": [
          "<= 0.23.4",
          "<= 0.22.3",
          "<= 0.21.10",
          "0.20"
        ]
      }
    },
    "text": "\n\n# `rustls::ConnectionCommon::complete_io` could fall into an infinite loop based on network input\n\nIf a `close_notify` alert is received during a handshake, `complete_io`\ndoes not terminate.\n\nCallers which do not call `complete_io` are not affected.\n\n`rustls-tokio` and `rustls-ffi` do not call `complete_io`\nand are not affected.\n\n`rustls::Stream` and `rustls::StreamOwned` types use\n`complete_io` and are affected.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0131",
      "package": "brotli-sys",
      "date": "2021-12-20",
      "url": "https://github.com/bitemyapp/brotli2-rs/issues/45",
      "references": [
        "https://github.com/google/brotli/releases/tag/v1.0.9"
      ],
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "CVE-2020-8927"
      ]
    },
    "affected": {},
    "versions": {
      "patched": []
    },
    "text": "\n# Integer overflow in the bundled Brotli C library\n\nA buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nAn updated version of `brotli-sys` has not been released. If one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.\n\nIn Rust the issue can be mitigated by migrating to the `brotli` crate, which provides a Rust implementation of Brotli compression and decompression that is not affected by this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0085",
      "package": "matrix-sdk-crypto",
      "date": "2022-09-29",
      "url": "https://github.com/matrix-org/matrix-rust-sdk/commit/093fb5d0aa21c0b5eaea6ec96b477f1075271cbb",
      "references": [
        "https://github.com/matrix-org/matrix-rust-sdk/commit/41449d2cc360e347f5d4e1c154ec1e3185f11acd"
      ],
      "aliases": [
        "CVE-2022-39252",
        "GHSA-vp68-2wrm-69qm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.6.0"
      ]
    },
    "text": "\n\n# matrix-sdk Impersonation of room keys\n\nWhen the user receives a forwarded room key, the software accepts it without\nchecking who the room key came from. This allows homeservers to try to insert\nroom keys of questionable validity, potentially mounting an impersonation attack.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0356",
      "package": "matrix-sdk-crypto",
      "date": "2024-07-18",
      "url": "https://github.com/matrix-org/matrix-rust-sdk/security/advisories/GHSA-4qg4-cvh2-crgg",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "CVE-2024-40648",
        "GHSA-4qg4-cvh2-crgg"
      ]
    },
    "affected": {
      "functions": {
        "matrix_sdk_crypto::UserIdentity::is_verified": [
          "< 0.7.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.7.2"
      ]
    },
    "text": "\n# `UserIdentity::is_verified` not checking verification status of own user identity while performing the check \n\nThe `UserIdentity::is_verified()` method in the matrix-sdk-crypto crate before\nversion 0.7.2 doesn't take into account the verification status of the user's\nown identity while performing the check and may as a result return a value\ncontrary to what is implied by its name and documentation.\n\n## Impact\n\nIf the method is used to decide whether to perform sensitive operations towards\na user identity, a malicious homeserver could manipulate the outcome in order to\nmake the identity appear trusted. This is not a typical usage of the method,\nwhich lowers the impact. The method itself is not used inside the\nmatrix-sdk-crypto crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0043",
      "package": "tower-http",
      "date": "2022-01-21",
      "url": "https://github.com/tower-rs/tower-http/pull/204",
      "categories": [
        "file-disclosure"
      ],
      "keywords": [
        "directory traversal",
        "http"
      ],
      "aliases": [
        "GHSA-qrqq-9c63-xfrg"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1",
        ">= 0.1.3, < 0.2.0"
      ]
    },
    "text": "\n\n# Improper validation of Windows paths could lead to directory traversal attack\n\n`tower_http::services::fs::ServeDir` didn't correctly validate Windows paths\nmeaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed\nand respond with the contents of `c:/windows/web/screen/img101.png`. Thus users\ncould potentially read files anywhere on the filesystem.\n\nThis only impacts Windows. Linux and other unix likes are not impacted by this.\n\nSee [tower-http#204] for more details.\n\n[tower-http#204]: https://github.com/tower-rs/tower-http/pull/204\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0135",
      "package": "tower-http",
      "date": "2021-01-21",
      "url": "https://github.com/tower-rs/tower-http/pull/204",
      "categories": [
        "file-disclosure"
      ],
      "keywords": [
        "directory traversal",
        "http"
      ],
      "withdrawn": "2022-08-14",
      "aliases": [
        "GHSA-wwh2-r387-g5rm"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1",
        ">= 0.1.3, < 0.2.0"
      ]
    },
    "text": "\n\n# Improper validation of Windows paths could lead to directory traversal attack\n\n`tower_http::services::fs::ServeDir` didn't correctly validate Windows paths\nmeaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed\nand respond with the contents of `c:/windows/web/screen/img101.png`. Thus users\ncould potentially read files anywhere on the filesystem.\n\nThis only impacts Windows. Linux and other unix likes are not impacted by this.\n\nSee [tower-http#204] for more details.\n\n[tower-http#204]: https://github.com/tower-rs/tower-http/pull/204\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0025",
      "package": "git-hash",
      "date": "2023-03-14",
      "url": "https://github.com/Byron/gitoxide/pull/741",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Gitoxide has renamed its crates.\n\nAll crates in the gitoxide project have been renamed from git-<crate> to\ngix-<crate>. The git- prefixed crates are no longer being updated. Switch\nto using gix-hash to continue receiving updates.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0119",
      "package": "nix",
      "date": "2021-09-27",
      "url": "https://github.com/nix-rust/nix/issues/1541",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "nss"
      ],
      "aliases": [
        "CVE-2021-45707",
        "GHSA-76w9-p8mg-j927",
        "GHSA-wgrg-5h56-jg27"
      ]
    },
    "versions": {
      "patched": [
        "^0.20.2",
        "^0.21.2",
        "^0.22.2",
        ">= 0.23.0"
      ],
      "unaffected": [
        "< 0.16.0"
      ]
    },
    "affected": {
      "os": [
        "linux",
        "freebsd",
        "android",
        "netbsd",
        "dragonfly",
        "openbsd",
        "fuchsia"
      ],
      "functions": {
        "nix::unistd::getgrouplist": [
          ">= 0.16.0"
        ]
      }
    },
    "text": "\n\n# Out-of-bounds write in nix::unistd::getgrouplist\n\nOn certain platforms, if a user has more than 16 groups, the\n`nix::unistd::getgrouplist` function will call the libc `getgrouplist`\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.\n\nThe libc `getgrouplist` function takes an in/out parameter `ngroups`\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the requested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify `ngroups`\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of `nix::unistd::getgrouplist` in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the `ngroups` variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n`getgrouplist` will then write past the end of the buffer.\n\nThe issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0151",
      "package": "ncollide2d",
      "date": "2021-01-29",
      "url": "https://github.com/dimforge/ncollide",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# ncollide2d is unmaintained\n\nThe maintainer has advised that this crate is passively-maintained and that it\nis being superseded by the [Parry](https://github.com/dimforge/parry) project.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0087",
      "package": "columnar",
      "date": "2021-01-07",
      "url": "https://github.com/frankmcsherry/columnar/issues/6",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45685",
        "GHSA-9mp7-45qh-r8j8",
        "GHSA-cxcc-q839-2cw9"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# columnar: `Read` on uninitialized buffer may cause UB (ColumnarReadExt::read_typed_vec())\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (`ColumnarReadExt::read_typed_vec()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0029",
      "package": "chacha20",
      "aliases": [
        "CVE-2019-25005",
        "GHSA-j2r6-2m5c-vgh5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "categories": [
        "crypto-failure"
      ],
      "date": "2019-10-22",
      "url": "https://github.com/RustCrypto/stream-ciphers/pull/64"
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "text": "\n\n# ChaCha20 counter overflow can expose repetitions in the keystream\n\nThe ChaCha20 stream cipher can produce a maximum of 2^32 blocks (~256GB)\nbefore the 32-bit counter overflows. Releases of the `chacha20` crate prior\nto v0.2.3 allow generating keystreams larger than this, including seeking\npast the limit. When this occurs, the keystream is duplicated, with failure\nmodes similar to nonce reuse (i.e. exposure of the XOR of two plaintexts).\n\nThe v0.2.3 release now panics in this event, rather than exposing the\nduplicated keystream. Note this is a \"hot fix\" solution to the problem\nand future releases will pursue returning an error in this case.\n\nUsers of the `chacha20poly1305` crate are unaffected by this as this crate\nproperly asserts the length of the plaintext is less than the maximum allowed\n(`P_MAX` as described in RFC 8439 Section 2.8).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0114",
      "package": "va-ts",
      "aliases": [
        "CVE-2020-36220",
        "GHSA-3hj2-hh36-hv9v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-22",
      "url": "https://github.com/video-audio/va-ts/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.0.4"
      ]
    },
    "text": "\n\n# `Demuxer` can carry non-Send types across thread boundaries\n\nIn the affected versions of this crate, `Demuxer<T>` unconditionally implemented `Send` with no trait bounds on `T`.\n\nThis allows sending a non-Send type `T` across thread boundaries, which can cause undefined behavior like unlocking a mutex from a thread that didn't lock the mutex, or memory corruption from data race.\n\nThe flaw was corrected in commit 0562cbf by adding a `T: Send` bound to the `Send` impl for `Demuxer<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0092",
      "package": "concread",
      "aliases": [
        "CVE-2020-35928",
        "GHSA-4xj5-vv9x-63jp"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-13",
      "url": "https://github.com/kanidm/concread/issues/48",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.2.6"
      ]
    },
    "text": "\n\n# Send/Sync bound needed on V in `impl Send/Sync for ARCache<K, V>`\n\nAffected versions of this crate unconditionally implemented `Send`/`Sync` traits for `ARCache<K, V>` type.\n\nThis allows users to send/access types that do not implement `Send`/`Sync`, which can cause a data race.\n\nThe flaw was corrected in the 0.2.6 release by adding bounds `K: Send + Sync` & `V: Send + Sync` to affected `Send`/`Sync` trait implementations.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0090",
      "package": "ash",
      "date": "2021-01-07",
      "url": "https://github.com/MaikKlein/ash/issues/354",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45688",
        "GHSA-64wv-8vwp-xgw2",
        "GHSA-qj69-c89v-jwq2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.33.1"
      ]
    },
    "text": "\n\n# Reading on uninitialized memory may cause UB ( `util::read_spv()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0123",
      "package": "fruity",
      "aliases": [
        "CVE-2021-43620",
        "GHSA-h352-g5vw-3926"
      ],
      "date": "2021-11-14",
      "url": "https://github.com/nvzqz/fruity/issues/14"
    },
    "affected": {
      "functions": {
        "fruity::foundation::NSString::to_str": [
          "< 0.3.0, >= 0.1.0"
        ],
        "fruity::foundation::NSString::to_str_with_nul": [
          "< 0.3.0, >= 0.1.0"
        ],
        "fruity::foundation::NSString::to_string": [
          "< 0.3.0, >= 0.1.0"
        ],
        "fruity::foundation::NSString::to_string_with_nul": [
          "< 0.3.0, >= 0.1.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ],
      "unaffected": [
        "< 0.1.0"
      ]
    },
    "text": "\n\n# Converting `NSString` to a String Truncates at Null Bytes\n\nMethods of [`NSString`] for conversion to a string may return a partial result.\nSince they call [`CStr::from_ptr`] on a pointer to the string buffer, the\nstring is terminated at the first null byte, which might not be the end of the\nstring.\n\nIn addition to the vulnerable functions listed for this issue, the\nimplementations of [`Display`], [`PartialEq`], [`PartialOrd`], and [`ToString`]\nfor [`NSString`] are also affected, since they call those functions.\n\n## Impact\n\nSince [`NSString`] is commonly used as the type for paths by the [Foundation]\nframework, null byte truncation might allow for easily bypassing file extension\nchecks. For example, if a file name is provided by a user and validated to have\none of a specific set of extensions, with validation taking place before\ntruncation, an attacker can add an accepted extension after a null byte (e.g.,\n`file.exe\\0.txt`). After truncation, the file name used by the application\nwould be `file.exe`.\n\nIt would be better to generate unique names for files, instead of using\nuser-provided names, but not all applications take this approach.\n\n## Example:\n\n```rust\nlet string = NSString::from_str(\"null\\0byte\");\nprintln!(\"{}\", string);\n```\n\nThat example only prints the string \"null\".\n\n[`CStr::from_ptr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr\n[`Display`]: https://doc.rust-lang.org/std/fmt/trait.Display.html\n[Foundation]: https://developer.apple.com/documentation/foundation\n[`NSString`]: https://docs.rs/fruity/0.2.0/fruity/foundation/struct.NSString.html\n[`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n[`PartialOrd`]: https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\n[`ToString`]: https://doc.rust-lang.org/std/string/trait.ToString.html\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0004",
      "package": "bzip2",
      "aliases": [
        "CVE-2023-22895",
        "GHSA-96jv-r488-c2rj"
      ],
      "date": "2023-01-09",
      "url": "https://github.com/alexcrichton/bzip2-rs/pull/86",
      "categories": [
        "denial-of-service"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.4"
      ]
    },
    "text": "\n\n# bzip2 Denial of Service (DoS)\n\nWorking with specific payloads can cause a Denial of Service (DoS) vector.\n\nBoth `Decompress` and `Compress` implementations can enter into infinite loops\ngiven specific payloads entered that trigger it.\n\nThe issue is described in great detail in the [bzip2 repository issue](https://github.com/alexcrichton/bzip2-rs/pull/86).\n\nThanks to bjrjk for finding and providing the patch for the issue and the\nmaintainer responsibly responding to release a fix quickly.\n\nUsers who use the crate with untrusted data should update the `bzip2` to 0.4.4.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0121",
      "package": "abox",
      "date": "2020-11-10",
      "url": "https://github.com/SonicFrog/abox/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36441",
        "GHSA-r626-fc64-3q28"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# AtomicBox<T> implements Send/Sync for any `T: Sized`\n\nAffected versions of this crate implements `Send`/`Sync` for `AtomicBox<T>` without requiring `T: Send`/`T: Sync`. This allows to create data races to `T: !Sync` and send `T: !Send` to another thread.\n\nSuch behavior breaks the compile-time thread safety guarantees of Rust, and allows users to incur undefined behavior using safe Rust (e.g. memory corruption from data race).\n\nThe flaw was corrected in commit 34c2b9e by adding trait bound `T: Send` to `Send` impl for `AtomicBox<T>` and trait bound `T: Sync` to `Sync` impl for `AtomicBox<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0142",
      "package": "dotenv_codegen",
      "date": "2021-12-24",
      "url": "https://github.com/dotenv-rs/dotenv/issues/74",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# dotenv is Unmaintained\n\ndotenv by description is meant to be used in development or testing only.\n\nUsing this in production may or may not be advisable.\n\n## Alternatives\n\nThe below may or may not be feasible alternative(s):\n- [dotenvy_codegen_impl](https://crates.io/crates/dotenvy_codegen_impl)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0071",
      "package": "time",
      "date": "2020-11-18",
      "url": "https://github.com/time-rs/time/issues/293",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "keywords": [
        "segfault"
      ],
      "aliases": [
        "CVE-2020-26235",
        "GHSA-wcg3-cvx6-7396"
      ]
    },
    "affected": {
      "os": [
        "linux",
        "redox",
        "solaris",
        "android",
        "ios",
        "macos",
        "netbsd",
        "openbsd",
        "freebsd"
      ],
      "functions": {
        "time::at": [
          "^0.1"
        ],
        "time::at_utc": [
          "^0.1"
        ],
        "time::now": [
          "^0.1"
        ],
        "time::UtcOffset::local_offset_at": [
          "< 0.2.23"
        ],
        "time::UtcOffset::try_local_offset_at": [
          "< 0.2.23"
        ],
        "time::UtcOffset::current_local_offset": [
          "< 0.2.23"
        ],
        "time::UtcOffset::try_current_local_offset": [
          "< 0.2.23"
        ],
        "time::OffsetDateTime::now_local": [
          "< 0.2.23"
        ],
        "time::OffsetDateTime::try_now_local": [
          "< 0.2.23"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.2.23"
      ],
      "unaffected": [
        "=0.2.0",
        "=0.2.1",
        "=0.2.2",
        "=0.2.3",
        "=0.2.4",
        "=0.2.5",
        "=0.2.6"
      ]
    },
    "text": "\n\n# Potential segfault in the time crate\n\n### Impact\n\nThe affected functions set environment variables without synchronization. On Unix-like operating systems, this can crash in multithreaded programs. Programs may segfault due to dereferencing a dangling pointer if an environment variable is read in a different thread than the affected functions. This may occur without the user's knowledge, notably in the Rust standard library or third-party libraries.\n\nThe affected functions from time 0.2.7 through 0.2.22 are:\n\n- `time::UtcOffset::local_offset_at`\n- `time::UtcOffset::try_local_offset_at`\n- `time::UtcOffset::current_local_offset`\n- `time::UtcOffset::try_current_local_offset`\n- `time::OffsetDateTime::now_local`\n- `time::OffsetDateTime::try_now_local`\n\nThe affected functions in time 0.1 (all versions) are:\n\n- `time::at_utc`\n- `time::at`\n- `time::now`\n- `time::tzset`\n\nNon-Unix targets (including Windows and wasm) are unaffected.\n\n### Patches\n\nPending a proper fix, the internal method that determines the local offset has been modified to always return `None` on the affected operating systems. This has the effect of returning an `Err` on the `try_*` methods and `UTC` on the non-`try_*` methods.\n\nUsers and library authors with time in their dependency tree should perform `cargo update`, which will pull in the updated, unaffected code.\n\nUsers of time 0.1 do not have a patch and should upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.\n\n### Workarounds\n\nA possible workaround for crates affected through the transitive dependency in `chrono`, is to avoid using the default `oldtime` feature dependency of the `chrono` crate by disabling its `default-features` and manually specifying the required features instead.\n\n#### Examples:\n\n`Cargo.toml`:  \n\n```toml\nchrono = { version = \"0.4\", default-features = false, features = [\"serde\"] }\n```\n\n```toml\nchrono = { version = \"0.4.22\", default-features = false, features = [\"clock\"] }\n```\n\nCommandline:  \n\n```bash\ncargo add chrono --no-default-features -F clock\n```\n\nSources:  \n - [chronotope/chrono#602 (comment)](https://github.com/chronotope/chrono/issues/602#issuecomment-1242149249)  \n - [vityafx/serde-aux#21](https://github.com/vityafx/serde-aux/issues/21)  \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0036",
      "package": "failure",
      "date": "2020-05-02",
      "informational": "unmaintained",
      "url": "https://github.com/rust-lang-nursery/failure/pull/347",
      "aliases": [
        "CVE-2019-25010",
        "CVE-2020-25575",
        "GHSA-jq66-xh47-j9f3",
        "GHSA-r98r-j25q-rmpr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# failure is officially deprecated/unmaintained\n\nThe `failure` crate is officially end-of-life: it has been marked as deprecated\nby the former maintainer, who has announced that there will be no updates or\nmaintenance work on it going forward.\n\nThe following are some suggested actively developed alternatives to switch to:\n\n- [`anyhow`](https://crates.io/crates/anyhow)\n- [`eyre`](https://crates.io/crates/eyre)\n- [`fehler`](https://crates.io/crates/fehler)\n- [`snafu`](https://crates.io/crates/snafu)\n- [`thiserror`](https://crates.io/crates/thiserror)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0036",
      "package": "failure",
      "aliases": [
        "CVE-2019-25010",
        "CVE-2020-25575",
        "GHSA-jq66-xh47-j9f3",
        "GHSA-r98r-j25q-rmpr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-11-13",
      "informational": "unsound",
      "keywords": [
        "unsound"
      ],
      "url": "https://github.com/rust-lang-nursery/failure/issues/336"
    },
    "affected": {
      "functions": {
        "failure::Fail::__private_get_type_id__": [
          ">= 0.1.0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Type confusion if __private_get_type_id__ is overridden\n\nSafe Rust code can implement malfunctioning `__private_get_type_id__` and cause\ntype confusion when downcasting, which is an undefined behavior.\n\nUsers who derive `Fail` trait are not affected.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0068",
      "package": "capnp",
      "date": "2022-11-30",
      "url": "https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md",
      "references": [
        "https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html",
        "https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx"
      ],
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2022-46149",
        "GHSA-qqff-4vw4-f6hx"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.15.2",
        "^0.14.11",
        "^0.13.7"
      ]
    },
    "text": "\n\n# out-of-bounds read possible when setting list-of-pointers\n\nIf a message consumer expects data\nof type \"list of pointers\",\nand if the consumer performs certain specific actions on such data,\nthen a message producer can cause the consumer to read out-of-bounds memory.\nThis could trigger a process crash in the consumer,\nor in some cases could allow exfiltration of private in-memory data.\n\nThe C++ Cap'n Proto library is also affected by this bug.\nSee the [advisory](https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md)\non the main Cap'n Proto repo for a succinct description of\nthe exact circumstances in which the problem can arise.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0066",
      "package": "safe_bindgen",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_bindgen/pull/67"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_bindgen`\n\nThis crate has been renamed from `safe_bindgen` to `sn_bindgen`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_bindgen>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0005",
      "package": "serde_yaml",
      "date": "2018-09-17",
      "keywords": [
        "crash"
      ],
      "url": "https://github.com/dtolnay/serde-yaml/pull/105",
      "aliases": [
        "GHSA-39vw-qp34-rmwf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.4"
      ],
      "unaffected": [
        "< 0.6.0-rc1"
      ]
    },
    "text": "\n\n# Uncontrolled recursion leads to abort in deserialization\n\nAffected versions of this crate did not properly check for recursion\nwhile deserializing aliases.\n\nThis allows an attacker to make a YAML file with an alias referring\nto itself causing an abort.\n\nThe flaw was corrected by checking the recursion depth.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0006",
      "package": "shlex",
      "date": "2024-01-21",
      "url": "https://github.com/comex/rust-shlex/security/advisories/GHSA-r7qv-8r2h-pg27",
      "categories": [
        "code-execution",
        "file-disclosure"
      ],
      "keywords": [],
      "aliases": [
        "GHSA-r7qv-8r2h-pg27"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.3.0"
      ]
    },
    "affected": {
      "functions": {
        "shlex::quote": [
          "< 1.2.1"
        ],
        "shlex::join": [
          "< 1.2.1"
        ],
        "shlex::bytes::quote": [
          "< 1.2.1"
        ],
        "shlex::bytes::join": [
          "< 1.2.1"
        ]
      }
    },
    "text": "\n\n# Multiple issues involving quote API\n\n## Issue 1: Failure to quote characters\n\nAffected versions of this crate allowed the bytes `{` and `\\xa0` to appear\nunquoted and unescaped in command arguments.\n\nIf the output of `quote` or `join` is passed to a shell, then what should be a\nsingle command argument could be interpreted as multiple arguments.\n\nThis does not *directly* allow arbitrary command execution (you can't inject a\ncommand substitution or similar).  But depending on the command you're running,\nbeing able to inject multiple arguments where only one is expected could lead\nto undesired consequences, potentially including arbitrary command execution.\n\nThe flaw was corrected in version 1.2.1 by escaping additional characters.\nUpdating to 1.3.0 is recommended, but 1.2.1 offers a more minimal fix if\ndesired.\n\nWorkaround: Check for the bytes `{` and `\\xa0` in `quote`/`join` input or\noutput.\n\n(Note: `{` is problematic because it is used for glob expansion.  `\\xa0` is\nproblematic because it's treated as a word separator in [specific\nenvironments][solved-xa0].)\n\n## Issue 2: Dangerous API w.r.t. nul bytes\n\nVersion 1.3.0 deprecates the `quote` and `join` APIs in favor of `try_quote`\nand `try_join`, which behave the same except that they have `Result` return\ntype, returning `Err` if the input contains nul bytes.\n\nStrings containing nul bytes generally cannot be used in Unix command arguments\nor environment variables, and most shells cannot handle nul bytes even\ninternally.  If you try to pass one anyway, then the results might be\nsecurity-sensitive in uncommon scenarios.  [More details here.][nul-bytes]\n\nDue to the low severity, the behavior of the original `quote` and `join` APIs\nhas not changed; they continue to allow nuls.\n\nWorkaround: Manually check for nul bytes in `quote`/`join` input or output.\n\n## Issue 3: Lack of documentation for interactive shell risks\n\nThe `quote` family of functions does not and cannot escape control characters.\nWith non-interactive shells this is perfectly safe, as control characters have\nno special effect.  But if you writing directly to the standard input of an\ninteractive shell (or through a pty), then control characters [can cause\nmisbehavior including arbitrary command injection.][control-characters]\n\nThis is essentially unfixable, and has not been patched.  But as of version\n1.3.0, documentation has been added.\n\nFuture versions of `shlex` may add API variants that avoid the issue at the\ncost of reduced portability.\n\n[solved-xa0]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#solved-xa0\n[nul-bytes]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#nul-bytes\n[control-characters]: https://docs.rs/shlex/latest/shlex/quoting_warning/index.html#control-characters-interactive-contexts-only\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0086",
      "package": "lexical-core",
      "date": "2023-09-03",
      "informational": "unsound",
      "references": [
        "https://github.com/Alexhuszagh/rust-lexical/issues/102",
        "https://github.com/Alexhuszagh/rust-lexical/issues/101",
        "https://github.com/Alexhuszagh/rust-lexical/issues/95",
        "https://github.com/Alexhuszagh/rust-lexical/issues/104",
        "https://github.com/Alexhuszagh/rust-lexical/issues/126"
      ],
      "related": [
        "RUSTSEC-2023-0055"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n`RUSTSEC-2024-0377` contains multiple soundness issues:\n\n 1. [Bytes::read() allows creating instances of types with invalid bit patterns](https://github.com/Alexhuszagh/rust-lexical/issues/102)\n 1. [BytesIter::read() advances iterators out of bounds](https://github.com/Alexhuszagh/rust-lexical/issues/101)\n 1. [The `BytesIter` trait has safety invariants but is public and not marked `unsafe`](https://github.com/Alexhuszagh/rust-lexical/issues/104)\n 1. [`write_float()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/95)\n 1. [`radix()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/126)\n\nVersion 1.0 fixes these issues, removes the vast majority of `unsafe` code, and also fixes some correctness issues.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0043",
      "package": "ftp",
      "date": "2023-02-20",
      "url": "https://github.com/mattnenterprise/rust-ftp/pull/92",
      "references": [
        "https://github.com/mattnenterprise/rust-ftp/issues/91",
        "https://github.com/mattnenterprise/rust-ftp/issues/84"
      ],
      "informational": "unmaintained",
      "keywords": [
        "ssl",
        "wont-build"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# ftp is unmaintained, use suppaftp instead\n\nThe [`ftp`](https://crates.io/crates/ftp) crate is not maintained any more;\nuse [`suppaftp`](https://crates.io/crates/suppaftp) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0106",
      "package": "multiqueue2",
      "aliases": [
        "CVE-2020-36214",
        "GHSA-jphw-p3m6-pj3c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-19",
      "url": "https://github.com/abbychau/multiqueue2/issues/10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.1.7"
      ]
    },
    "text": "\n\n# Queues allow non-Send types to be sent to other threads, allowing data races\n\nAffected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.\n\nThe flaw was corrected in v0.1.7 by adding `T: Send` bound to to the `Send` impl of four data types explained above.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0141",
      "package": "noise_search",
      "date": "2020-12-10",
      "url": "https://github.com/pipedown/noise/issues/72",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36461",
        "GHSA-wxjf-9f4g-3v44"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# MvccRwLock allows data races & aliasing violations\n\nAffected versions of this crate unconditionally implement Send/Sync for `MvccRwLock`.\nThis can lead to data races when types that are either `!Send` or `!Sync` (e.g. `Rc<T>`, `Arc<Cell<_>>`) are contained inside `MvccRwLock` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nAlso, safe APIs of `MvccRwLock` allow aliasing violations by allowing `&T` and `LockResult<MutexGuard<Box<T>>>` to co-exist in conflicting lifetime regions. The APIs of `MvccRwLock` should either be marked as `unsafe` or `MbccRwLock` should be changed to private or pub(crate).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0027",
      "package": "bam",
      "aliases": [
        "CVE-2021-28027",
        "GHSA-cpqj-r29q-chrh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-07",
      "url": "https://gitlab.com/tprodanov/bam/-/issues/4",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ]
    },
    "affected": {
      "functions": {
        "bam::bgzip::Block::load": [
          "< 0.1.3"
        ]
      }
    },
    "text": "\n\n# Loading a bgzip block can write out of bounds if size overflows.\n\nAffected versions of `bam` set the length of an internal buffer using\n`self.compressed.set_len(block_size - HEADER_SIZE - MIN_EXTRA_SIZE)` and then\nwrote into it. While `block_size` was constrained to a proper maximum, when it\nwas too small the subtraction could overflow negatively to a large number past\nthe capacity of `self.compressed`.\n\nThis can result in memory corruption in the form of writing out of bounds when\nloading a `bgzip` file with a small `block_size`.\n\nCommit `061eee38d4` fixed this issue by checking for the underflow when setting\nthe buffer size.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0014",
      "package": "chan",
      "date": "2018-07-31",
      "informational": "unmaintained",
      "url": "https://github.com/BurntSushi/chan/commit/0a5c0d4ad4adc90a54ee04a427389acf2e157275"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.1.23"
      ]
    },
    "text": "\n\n# chan is end-of-life; use crossbeam-channel instead\n\n**`chan` has reached its end-of-life and is now deprecated.**\n\nThe intended successor of this crate is\n[`crossbeam-channel`](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel).\nIts API is strikingly similar, but comes with a much better `select!` macro,\nbetter performance, a better test suite and an all-around better\nimplementation.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0009",
      "package": "basic_dsp_matrix",
      "aliases": [
        "CVE-2021-25906",
        "GHSA-fjr6-hm39-4cf9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-10",
      "url": "https://github.com/liebharc/basic_dsp/issues/47",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.2"
      ]
    },
    "text": "\n\n# panic safety issue in `impl TransformContent<S, D> for [S; (2|3|4)]`\n\nAffected versions of this crate did not guard against double drop while temporarily duplicating objects' ownership using `ptr::read()`. Upon panic in a user-provided function `conversion`, objects that are copied by `ptr::read()` are dropped twice, leading to memory corruption.\n\nThe flaw was corrected in v0.9.2 by using `ManuallyDrop<T>` to enclose objects that are to be temporarily duplicated.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0008",
      "package": "hyper",
      "aliases": [
        "CVE-2020-35863",
        "GHSA-h3qr-rq2j-74w4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "format-injection"
      ],
      "date": "2020-03-19",
      "keywords": [
        "http",
        "request-smuggling"
      ],
      "url": "https://github.com/hyperium/hyper/issues/1925"
    },
    "versions": {
      "patched": [
        ">= 0.12.34"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# Flaw in hyper allows request smuggling by sending a body in GET requests\n\nVulnerable versions of hyper allow GET requests to have bodies, even if there is\nno Transfer-Encoding or Content-Length header.  As per the HTTP 1.1\nspecification, such requests do not have bodies, so the body will be interpreted\nas a separate HTTP request.\n\nThis allows an attacker who can control the body and method of an HTTP request\nmade by hyper to inject a request with headers that would not otherwise be\nallowed, as demonstrated by sending a malformed HTTP request from a Substrate\nruntime.  This allows bypassing CORS restrictions.  In combination with other\nvulnerabilities, such as an exploitable web server listening on loopback, it may\nallow remote code execution.\n\nThe flaw was corrected in hyper version 0.12.34.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0020",
      "package": "hyper",
      "date": "2021-02-05",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "http",
        "request-smuggling"
      ],
      "aliases": [
        "CVE-2021-21299",
        "GHSA-6hfq-h8hq-87mf"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.14.3",
        "0.13.10",
        "0.12.36"
      ],
      "unaffected": [
        "< 0.12.0"
      ]
    },
    "text": "\n\n# Multiple Transfer-Encoding headers misinterprets request payload\n\nhyper's HTTP server code had a flaw that incorrectly understands some requests\nwith multiple transfer-encoding headers to have a chunked payload, when it\nshould have been rejected as illegal. This combined with an upstream HTTP proxy\nthat understands the request payload boundary differently can result in\n\"request smuggling\" or \"desync attacks\".\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0022",
      "package": "hyper",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/hyperium/hyper/pull/2545",
      "aliases": [
        "GHSA-f67m-9j94-qv9j"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.14.12"
      ]
    },
    "text": "\n\n# Parser creates invalid uninitialized value\n\nAffected versions of this crate called `mem::uninitialized()` in the HTTP1 parser to create values of type `httparse::Header` (from the `httparse` crate).\nThis is unsound, since `Header` contains references and thus must be non-null.\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0002",
      "package": "hyper",
      "date": "2016-05-09",
      "aliases": [
        "CVE-2016-10932",
        "GHSA-9xjr-m6f3-v5wm"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
      "related": [
        "RUSTSEC-2016-0001"
      ],
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "ssl",
        "mitm"
      ],
      "url": "https://github.com/hyperium/hyper/blob/master/CHANGELOG.md#v094-2016-05-09"
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.4"
      ]
    },
    "text": "\n\n# HTTPS MitM vulnerability due to lack of hostname verification\n\nWhen used on Windows platforms, all versions of Hyper prior to 0.9.4 did not\nperform hostname verification when making HTTPS requests.\n\nThis allows an attacker to perform MitM attacks by preventing any valid\nCA-issued certificate, even if there's a hostname mismatch.\n\nThe problem was addressed by leveraging rust-openssl's built-in support for\nhostname verification.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0002",
      "package": "hyper",
      "aliases": [
        "CVE-2017-18587",
        "GHSA-q89x-f52w-6hj2"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
      "date": "2017-01-23",
      "url": "https://github.com/hyperium/hyper/wiki/Security-001"
    },
    "versions": {
      "patched": [
        ">= 0.10.2",
        "< 0.10.0, >= 0.9.18"
      ]
    },
    "text": "\n\n# headers containing newline characters can split messages\n\nSerializing of headers to the socket did not filter the values for newline bytes (`\\r` or `\\n`),\nwhich allowed for header values to split a request or response. People would not likely include\nnewlines in the headers in their own applications, so the way for most people to exploit this\nis if an application constructs headers based on unsanitized user input.\n\nThis issue was fixed by replacing all newline characters with a space during serialization of\na header value.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0078",
      "package": "hyper",
      "date": "2021-07-07",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-f3pg-qwvg-p99c",
      "keywords": [
        "parsing",
        "http"
      ],
      "aliases": [
        "CVE-2021-32715",
        "GHSA-f3pg-qwvg-p99c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.14.10"
      ]
    },
    "text": "\n\n# Lenient `hyper` header parsing of `Content-Length` could allow request smuggling\n\n`hyper`'s HTTP header parser accepted, according to RFC 7230, illegal contents inside `Content-Length` headers.\nDue to this, upstream HTTP proxies that ignore the header may still forward them along if it chooses to ignore the error.\n\nTo be vulnerable, `hyper` must be used as an HTTP/1 server and using an HTTP proxy upstream that ignores the header's contents\nbut still forwards it. Due to all the factors that must line up, an attack exploiting this vulnerability is unlikely.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0079",
      "package": "hyper",
      "date": "2021-07-07",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-5h46-h7hh-c6x9",
      "keywords": [
        "http",
        "parsing",
        "data loss"
      ],
      "aliases": [
        "CVE-2021-32714",
        "GHSA-5h46-h7hh-c6x9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.14.10"
      ]
    },
    "text": "\n\n# Integer overflow in `hyper`'s parsing of the `Transfer-Encoding` header leads to data loss\n\nWhen decoding chunk sizes that are too large, `hyper`'s code would encounter an integer overflow. Depending on the situation,\nthis could lead to data loss from an incorrect total size, or in rarer cases, a request smuggling attack.\n\nTo be vulnerable, you must be using `hyper` for any HTTP/1 purpose, including as a client or server, and consumers must send\nrequests or responses that specify a chunk size greater than 18 exabytes. For a possible request smuggling attack to be possible,\nany upstream proxies must accept a chunk size greater than 64 bits.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0067",
      "package": "fehler",
      "date": "2023-10-12",
      "url": "https://github.com/withoutboats/fehler/issues/66",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# `fehler` is unmaintained; use `culpa` instead\n\nThe [`fehler`](https://crates.io/crates/fehler) crate is no longer maintained.\nConsider using [`culpa`](https://crates.io/crates/culpa) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0010",
      "package": "containers",
      "aliases": [
        "CVE-2021-25907",
        "GHSA-cv7x-6rc6-pq5v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-12",
      "url": "https://github.com/strake/containers.rs/issues/2",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.11"
      ]
    },
    "text": "\n\n# panic safety: double drop may happen within `util::{mutate, mutate2}`\n\nUpon panic in a user-provided function `f`, `fn mutate()` & `fn mutate2` drops twice a same object.\n\nAffected versions of this crate did not guard against double drop while temporarily duplicating an object's ownership with `ptr::read()`.\n\nDropping a same object can result in memory corruption.\n\nThe flaw was corrected in version \"0.9.11\" by fixing the code to abort upon panic.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0040",
      "package": "arenavec",
      "aliases": [
        "CVE-2021-29930",
        "CVE-2021-29931",
        "GHSA-327x-39hh-65wf",
        "GHSA-955p-rc5h-hg6h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-12",
      "url": "https://github.com/ibabushkin/arenavec/issues/1",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# panic safety: double drop or uninitialized drop of T upon panic\n\nAffected versions of this crate did not guard against potential panics that may happen from user-provided functions `T::default()` and `T::drop()`.\n\nPanic within `T::default()` leads to dropping uninitialized `T`, when it is invoked from `common::Slice::<T, H>::new()`.\nPanic within `T::drop()` leads to double drop of `T`, when it is invoked either from `common::SliceVec::<T, H>::resize_with()` or `common::SliceVec::<T, H>::resize()`\n\nEither case causes memory corruption in the heap memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0061",
      "package": "aes-ctr",
      "date": "2021-04-29",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `aes-ctr` has been merged into the `aes` crate\n\nPlease use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nThe `aes` crate now has an optional `ctr` feature which autodetects SIMD\nfeatures on `i686`/`x86-64` targets and uses them if available, or otherwise\nfalls back to the implementation in the `ctr` crate.\n\nIf you would prefer not to have this autodetection performed, use the `aes`\ncrate directly with the `ctr` crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0055",
      "package": "lexical",
      "date": "2023-09-03",
      "informational": "unsound",
      "references": [
        "https://github.com/Alexhuszagh/rust-lexical/issues/102",
        "https://github.com/Alexhuszagh/rust-lexical/issues/101",
        "https://github.com/Alexhuszagh/rust-lexical/issues/95",
        "https://github.com/Alexhuszagh/rust-lexical/issues/104",
        "https://github.com/Alexhuszagh/rust-lexical/issues/126"
      ],
      "aliases": [
        "GHSA-c2hm-mjxv-89r4"
      ]
    },
    "versions": {
      "patched": [
        ">= 7.0.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n`lexical` contains multiple soundness issues:\n\n 1. [Bytes::read() allows creating instances of types with invalid bit patterns](https://github.com/Alexhuszagh/rust-lexical/issues/102)\n 1. [BytesIter::read() advances iterators out of bounds](https://github.com/Alexhuszagh/rust-lexical/issues/101)\n 1. [The `BytesIter` trait has safety invariants but is public and not marked `unsafe`](https://github.com/Alexhuszagh/rust-lexical/issues/104)\n 1. [`write_float()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/95)\n 1. [`radix()` calls `MaybeUninit::assume_init()` on uninitialized data, which is is not allowed by the Rust abstract machine](https://github.com/Alexhuszagh/rust-lexical/issues/126)\n\nThe crate also has some correctness issues.\n\n## Alternatives\n\nFor quickly parsing floating-point numbers third-party crates are no longer needed. A fast float parsing algorithm by the author of `lexical` has been [merged](https://github.com/rust-lang/rust/pull/86761) into libcore.\n\nFor quickly parsing integers, consider `atoi` and `btoi` crates (100% safe code). `atoi_radix10` provides even faster parsing, but only with `-C target-cpu=native`, and at the cost of some `unsafe`.\n\nFor formatting integers in a `#[no_std]` context consider the [`numtoa`](https://crates.io/crates/numtoa) crate.\n\nFor working with big numbers consider `num-bigint` and `num-traits`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0048",
      "package": "xml-rs",
      "date": "2022-01-26",
      "withdrawn": "2023-05-04",
      "url": "https://github.com/netvl/xml-rs/issues",
      "references": [
        "https://github.com/netvl/xml-rs/issues/219",
        "https://github.com/netvl/xml-rs/issues/210",
        "https://github.com/netvl/xml-rs/issues/204"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# xml-rs is Unmaintained\n\nxml-rs is a XML parser has open issues around parsing including integer\noverflows / panics that may or may not be an issue with untrusted data.\n\nTogether with these open issues with Unmaintained status xml-rs\nmay or may not be suited to parse untrusted data.\n\n## Alternatives\n\n- [quick-xml](https://crates.io/crates/quick-xml)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0059",
      "package": "users",
      "date": "2023-09-10",
      "url": "https://github.com/ogham/rust-users/issues/55",
      "informational": "unsound",
      "keywords": [
        "unaligned-read"
      ],
      "aliases": [
        "GHSA-jcr6-4frq-9gjj"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Unaligned read of `*const *const c_char` pointer\n\nAffected versions dereference a potentially unaligned pointer. The pointer is\ncommonly unaligned in practice, resulting in undefined behavior.\n\nIn some build modes, this is observable as a panic followed by abort. In other\nbuild modes the UB may manifest in some other way, including the possibility of\nworking correctly in some architectures.\n\nThe crate is not currently maintained, so a patched version is not available.\n\n## Recommended alternatives\n- [`uzers`](https://crates.io/crates/uzers) (an actively maintained fork of the `users` crate)\n- [`sysinfo`](https://crates.io/crates/sysinfo)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0040",
      "package": "users",
      "date": "2023-06-01",
      "url": "https://github.com/ogham/rust-users/issues/54",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `users` crate is unmaintained\n\nThe `users` crate hasn't seen any action since 2020-10-08. The developer seems [MIA] since.\n\n## Recommended alternatives\n- [`uzers`]\n- [`sysinfo`]\n\n[MIA]: https://github.com/ogham/rust-users/issues/54\n[`uzers`]: https://crates.io/crates/uzers\n[`sysinfo`]: https://crates.io/crates/sysinfo\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0011",
      "package": "plutonium",
      "date": "2020-04-23",
      "informational": "notice",
      "url": "https://docs.rs/plutonium",
      "aliases": [
        "GHSA-gfg9-x6px-r7gr"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Library exclusively intended to obfuscate code.\n\nThis crate allows you to write safe functions with unsafe bodies without the `unsafe` keyword.\n\nThe value this adds is questionable, and hides `unsafe` usages from naive analysis.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0122",
      "package": "beef",
      "date": "2020-10-28",
      "url": "https://github.com/maciejhirsz/beef/issues/37",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36442",
        "GHSA-m7w4-8wp8-m2xq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# beef::Cow lacks a Sync bound on its Send trait allowing for data races\n\nAffected versions of this crate did not have a `T: Sync` bound in the `Send` impl for `Cow<'_, T, U>`. This allows users to create data races by making `Cow` contain types that are (Send && !Sync) like `Cell<_>` or `RefCell<_>`.\n\nSuch data races can lead to memory corruption.\n\nThe flaw was corrected in commit d1c7658 by adding trait bounds `T: Sync` and `T::Owned: Send` to the `Send` impl for `Cow<'_, T, U>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0346",
      "package": "zerovec-derive",
      "date": "2024-07-01",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.3",
        ">= 0.9.7, <0.10.0"
      ]
    },
    "text": "\n\n# Incorrect usage of `#[repr(packed)]`\n\nThe affected versions make unsafe memory accesses under the assumption that `#[repr(packed)]` has a guaranteed field order. \n\nThe Rust specification does not guarantee this, and https://github.com/rust-lang/rust/pull/125360 (1.80.0-beta) starts \nreordering fields of `#[repr(packed)]` structs, leading to illegal memory accesses.\n\nThe patched versions `0.9.7` and `0.10.3` use `#[repr(C, packed)]`, which guarantees field order.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0076",
      "package": "cpython",
      "date": "2023-11-14",
      "url": "https://github.com/dgrunwald/rust-cpython/commit/e815555",
      "references": [
        "https://github.com/dgrunwald/rust-cpython/issues/265",
        "https://github.com/dgrunwald/rust-cpython/issues/294"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `cpython` is unmaintained\n\nThe `cpython` crate and the underlying `python3-sys` and `python27-sys` crates have been marked as [no longer actively maintained] by the developer.\n\nThere are also open issues for unsound code that is currently in these crates:\n\n- [cpython#265]: Using some string functions causes segmentation faults on big-endian architectures. Due to incorrect bitfield manipulations, it is possible to create invalid Python objects that crash the Python interpreter.\n- [cpython#294]: Python 3.12 is not supported. Due to ABI changes in Python 3.12, calling some string functions will result in invalid Python objects and / or cause out-of-bounds memory accesses.\n\n## Recommended alternatives\n\n- [`pyo3`] (version 0.19.2 and newer)\n\nThe `pyo3` crate is actively maintained. Preliminary support for Python 3.12 was added in version 0.19.2, and version 0.20.0 was released with full support for Python 3.12.\n\nBoth versions implement string functions correctly on big-endian architectures. The endianness issue affecting the `cpython` crate was fixed in recent versions of `pyo3`.\n\n[no longer actively maintained]: https://github.com/dgrunwald/rust-cpython/commit/e815555\n[cpython#265]: https://github.com/dgrunwald/rust-cpython/issues/265\n[cpython#294]: https://github.com/dgrunwald/rust-cpython/issues/294\n[`pyo3`]: https://crates.io/crates/pyo3\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0105",
      "package": "abi_stable",
      "aliases": [
        "CVE-2020-36212",
        "CVE-2020-36213",
        "GHSA-vq23-5h4f-vwpv",
        "GHSA-wqxc-qrq4-w5v4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-21",
      "url": "https://github.com/rodrimati1992/abi_stable_crates/issues/44",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.1"
      ]
    },
    "text": "\n\n# Update unsound DrainFilter and RString::retain\n\nAffected versions of this crate contained code from the Rust standard library that contained soundness bugs rust-lang/rust#60977 (double drop) & rust-lang/rust#78498 (create invalid utf-8 string).\n\nThe flaw was corrected in v0.9.1 by making a similar fix to the one made in the Rust standard library.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0002",
      "package": "git2",
      "date": "2023-01-12",
      "url": "https://github.com/rust-lang/git2-rs/pull/909",
      "references": [
        "https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html"
      ],
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "cargo",
        "ssh",
        "mitm"
      ],
      "withdrawn": "2023-01-13"
    },
    "versions": {
      "patched": [
        ">= 0.16.0"
      ]
    },
    "text": "\n\n# git2 Rust package suppresses ssh host key checking\n\nBy default, when accessing an ssh repository\n(ie via an `ssh:` git repository url)\nthe git2 Rust package does not do any host key checking.\n\nAdditionally,\nthe provided API is not sufficient for a an application\nto do meaningful checking itself.\n\n## Impact\n\nWhen connecting to an ssh repository,\nand when an attacker can redirect the connection\n(performing a malice-in-the-middle attack)\nan affected application might:\n\n * Receive git objects and branches controlled by the attacker,\n   exposing the local system (and whatever happens next)\n   to malicious data.\n   In many circumstances,\n   this could readily lead to privilege escalation.\n\n * Erroneously send git objects to the attacker,\n   rather than to the intended recipient.\n   If the information is not supposed to be public,\n   this would constitute an information leak.\n   Also, since the data doesn't arrive where intended,\n   it constitutes a denial of service.\n\n## Technical details\n\nThe `git2` Rust package (henceforth, git2-rs)\nunconditionally calls the underlying C `libgit2` functions to set\nan ssh certificate check callback.\nThe Rust package uses this to offer\nthe ability for the application to set a callback to a Rust function.\n\nThe C-level callback function provided by git2-rs 0.15.0 and earlier:\n\n * Always ignores the `is_valid` argument provided by `libgit2`,\n   which indicates whether `libgit2` considers the host key valid\n\n * By default, performs no checks, and then\n   returns code `0`,\n   indicating to `libgit2` to override `libgit2`'s determination\n   and treat the host key as valid.\n\n * Provides only limited APIs to the application\n   for examining the supplied host key,\n   and doesn't tell the application\n   whether `libgit2`'s checks succeeded,\n   so it is difficult for the application cannot work around the problem.\n\n## Resolution\n\nUpgrade to git2-rs 0.16.x.\n\nThe default behaviour in 0.16.x is to\nhonour `libgit2`'s validity determination.\n\nNote that adding this previously skipped check\nmay cause existing setups to stop working.\n\n## Relationship to CVE-2022-46176\n\nThis bug manifested in cargo where it was assigned CVE-2022-46176.\n\nThe same bug exists in other applications which use\naffected versions of git2-rs\nunless they never try to access git repositories with `ssh:` urls.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0058",
      "package": "inconceivable",
      "date": "2022-09-28",
      "informational": "notice",
      "url": "https://crates.io/crates/inconceivable"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Library exclusively intended to inject UB into safe Rust.\n\nQuoting from the crate description:\n\n> This crate is created purely to inject undefined behavior into stable, safe rust.\n\nSpecifically, the `inconceivable!` macro is insta-UB if the `ub_inconceivable` feature is enabled by *any* reverse dependency.\nThe value this adds is questionable, and hides `unsafe` code from naive analysis.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0053",
      "package": "mapr",
      "date": "2022-08-24",
      "url": "https://github.com/rustsec/advisory-db/pull/1381",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# mapr is Unmaintained\n\nThe `mapr` fork has been merged back into upstream fork `memmap2`.\n\nThe maintainer(s) have advised `mapr` is deprecated and will not\nreceive any maintenance in favor of using `memmap2`.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [`memmap2`](https://github.com/RazrFalcon/memmap2-rs)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0016",
      "package": "ms3d",
      "aliases": [
        "CVE-2021-26952",
        "GHSA-9f5r-vqm5-m342"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-26",
      "url": "https://github.com/andrewhickman/ms3d/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ]
    },
    "text": "\n\n# `IoReader::read()`: user-provided `Read` on uninitialized buffer may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 599313b by zero-initializing the buffer (via `self.buf.resize(len, 0)`) before passing it to `Read`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0060",
      "package": "aes-soft",
      "date": "2021-04-29",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `aes-soft` has been merged into the `aes` crate\n\nPlease use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nAES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.\nIf AES-NI is not present, the `aes` crate will fallback to a constant-time\nportable software implementation.\n\nTo force the use of a constant-time portable implementation on these platforms,\neven if AES-NI is available, use the new `force-soft` feature of the `aes`\ncrate to disable autodetection.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0039",
      "package": "typemap",
      "date": "2019-04-06",
      "url": "https://github.com/reem/rust-typemap/issues/45",
      "references": [
        "https://github.com/rustsec/advisory-db/issues/1088"
      ],
      "informational": "unmaintained",
      "aliases": [
        "GHSA-vfv3-9w6v-23jp"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# typemap is Unmaintained\n\nThe maintainer seems unreachable.\n\nThe crate may or may not be usable as-is despite no maintenance and may not work in future versions of Rust.\n\nThe last release seems to have been seven years ago.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [ttmap](https://crates.io/crates/ttmap)\n - [typemap_rev](https://crates.io/crates/typemap_rev)\n - [typemap-ors](https://crates.io/crates/typemap-ors)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0067",
      "package": "quic-p2p",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/qp2p/pull/141"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `qp2p`\n\nThis crate has been renamed from `quic-p2p` to `qp2p`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/qp2p>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0077",
      "package": "claim",
      "date": "2022-12-04",
      "url": "https://github.com/svartalf/rust-claim/issues/12",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `claim` is Unmaintained\n\nThe last release was in February 2021, almost two years ago.\n\nThe maintainer has been unresponsive regarding this crate for over a year.\n\nA pending issue with `claim`'s dependencies has made the crate [difficult to use](https://github.com/svartalf/rust-claim/issues/9).\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n- [`claims`](https://crates.io/crates/claims), a direct fork of the `claim` crate\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0001",
      "package": "untrusted",
      "aliases": [
        "CVE-2018-20989",
        "GHSA-wq8f-46ww-6c2h"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2018-06-21",
      "keywords": [
        "crash"
      ],
      "url": "https://github.com/briansmith/untrusted/pull/20"
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ],
      "unaffected": []
    },
    "text": "\n\n# An integer underflow could lead to panic\n\nA mistake in error handling in untrusted before 0.6.2 could lead to an integer\nunderflow and panic if a user of the crate didn't properly check for errors\nreturned by untrusted.\n\nCombination of these two programming errors (one in untrusted and another by\nuser of this crate) could lead to a panic and maybe a denial of service of\naffected software.\n\nThe error in untrusted is fixed in release 0.6.2 released 2018-06-21. It's also\nadvisable that users of untrusted check for their sources for cases where errors\nreturned by untrusted are not handled correctly.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0019",
      "package": "tokio-rustls",
      "aliases": [
        "CVE-2020-35875",
        "GHSA-2jfv-g3fh-xq3v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-05-19",
      "keywords": [
        "tls",
        "ssl",
        "DoS"
      ],
      "url": "https://github.com/tokio-rs/tls/pull/14"
    },
    "versions": {
      "patched": [
        ">= 0.12.3, < 0.13.0",
        ">= 0.13.1"
      ],
      "unaffected": [
        "< 0.12"
      ]
    },
    "text": "\n\n# tokio-rustls reads may cause excessive memory usage\n\n`tokio-rustls` does not call `process_new_packets` immediately after `read`,\nso the expected termination condition `wants_read` always returns true.\nAs long as new incoming data arrives faster than it is processed\nand the reader does not return pending, data will be buffered.\n\nThis may cause DoS.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0076",
      "package": "libsecp256k1",
      "date": "2021-07-13",
      "url": "https://github.com/paritytech/libsecp256k1/pull/67",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "CVE-2021-38195",
        "GHSA-g4vj-x7v9-h82m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# libsecp256k1 allows overflowing signatures\n\nlibsecp256k1 accepts signatures whose R or S parameter is larger than the\nsecp256k1 curve order, which differs from other implementations. This could\nlead to invalid signatures being verified.\n\nThe error is resolved in 0.5.0 by adding a `check_overflow` flag.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0027",
      "package": "libsecp256k1",
      "aliases": [
        "CVE-2019-25003",
        "GHSA-hrjm-c879-pp86"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "categories": [
        "crypto-failure"
      ],
      "date": "2019-10-14",
      "keywords": [
        "crypto",
        "sidechannel"
      ]
    },
    "affected": {
      "functions": {
        "libsecp256k1::Scalar::check_overflow": [
          "< 0.3.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "text": "\n\n# Flaw in Scalar::check_overflow allows side-channel timing attack\n\nVersions of `libsecp256k1` prior to `0.3.1` did not execute\nScalar::check_overflow in constant time.\n\nThis allows an attacker to potentially leak information via a timing attack.\n\nThe flaw was corrected by modifying Scalar::check_overflow to execute in\nconstant time.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0016",
      "package": "net2",
      "date": "2020-05-01",
      "informational": "unmaintained",
      "url": "https://github.com/deprecrated/net2-rs/commit/3350e3819adf151709047e93f25583a5df681091"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `net2` crate has been deprecated; use `socket2` instead\n\nThe [`net2`](https://crates.io/crates/net2) crate has been deprecated\nand users are encouraged to considered [`socket2`](https://crates.io/crates/socket2) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0078",
      "package": "net2",
      "date": "2020-11-07",
      "url": "https://github.com/deprecrated/net2-rs/issues/105",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-35919",
        "CVE-2020-35920",
        "GHSA-458v-4hrf-g3m4",
        "GHSA-c79c-gwph-gqfm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.36"
      ]
    },
    "text": "\n\n# `net2` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`net2`](https://crates.io/crates/net2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0017",
      "package": "tempdir",
      "date": "2018-02-13",
      "informational": "unmaintained",
      "url": "https://github.com/rust-lang-deprecated/tempdir/pull/46"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `tempdir` crate has been deprecated; use `tempfile` instead\n\nThe [`tempdir`](https://crates.io/crates/tempdir) crate has been deprecated\nand the functionality is merged into [`tempfile`](https://crates.io/crates/tempfile).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0094",
      "package": "rdiff",
      "date": "2021-02-03",
      "url": "https://github.com/dyule/rdiff/issues/3",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45694",
        "GHSA-2rxc-8f9w-fjq8",
        "GHSA-q579-9wp9-gfp2"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Window can read out of bounds if Read instance returns more bytes than buffer size\n\n`rdiff` performs a diff of two provided strings or files. As part of its reading\ncode it uses the return value of a `Read` instance to set the length of\nits internal character vector.\n\nIf the `Read` implementation claims that it has read more bytes than the length\nof the provided buffer, the length of the vector will be set to longer than its\ncapacity. This causes `rdiff` APIs to return uninitialized memory in its API\nmethods.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0013",
      "package": "fake-static",
      "date": "2020-04-24",
      "aliases": [
        "GHSA-8xw8-mmqv-frqq"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# fake-static allows converting any reference into a `'static` reference\n\nfake-static allows converting a reference with any lifetime into\na reference with `'static` lifetime without the `unsafe` keyword.\n\nInternally, this crate does not use unsafe code, it instead\nexploits a soundness bug in rustc:\n\nhttps://github.com/rust-lang/rust/issues/25860\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0021",
      "package": "eyre",
      "date": "2024-03-05",
      "url": "https://github.com/eyre-rs/eyre/issues/141",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-4v52-7q2x-v4xj"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.12"
      ],
      "unaffected": [
        "< 0.6.9"
      ]
    },
    "affected": {
      "functions": {
        "eyre::Report::downcast": [
          ">= 0.6.9, < 0.6.12"
        ]
      }
    },
    "text": "\n\n# Parts of Report are dropped as the wrong type during downcast\n\nIn affected versions, after a `Report` is constructed using `wrap_err` or\n`wrap_err_with` to attach a message of type `D` onto an error of type `E`, then\nusing `downcast` to recover ownership of either the value of type `D` or the\nvalue of type `E`, one of two things can go wrong:\n\n- If downcasting to `E`, there remains a value of type `D` to be dropped. It is\n  incorrectly \"dropped\" by running `E`'s drop behavior, rather than `D`'s. For\n  example if `D` is `&str` and `E` is `std::io::Error`, there would be a call of\n  `std::io::Error::drop` in which the reference received by the `Drop` impl does\n  not refer to a valid value of type `std::io::Error`, but instead to `&str`.\n\n- If downcasting to `D`, there remains a value of type `E` to be dropped. When\n  `D` and `E` do not happen to be the same size, `E`'s drop behavior is\n  incorrectly executed in the wrong location. The reference received by the\n  `Drop` impl may point left or right of the real `E` value that is meant to be\n  getting dropped.\n\nIn both cases, when the `Report` contains an error `E` that has nontrivial drop\nbehavior, the most likely outcome is memory corruption.\n\nWhen the `Report` contains an error `E` that has trivial drop behavior (for\nexample a `Utf8Error`) but where `D` has nontrivial drop behavior (such as\n`String`), the most likely outcome is that downcasting to `E` would leak `D`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0063",
      "package": "safe-nd",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_data_types/pull/218"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `safe-nd`\n\nThis crate has been renamed from `safe-nd` to `sn_data_types`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_data_types>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0159",
      "package": "chrono",
      "date": "2020-11-10",
      "url": "https://github.com/chronotope/chrono/issues/499",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "keywords": [
        "segfault"
      ],
      "related": [
        "CVE-2020-26235",
        "RUSTSEC-2020-0071"
      ]
    },
    "versions": {
      "patched": [
        ">=0.4.20"
      ]
    },
    "text": "\n\n# Potential segfault in `localtime_r` invocations\n\n### Impact\n\nUnix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.\n\n### Workarounds\n\nNo workarounds are known.\n\n### References\n\n- [time-rs/time#293](https://github.com/time-rs/time/issues/293)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0137",
      "package": "lever",
      "date": "2020-11-10",
      "url": "https://github.com/vertexclique/lever/issues/15",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36457",
        "GHSA-9pp4-8p8v-g78w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.1"
      ]
    },
    "text": "\n\n# AtomicBox<T> lacks bound on its Send and Sync traits allowing data races\n\n`AtomicBox<T>` is a `Box` type designed to be used across threads, however, it\nimplements the `Send` and `Sync` traits for all types `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0010",
      "package": "svix",
      "date": "2024-02-06",
      "url": "https://github.com/svix/svix-webhooks/pull/1190",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "CVE-2024-21491",
        "GHSA-747x-5m58-mq97",
        "GHSA-w277-wpqf-rcfv"
      ]
    },
    "affected": {
      "functions": {
        "svix::webhooks::Webhook::verify": [
          "< 1.17.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.17.0"
      ]
    },
    "text": "\n\n# Improper comparison of different-length signatures\n\nThe `Webhook::verify` function incorrectly compared signatures of\ndifferent lengths - the two signatures would only be compared up to\nthe length of the shorter signature. This allowed an attacker to\npass in `v1,` as the signature, which would always pass verification.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0043",
      "package": "ws",
      "aliases": [
        "CVE-2020-35896",
        "GHSA-rh7x-ppxx-p34c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-09-25",
      "keywords": [
        "websocket",
        "dos",
        "ddos",
        "oom",
        "memory",
        "remotely"
      ],
      "url": "https://github.com/housleyjk/ws-rs/issues/291"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Insufficient size checks in outgoing buffer in ws allows remote attacker to run the process out of memory\n\nAffected versions of this crate did not properly check and cap the growth of the outgoing buffer.\n\nThis allows a remote attacker to take down the process by growing the buffer of their (single) connection until the process runs out of memory it can allocate and is killed.\n\nThe flaw was corrected in the [`parity-ws` fork](https://crates.io/crates/parity-ws) (>=0.10.0) by [disconnecting a client when the buffer runs full](https://github.com/housleyjk/ws-rs/pull/328).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0137",
      "package": "sodiumoxide",
      "date": "2021-10-22",
      "keywords": [
        "cryptography"
      ],
      "informational": "unmaintained",
      "url": "https://github.com/sodiumoxide/sodiumoxide/commit/5bb1dfd2578539b89ffb0cbea25f21f00cfb963e"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# sodiumoxide is deprecated\n\nAlternatives may be found - not in any specific order:\n\n- [libsodium-sys-stable](https://crates.io/crates/libsodium-sys-stable)\n- [dryoc](https://crates.io/crates/dryoc)\n- [RustCrypto/nacl-compat](https://github.com/RustCrypto/nacl-compat) (`crypto_box`, `crypto_kx`, `crypto_secretstream`)\n- [RustCrypto/xsalsa20poly1305](https://github.com/RustCrypto/AEADs/tree/master/xsalsa20poly1305) (`crypto_secretbox`)\n- [Signatory](https://crates.io/crates/signatory)\n- [ed25519-compact](https://crates.io/crates/ed25519-compact)\n- [ed25519-dalek](https://github.com/dalek-cryptography/ed25519-dalek)\n- [ring](https://github.com/briansmith/ring)\n\nRecommendations can be also found from:\n\n- [Awesome Rust Cryptography](https://github.com/The-DevX-Initiative/RCIG_Coordination_Repo/blob/main/Awesome_Rust_Cryptography.md) \n\nNo direct maintained fork exists.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0001",
      "package": "sodiumoxide",
      "aliases": [
        "CVE-2017-1000168",
        "GHSA-2wc6-2rcj-8v76"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
      "date": "2017-01-26",
      "keywords": [
        "cryptography"
      ],
      "url": "https://github.com/dnaq/sodiumoxide/issues/154"
    },
    "versions": {
      "patched": [
        ">= 0.0.14"
      ]
    },
    "text": "\n\n# scalarmult() vulnerable to degenerate public keys\n\nThe `scalarmult()` function included in previous versions of this crate\naccepted all-zero public keys, for which the resulting Diffie-Hellman shared\nsecret will always be zero regardless of the private key used.\n\nThis issue was fixed by checking for this class of keys and rejecting them\nif they are used.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0026",
      "package": "sodiumoxide",
      "aliases": [
        "CVE-2019-25002",
        "GHSA-wrvc-72w7-xpmj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-10-11",
      "keywords": [
        "cryptography"
      ],
      "url": "https://github.com/sodiumoxide/sodiumoxide/pull/381"
    },
    "affected": {
      "functions": {
        "sodiumoxide::crypto::generichash::Digest::eq": [
          "< 0.2.5, >= 0.2.0"
        ],
        "sodiumoxide::crypto::generichash::Digest::ne": [
          "< 0.2.5, >= 0.2.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.2.5"
      ]
    },
    "text": "\n\n# generichash::Digest::eq always return true\n\nPartialEq implementation for generichash::Digest has compared itself to itself.\n\nDigest::eq always returns true and Digest::ne always returns false. \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0011",
      "package": "snow",
      "date": "2024-01-23",
      "url": "https://github.com/mcginty/snow/security/advisories/GHSA-7g9j-g5jg-3vv3",
      "categories": [
        "crypto-failure",
        "denial-of-service"
      ],
      "keywords": [
        "noise",
        "nonce",
        "state"
      ],
      "aliases": [
        "GHSA-7g9j-g5jg-3vv3"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.5"
      ]
    },
    "text": "\n\n# Unauthenticated Nonce Increment in snow\n\nThere was a logic bug where unauthenticated payloads could still cause a nonce\nincrement in snow's internal state. For an attacker with privileges to inject\npackets into the channel over which the Noise session operates, this could\nallow a denial-of-service attack which could prevent message delivery by\nsending garbage data.\n\nNote that this only affects those who are using the stateful TransportState,\nnot those using StatelessTransportState.\n\nThis has been patched in version 0.9.5, and all users are recommended to\nupdate.\n\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0007",
      "package": "bitvec",
      "aliases": [
        "CVE-2020-35862",
        "GHSA-7cjc-hvxf-gqh7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-03-27",
      "url": "https://github.com/myrrlyn/bitvec/issues/55"
    },
    "affected": {
      "functions": {
        "bitvec::vec::BitVec::into_boxed_bitslice": [
          "< 0.17.4, >= 0.11.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.17.4"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# use-after or double free of allocated memory\n\nConversion of `BitVec` to `BitBox` did not account for allocation movement.\n\nThe flaw was corrected by using the address after resizing, rather than the original base address.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0053",
      "package": "algorithmica",
      "date": "2021-03-07",
      "url": "https://github.com/AbrarNitk/algorithmica/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2021-31996",
        "GHSA-jh37-772x-4hpw"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# 'merge_sort::merge()' crashes with double-free for `T: Drop`\n\nIn the affected versions of this crate, `merge_sort::merge()` wildly duplicates and drops ownership of `T` without guarding against double-free. Due to such implementation,\nsimply invoking `merge_sort::merge()` on `Vec<T: Drop>` can cause **double free** bugs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0043",
      "package": "uu_od",
      "aliases": [
        "CVE-2021-29934",
        "GHSA-w9vv-q986-vj7x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-17",
      "url": "https://github.com/uutils/coreutils/issues/1729",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.0.4"
      ]
    },
    "text": "\n\n# PartialReader passes uninitialized memory to user-provided Read\n\nAffected versions of this crate passed an uniniitalized buffer to a\nuser-provided `Read` instance in `PartialReader::read`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was fixed in commit [`39d62c6`](https://github.com/uutils/coreutils/commit/39d62c6c1f809022c903180471c10fde6ecd12d1)\nby zero-initializing the passed buffer.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0094",
      "package": "reffers",
      "aliases": [
        "CVE-2020-36203",
        "GHSA-39xg-8p43-h76x"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-01",
      "url": "https://github.com/diwic/reffers-rs/issues/7",
      "informational": "unsound",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Unsound: can make `ARefss` contain a !Send, !Sync object.\n\n`ARefss<'a, V>` is a type that is assumed to contain objects that are `Send + Sync`.\n\nIn the affected versions of this crate,\n`Send`/`Sync` traits are unconditionally implemented for `ARefss<'a, V>`.\n\nBy using the `ARefss::map()` API, we can insert a `!Send` or `!Sync` object into `ARefss<'a, V>`. After that, it is possible to create a data race to the inner object of `ARefss<'a, V>`, which can lead to undefined behavior & memory corruption.\n\nThe flaw was corrected in commit 6dd7ca0 (https://github.com/diwic/reffers-rs/commit/6dd7ca0d50f2464df708975cdafcfaeeb6d41c66) by adding trait bound `V: Send + Sync` to `ARefss::map()` API.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0032",
      "package": "ntru",
      "date": "2023-03-22",
      "url": "https://github.com/FrinkGlobal/ntru-rs/issues/8",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "ffi",
        "buffer overflow"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-fq33-vmhv-48xh"
      ]
    },
    "versions": {
      "patched": []
    },
    "affected": {
      "functions": {
        "ntru::types::PrivateKey::export": [
          ">= 0.4.3"
        ],
        "ntru::types::PublicKey::export": [
          ">= 0.4.3"
        ]
      }
    },
    "text": "\n\n# Unsound FFI: Wrong API usage causes write past allocated area\n\nThe following usage causes undefined behavior.\n```rust\nlet kp: ntru::types::KeyPair = \u2026;\nkp.get_public().export(Default::default())\n```\n\nWhen compiled with debug assertions, the code above will trigger a `attempt to subtract with overflow` panic before UB occurs.\nOther mistakes (e.g. using `EncParams` from a different key) may always trigger UB.\n\nLikely, older versions of this crate are also affected, but have not been tested.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0119",
      "package": "ticketed_lock",
      "date": "2020-11-17",
      "url": "https://github.com/kvark/ticketed_lock/issues/7",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36439",
        "GHSA-77m6-x95j-75r5",
        "GHSA-gq4h-f254-7cw9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# ReadTicket and WriteTicket should only be sendable when T is Send\n\nAffected versions of this crate unconditionally implemented `Send` for `ReadTicket<T>` & `WriteTicket<T>`.\nThis allows to send non-Send `T` to other threads.\n\nThis can allows creating data races by cloning types with internal mutability and sending them to other threads (as `T` of `ReadTicket<T>`/`WriteTicket<T>`). Such data races can cause memory corruption or other undefined behavior.\n\nThe flaw was corrected in commit a986a93 by adding `T: Send` bounds to `Send` impls of `ReadTicket<T>`/`WriteTicket<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0050",
      "package": "dync",
      "aliases": [
        "CVE-2020-35903",
        "GHSA-qxjq-v4wf-ppvh"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-27",
      "informational": "unsound",
      "url": "https://github.com/elrnv/dync/issues/4"
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# VecCopy allows misaligned access to elements\n\n`VecCopy::data` is created as a Vec of u8 but can be used to store and retrieve\nelements of different types leading to misaligned access.\n\nThe issue was resolved in v0.5.0 by replacing data being stored by `Vec<u8>` with a custom managed\npointer.  Elements are now stored and retrieved using types with proper alignment corresponding to\noriginal types.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0143",
      "package": "multiqueue",
      "date": "2020-12-25",
      "url": "https://github.com/schets/multiqueue/issues/31",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36463",
        "GHSA-jf43-3v8j-qwwr",
        "GHSA-r2x6-vrxx-jgv4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Queues allow non-Send types to be sent to other threads, allowing data races\n\nAffected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0096",
      "package": "spirv_headers",
      "date": "2021-08-16",
      "url": "https://github.com/gfx-rs/rspirv/issues/197",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# spirv_headers is unmaintained, use spirv instead\n\nBecause of versioning issues; the `spirv_headers` crate is unmaintained. Use [spirv](https://crates.io/crates/spirv)\nfor parsing spirv files.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0065",
      "package": "tungstenite",
      "date": "2023-09-25",
      "url": "https://github.com/snapview/tungstenite-rs/issues/376",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2023-43669",
        "GHSA-9mcr-873m-xcxp"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.20.1"
      ]
    },
    "text": "\n\n# Tungstenite allows remote attackers to cause a denial of service\n\nThe Tungstenite crate through 0.20.0 for Rust allows remote attackers to cause\na denial of service (minutes of CPU consumption) via an excessive length of an\nHTTP header in a client handshake. The length affects both how many times a parse\nis attempted (e.g., thousands of times) and the average amount of data for each\nparse attempt (e.g., millions of bytes).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0334",
      "package": "libp2p-tokio-socks5",
      "date": "2024-04-05",
      "url": "https://github.com/comit-network/rust-libp2p-tokio-socks5/commit/e1fdc92ca69ffd254824ab80fbad5660f4aac911",
      "informational": "unmaintained",
      "license": "CC-BY-4.0"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `libp2p-tokio-socks5` is unmaintained\n\nNote the repository was archived without an issue so we link directly\nto the commit that marked the repository as unmaintained.\n\nTo the best of the original authors knowledge the crate has no\nvulnerabilities as of the last release, it is just unmaintained due to\nlaziness - new maintainer welcome.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0006",
      "package": "ncurses",
      "aliases": [
        "CVE-2019-15547",
        "CVE-2019-15548",
        "GHSA-32v7-ghpr-c8hg",
        "GHSA-g7r5-x7cr-vm3v"
      ],
      "date": "2019-06-15",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    },
    "affected": {
      "functions": {
        "ncurses::instr": [
          ">= 0"
        ],
        "ncurses::mvprintw": [
          ">= 0"
        ],
        "ncurses::mvwinstr": [
          ">= 0"
        ],
        "ncurses::mvwprintw": [
          ">= 0"
        ],
        "ncurses::printw": [
          ">= 0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Buffer overflow and format vulnerabilities in functions exposed without unsafe\n\n`ncurses` exposes functions from the ncurses library which:\n\n- Pass buffers without length to C functions that may write an arbitrary amount of\n  data, leading to a buffer overflow. (`instr`, `mvwinstr`, etc)\n- Passes rust &str to strings expecting C format arguments, allowing hostile\n  input to execute a format string attack, which trivially allows writing\n  arbitrary data to stack memory (functions in the `printw` family).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0075",
      "package": "branca",
      "aliases": [
        "CVE-2020-35918",
        "GHSA-c9rv-3jmq-527w"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-29",
      "url": "https://github.com/return/branca/issues/24",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "decoding",
        "panic",
        "untrusted data"
      ]
    },
    "affected": {
      "functions": {
        "branca::decode": [
          "< 0.10.0"
        ],
        "branca::Branca::decode": [
          "< 0.10.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.0"
      ]
    },
    "text": "\n\n# Unexpected panic when decoding tokens\n\nPrior to `0.10.0` it was possible to have both decoding functions panic unexpectedly,\nby supplying tokens with an incorrect base62 encoding.\n\nThe documentation stated that an error should have been reported instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0125",
      "package": "convec",
      "date": "2020-11-24",
      "url": "https://github.com/krl/convec/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36445",
        "GHSA-rpxm-vmr7-5f5f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# convec::ConVec<T> unconditionally implements Send/Sync\n\nAffected versions of this crate unconditionally implement Send/Sync for `ConVec<T>`.\nThis allows users to insert `T` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<_>>` or `Rc<_>` as `T` in `ConVec<T>`. It is also possible to create data races by using types like `Cell<_>` or `RefCell<_>` as `T` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0028",
      "package": "toodee",
      "aliases": [
        "CVE-2021-28028",
        "CVE-2021-28029",
        "GHSA-wcvp-r8j8-47pc",
        "GHSA-xm9m-2vj8-fmfr"
      ],
      "date": "2021-02-19",
      "url": "https://github.com/antonmarsden/toodee/issues/13",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "toodee::TooDee::insert_row": [
          "< 0.3.0"
        ]
      }
    },
    "text": "\n\n# Multiple memory safety issues in insert_row\n\nWhen inserting rows from an iterator at a particular index, `toodee` would shift\nitems over, duplicating their ownership. The space reserved for the new elements\nwas based on the `len()` returned by the `ExactSizeIterator`.\n\nThis could result in elements in the array being freed twice if the iterator\npanics. Uninitialized or previously freed elements could also be exposed if the\n`len()` didn't match the number of elements.\n\nThese issues were fixed in commit `ced70c17` by temporarily setting the length\nof the array smaller while processing it and adding assertions on the number\nof elements returned by the iterator.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0052",
      "package": "webpki",
      "date": "2023-08-22",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "certificate",
        "path building",
        "x509"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "related": [
        "CVE-2018-16875"
      ],
      "aliases": [
        "GHSA-8qv2-5vq6-g2g7"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.22.2"
      ]
    },
    "text": "\n\n# webpki: CPU denial of service in certificate path building\n\nWhen this crate is given a pathological certificate chain to validate, it will\nspend CPU time exponential with the number of candidate certificates at each\nstep of path building.\n\nBoth TLS clients and TLS servers that accept client certificate are affected.\n\nThis was previously reported in\n<https://github.com/briansmith/webpki/issues/69> and re-reported recently\nby Luke Malinowski.\n\nwebpki 0.22.1 included a partial fix and webpki 0.22.2 added further fixes.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0073",
      "package": "candid",
      "date": "2023-12-08",
      "url": "https://github.com/dfinity/candid/pull/478",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "candid",
        "canister",
        "icp"
      ],
      "aliases": [
        "CVE-2023-6245",
        "GHSA-7787-p7x6-fq3j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.9.10"
      ],
      "unaffected": [
        "< 0.9.0"
      ]
    },
    "affected": {
      "functions": {
        "candid::Decode": [
          ">= 0.9.0, < 0.9.10"
        ]
      }
    },
    "text": "\n\n# Infinite decoding loop through specially crafted payload\n\nThe Candid library causes a Denial of Service while parsing a specially crafted payload with `empty` data type. For example, if the payload is `record { * ; empty }` and  the canister interface expects `record { * }` then the rust candid decoder treats `empty` as an extra field required by the type.  The problem with type `empty` is that the candid rust library wrongly categorizes `empty` as a recoverable error when skipping the field and thus causing an infinite decoding loop. \n\nCanisters using affected versions of candid are exposed to denial of service by causing the decoding to run indefinitely until the canister traps due to reaching maximum instruction limit per execution round. Repeated exposure to the payload will result in degraded performance of the canister.\n\nFor asset canister users, `dfx` versions `>= 0.14.4` to `<= 0.15.2-beta.0` ships asset canister with an affected version of candid.\n\n### Unaffected \n- Rust canisters using candid `< 0.9.0` or `>= 0.9.10` \n- Rust canister interfaces of type other than `record { * }`\n- Motoko based canisters\n- dfx (for asset canister) `<= 0.14.3` or `>= 0.15.2`\n\n### References\n-  [GitHub Security Advisory (GHSA-7787-p7x6-fq3j)](https://github.com/dfinity/candid/security/advisories/GHSA-7787-p7x6-fq3j)\n-  [dfinity/candid/pull/478](https://github.com/dfinity/candid/pull/478)\n-  [Candid Library Reference](https://internetcomputer.org/docs/current/references/candid-ref)\n-  [Candid Specification](https://github.com/dfinity/candid/blob/master/spec/Candid.md)\n-  [Internet Computer Specification](https://internetcomputer.org/docs/current/references/ic-interface-spec)\n\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0006",
      "package": "rmpv",
      "categories": [
        "denial-of-service"
      ],
      "date": "2017-11-21",
      "keywords": [
        "memory",
        "dos",
        "msgpack",
        "serialization",
        "deserialization"
      ],
      "url": "https://github.com/3Hren/msgpack-rust/issues/151",
      "aliases": [
        "GHSA-mcrf-7hf9-f6q5"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Unchecked vector pre-allocation\n\nAffected versions of this crate pre-allocate memory on deserializing raw\nbuffers without checking whether there is sufficient data available.\n\nThis allows an attacker to do denial-of-service attacks by sending small\nmsgpack messages that allocate gigabytes of memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0032",
      "package": "byte_struct",
      "aliases": [
        "CVE-2021-28033",
        "GHSA-8fgg-5v78-6g76"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-01",
      "url": "https://github.com/wwylele/byte-struct-rs/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Deserializing an array can drop uninitialized memory on panic\n\nThe `read_bytes_default_le` function for `[T; n]` arrays, used to deserialize\narrays of `T` from bytes created a `[T; n]` array with `std::mem::uninitialized`\nand then called `T`'s deserialization method.\n\nIf `T`'s deserialization method panicked, the uninitialized memory could drop\ninvalid objects.\n\nThis flaw was corrected in `a535678` by removing the unsafe block and using\na `.map` function to deserialize each element of the array instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0109",
      "package": "ckb",
      "date": "2021-07-25",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-45p7-c959-rgcm",
      "aliases": [
        "CVE-2021-45700",
        "GHSA-45p7-c959-rgcm",
        "GHSA-cw98-cx2m-9qqg"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.40.0"
      ]
    },
    "text": "\n\n# Process crashes when the cell used as DepGroup is not alive \n\nIt's easy to create a malign transaction which uses the dead cell as the DepGroup in the DepCells. The transaction can crash all the receiving nodes.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0108",
      "package": "ckb",
      "date": "2021-07-25",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-48vq-8jqv-gm6f",
      "aliases": [
        "CVE-2021-45699",
        "GHSA-2969-8hh9-57jc",
        "GHSA-48vq-8jqv-gm6f"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.40.0"
      ]
    },
    "text": "\n\n# Remote memory exhaustion in ckb\n\nIn the ckb sync protocol, SyncState maintains a HashMap called 'misbehavior' that keeps a score of a peer's violations of the protocol. This HashMap is keyed to PeerIndex (an alias for SessionId), and entries are never removed from it. SessionId is an integer that increases monotonically with every new connection.\n\nA remote attacker can manipulate this HashMap to grow forever, resulting in degraded performance and ultimately a panic on allocation failure or being killed by the OS, depending on the platform.\n\nThis is a critical severity security bug. It could be exploited to create a targeted or network-wide denial of service, to reduce the hash power of the network as part of a 51% attack, and perhaps in other creative ways.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0107",
      "package": "ckb",
      "date": "2021-07-25",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-v666-6w97-pcwm",
      "aliases": [
        "CVE-2021-45698",
        "GHSA-8gjm-h3xj-mp6w",
        "GHSA-v666-6w97-pcwm"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.40.0"
      ]
    },
    "text": "\n\n# Miner fails to get block template when a cell used as a cell dep has been destroyed. \n\n## Impact\n\nThe RPC get_block_template fails when a cell has been used as a cell dep and an input in the different transactions.\n\nSay cell C is used as a dep group in the transaction A, and is destroyed in the transaction B.\n\nThe node adds transaction A first, then B into the transaction pool. They are both valid. But when generating the block template, if the fee rate of B is higher, it comes before A, which will invalidate A. Currently the RPC get_block_template will fail instead of dropping A.\n\n## Patch\n\nFirst, the get_block_template should not fail but dropping the conflict transactions.\n\nThen we can propose solution to this issue. Here is an example. When a transaction is added to the pool, the pool must consider it depending on all the transactions which dep cell (direct or indirect via dep group) has been destroyed in this transaction. Because future transactions using the destroyed cells as dep will be rejected, the spending transaction only need to wait for all the existing dep transactions on chain.\n\n## Workaround\n\n    Submit transaction B when A is already on chain.\n    Let B depend on A explicitly, there are several solutions:\n        a. Add any output cell on A as a dep cell or input in B.\n        b. Merge A and B. CKB allows using the same cell as both dep and input in the same transaction.\n    Ensure the fee rate of B is less than A so A always has higher priority.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0091",
      "package": "arc-swap",
      "date": "2020-12-10",
      "url": "https://github.com/vorner/arc-swap/issues/45",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "dangling reference"
      ],
      "aliases": [
        "CVE-2020-35711",
        "GHSA-9pqx-g3jh-qpqq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.8, < 1.0.0-0",
        ">= 1.1.0"
      ],
      "unaffected": [
        "< 0.4.2"
      ]
    },
    "affected": {
      "functions": {
        "arc_swap::access::MapGuard::deref": [
          "< 1.1.0"
        ]
      }
    },
    "text": "\n\n# Dangling reference in `access::Map` with Constant\n\nUsing the `arc_swap::access::Map` with the `Constant` test helper (or with\nuser-provided implementation of the `Access` trait) could sometimes lead to the\nmap returning dangling references.\n\nReplaced by implementation without `unsafe`, at the cost of added `Clone` bound\non the closure and small penalty on performance.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0113",
      "package": "atomic-option",
      "aliases": [
        "CVE-2020-36219",
        "GHSA-8gf5-q9p9-wvmc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-31",
      "url": "https://github.com/reem/rust-atomic-option/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# AtomicOption should have Send + Sync bound on its type argument.\n\nIn the affected versions of this crate,\n`AtomicOption<T>` unconditionally implements `Sync`.\n\nThis allows programmers to move non-Sync types across thread boundaries (e.g. `Rc<T>`, `Arc<Cell<T>>`), which can lead to data races and undefined behavior. \nIt is also possible to send non-Send types like `std::sync::MutexGuard` to other threads, which can lead to undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0370",
      "package": "proc-macro-error",
      "date": "2024-09-01",
      "informational": "unmaintained",
      "url": "https://gitlab.com/CreepySkeleton/proc-macro-error/-/issues/20"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# proc-macro-error is unmaintained\n\nproc-macro-error's maintainer seems to be unreachable, with no commits for 2 years, no releases pushed for 4 years, and no activity on the GitLab repo or response to email.\n\nproc-macro-error also depends on `syn 1.x`, which may be bringing duplicate dependencies into dependant build trees.\n\n## Possible Alternative(s)\n\n- [manyhow](https://crates.io/crates/manyhow)\n- [proc-macro-error2](https://crates.io/crates/proc-macro-error2)\n- [proc-macro2-diagnostics](https://github.com/SergioBenitez/proc-macro2-diagnostics)"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0140",
      "package": "model",
      "date": "2020-11-10",
      "url": "https://github.com/spacejam/model/issues/3",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36460",
        "GHSA-mxv6-q98x-h958"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Shared` can cause a data race\n\n`Shared` data structure in `model` crate implements `Send` and `Sync` traits regardless of the inner type.\nThis allows safe Rust code to trigger a data race, which is undefined behavior in Rust.\n\nUsers are advised to treat `Shared` as an unsafe type.\nIt should not be used outside of the testing context,\nand care must be taken so that the testing code does not have a data race\nbesides a race condition that is expected to be caught by the test.\n\nCheck [the Rustonomicon](https://doc.rust-lang.org/nomicon/races.html) for the difference between\na data race and a general race condition.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0150",
      "package": "ncollide3d",
      "date": "2021-01-29",
      "url": "https://github.com/dimforge/ncollide",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# ncollide3d is unmaintained\n\nThe maintainer has advised that this crate is passively-maintained and that it\nis being superseded by the [Parry](https://github.com/dimforge/parry) project.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0030",
      "package": "mozwire",
      "aliases": [
        "CVE-2020-35883",
        "GHSA-4vhw-4rw7-jfpv"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
      "categories": [],
      "date": "2020-08-18",
      "keywords": [
        "file-overwrite"
      ],
      "url": "https://github.com/NilsIrl/MozWire/issues/14"
    },
    "versions": {
      "patched": [
        "> 0.4.1"
      ]
    },
    "text": "\n\n# Missing sanitization in mozwire allows local file overwrite of files ending in .conf\n\nThe client software downloaded a list of servers from mozilla's servers and created local files named\nafter the hostname field in the json document.\n\nNo verification of the content of the string was made, and it could therefore have included '../' leading to path traversal.\n\nThis allows an attacker in control of mozilla's servers to overwrite/create local files named .conf.\n\nThe flaw was corrected by sanitizing the hostname field.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0030",
      "package": "scratchpad",
      "aliases": [
        "CVE-2021-28031",
        "GHSA-3qm2-rfqw-fmrw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-18",
      "url": "https://github.com/okready/scratchpad/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.3.1"
      ]
    },
    "affected": {
      "functions": {
        "scratchpad::SliceMoveSource::move_elements": [
          "< 1.3.1"
        ]
      }
    },
    "text": "\n\n# move_elements can double-free objects on panic\n\nAffected versions of `scratchpad` used `ptr::read` to read elements while\ncalling a user provided function `f` on them.\n\nSince the pointer read duplicates ownership, a panic inside the user provided\n`f` function could cause a double free when unwinding.\n\nThe flaw was fixed in commit `891561bea` by removing the unsafe block and using\na plain iterator.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0017",
      "package": "once_cell",
      "aliases": [
        "CVE-2019-16141",
        "GHSA-7j44-fv4x-79g9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-09-01",
      "keywords": [
        "undefined_behavior"
      ],
      "url": "https://github.com/matklad/once_cell/issues/46"
    },
    "affected": {
      "functions": {
        "once_cell::sync::Lazy::deref": [
          "< 1.0.1, >= 0.2.5"
        ],
        "once_cell::sync::Lazy::force": [
          "< 1.0.1, >= 0.2.5"
        ],
        "once_cell::unsync::Lazy::deref": [
          "< 1.0.1, >= 0.2.5"
        ],
        "once_cell::unsync::Lazy::force": [
          "< 1.0.1, >= 0.2.5"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.0.1"
      ],
      "unaffected": [
        "< 0.2.5"
      ]
    },
    "text": "\n\n# Panic during initialization of Lazy<T> might trigger undefined behavior\n\nIf during the first dereference of Lazy<T> the initialization function panics,\nsubsequent dereferences will execute `std::hints::unreachable_unchecked`.\n\nApplications with `panic = \"abort\"` are not affected, as there will be no\nsubsequent dereferences.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0012",
      "package": "smallvec",
      "aliases": [
        "CVE-2019-15554",
        "GHSA-69gw-hgj3-45m7"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "date": "2019-07-19",
      "url": "https://github.com/servo/rust-smallvec/issues/149"
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::grow": [
          "< 0.6.10, >= 0.6.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.10"
      ],
      "unaffected": [
        "< 0.6.3"
      ]
    },
    "text": "\n\n# Memory corruption in SmallVec::grow()\n\nAttempting to call `grow` on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0009",
      "package": "smallvec",
      "aliases": [
        "CVE-2019-15551",
        "GHSA-mm7v-vpv8-xfc3"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-06-06",
      "keywords": [
        "double free",
        "use after free",
        "arbitrary code execution"
      ],
      "url": "https://github.com/servo/rust-smallvec/issues/148"
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::grow": [
          "< 0.6.10, >= 0.6.5"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.10"
      ],
      "unaffected": [
        "< 0.6.5"
      ]
    },
    "text": "\n\n# Double-free and use-after-free in SmallVec::grow()\n\nAttempting to call `grow` on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0003",
      "package": "smallvec",
      "aliases": [
        "CVE-2018-20991",
        "GHSA-rxr4-x558-x7hw"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-07-19",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/servo/rust-smallvec/issues/96"
    },
    "versions": {
      "patched": [
        ">= 0.6.3",
        "^0.3.4",
        "^0.4.5",
        "^0.5.1"
      ],
      "unaffected": [
        "< 0.3.2"
      ]
    },
    "text": "\n\n# Possible double free during unwinding in SmallVec::insert_many\n\nIf an iterator passed to `SmallVec::insert_many` panicked in `Iterator::next`,\ndestructors were run during unwinding while the vector was in an inconsistent\nstate, possibly causing a double free (a destructor running on two copies of\nthe same value).\n\nThis is fixed in smallvec 0.6.3 by ensuring that the vector's length is not\nupdated to include moved items until they have been removed from their\noriginal positions.  Items may now be leaked if `Iterator::next` panics, but\nthey will not be dropped more than once.\n\nThank you to @Vurich for reporting this bug.\n"
  },
  {
    "advisory": {
      "date": "2018-09-25",
      "id": "RUSTSEC-2018-0018",
      "package": "smallvec",
      "informational": "unsound",
      "url": "https://github.com/servo/rust-smallvec/issues/126",
      "aliases": [
        "CVE-2018-25023",
        "GHSA-55m5-whcv-c49c",
        "GHSA-66p5-j55p-32r9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.13"
      ]
    },
    "text": "\n\n# smallvec creates uninitialized value of any type\n\nAffected versions of this crate called `mem::uninitialized()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null and thus may not remain uninitialized).\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0003",
      "package": "smallvec",
      "aliases": [
        "CVE-2021-25900",
        "GHSA-43w2-9j62-hq99"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-08",
      "url": "https://github.com/servo/rust-smallvec/issues/252",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "buffer-overflow",
        "heap-overflow",
        "unsound"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.14, < 1.0.0",
        ">= 1.6.1"
      ],
      "unaffected": [
        "< 0.6.3"
      ]
    },
    "affected": {
      "functions": {
        "smallvec::SmallVec::insert_many": [
          ">= 0.6.3, < 0.6.14",
          ">= 1.0.0, < 1.6.1"
        ]
      }
    },
    "text": "\n\n# Buffer overflow in SmallVec::insert_many\n\nA bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.\n\nThis bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.\n \nThe flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.\n\nThank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Tech\u2019s SSLab for finding and reporting this bug.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0065",
      "package": "anymap",
      "date": "2021-05-07",
      "informational": "unmaintained",
      "url": "https://github.com/chris-morgan/anymap/issues/37",
      "aliases": [
        "CVE-2021-38187",
        "GHSA-hc92-9h3m-c39j"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# anymap is unmaintained.\n\nThe `anymap` crate does not appear to be maintained, and the most recent\npublished version 0.12.1 includes a soundness bug. This has been\n[fixed](https://github.com/chris-morgan/anymap/pull/32) a few years ago, but\nwas never released.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0146",
      "package": "generic-array",
      "date": "2020-04-09",
      "url": "https://github.com/fizyk20/generic-array/issues/98",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "soundness"
      ],
      "aliases": [
        "CVE-2020-36465",
        "GHSA-3358-4f7f-p4j4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.8.4, < 0.9.0",
        ">= 0.9.1, < 0.10.0",
        ">= 0.10.1, < 0.11.0",
        ">= 0.11.2, < 0.12.0",
        ">= 0.12.4, < 0.13.0",
        ">= 0.13.3"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n\n# arr! macro erases lifetimes\n\nAffected versions of this crate allowed unsoundly extending\nlifetimes using `arr!` macro. This may result in a variety of\nmemory corruption scenarios, most likely use-after-free.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0149",
      "package": "nphysics2d",
      "date": "2021-01-29",
      "url": "https://github.com/dimforge/nphysics",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# nphysics2d is unmaintained\n\nThe maintainer has advised that this crate is passively-maintained and that it\nis being superseded by the [Rapier](https://github.com/dimforge/rapier) project.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0013",
      "package": "safe-transmute",
      "aliases": [
        "CVE-2018-21000",
        "GHSA-2v78-j59h-fmpf"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-11-27",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/nabijaczleweli/safe-transmute-rs/pull/36"
    },
    "versions": {
      "patched": [
        ">= 0.10.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Vec-to-vec transmutations could lead to heap overflow/corruption\n\nAffected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor,\nwhich could lead to memory corruption or data leakage.\n\nThe flaw was corrected by using the constructor correctly.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0001",
      "package": "lmdb",
      "date": "2022-01-05",
      "url": "https://github.com/danburkert/lmdb-rs",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# lmdb is unmaintained, use lmdb-rkv instead\n\nThe lmdb crate hasn't had any updates since August 2018.\n\nMozilla's [lmdb-rkv](https://github.com/mozilla/lmdb-rs) fork of the crate has received additional maintenance work beyond that and is the best available replacement.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0076",
      "package": "routing",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_routing/pull/2190"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_routing`\n\nThis crate has been renamed from `routing` to `sn_routing`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_routing>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0020",
      "package": "whoami",
      "date": "2024-02-28",
      "url": "https://github.com/ardaku/whoami/issues/91",
      "categories": [
        "denial-of-service",
        "memory-corruption"
      ],
      "keywords": [
        "buffer-overflow",
        "stack-buffer-overflow",
        "cwe-121"
      ],
      "aliases": [
        "GHSA-w5w5-8vfh-xcjq"
      ]
    },
    "affected": {
      "os": [
        "illumos",
        "solaris",
        "dragonfly",
        "freebsd",
        "netbsd",
        "openbsd"
      ],
      "functions": {
        "whoami::username": [
          "< 1.5.0"
        ],
        "whoami::realname": [
          "< 1.5.0"
        ],
        "whoami::username_os": [
          "< 1.5.0"
        ],
        "whoami::realname_os": [
          "< 1.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.5.0"
      ],
      "unaffected": [
        "< 0.5.3"
      ]
    },
    "text": "\n\n# Stack buffer overflow with whoami on several Unix platforms\n\nWith versions of the whoami crate >= 0.5.3 and < 1.5.0, calling any of these functions leads to an\nimmediate stack buffer overflow on illumos and Solaris:\n\n- `whoami::username`\n- `whoami::realname`\n- `whoami::username_os`\n- `whoami::realname_os`\n\nWith versions of the whoami crate >= 0.5.3 and < 1.0.1, calling any of the above functions also\nleads to a stack buffer overflow on these platforms:\n\n- Bitrig\n- DragonFlyBSD\n- FreeBSD\n- NetBSD\n- OpenBSD\n\nThis occurs because of an incorrect definition of the `passwd` struct on those platforms.\n\nAs a result of this issue, denial of service and data corruption have both been observed in the\nwild. The issue is possibly exploitable as well.\n\nThis vulnerability also affects other Unix platforms that aren't Linux or macOS.\n\nThis issue has been addressed in whoami 1.5.0.\n\nFor more information, see [this GitHub issue](https://github.com/ardaku/whoami/issues/91).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0012",
      "package": "os_str_bytes",
      "aliases": [
        "CVE-2020-35865",
        "GHSA-q948-x8rf-888m"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-04-24",
      "url": "https://github.com/dylni/os_str_bytes/pull/1"
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# Relies on undefined behavior of `char::from_u32_unchecked`\n\nThe Windows implementation of this crate relied on the behavior of\n`std::char::from_u32_unchecked` when its safety clause is violated.\nEven though this worked with Rust versions up to 1.42 (at least),\nthat behavior could change with any new Rust version, possibly leading\na security issue.\n\nThe flaw was corrected in version 2.0.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0050",
      "package": "multipart",
      "date": "2023-04-11",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# multipart is Unmaintained\n\nThe `multipart` crate is unmaintained. The author has archived the github\nrepository.\n\nAlternatives:\n\n- [multer](https://crates.io/crates/multer)\n- [multiparty](https://crates.io/crates/multiparty)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0066",
      "package": "pleaser",
      "aliases": [
        "CVE-2023-46277",
        "GHSA-cgf8-h3fp-h956"
      ],
      "date": "2023-04-29",
      "url": "https://gitlab.com/edneville/please/-/issues/13",
      "categories": [
        "privilege-escalation"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N"
    },
    "versions": {
      "patched": []
    },
    "affected": {},
    "text": "\n\n# Vulnerable to privilege escalation using ioctls TIOCSTI and TIOCLINUX\n\nplease is vulnerable to privilege escalation using ioctls TIOCSTI\nand TIOCLINUX on systems where they are not disabled.\n\nHere is how to see it in action:\n\n```\n$ cd \"$(mktemp -d)\"\n$ git clone --depth 1 https://gitlab.com/edneville/please.git\n$ cd please/\n$ git rev-parse HEAD  # f3598f8fae5455a8ecf22afca19eaba7be5053c9\n$ cargo test && cargo build --release\n$ echo \"[${USER}_as_nobody]\"$'\\nname='\"${USER}\"$'\\ntarget=nobody\\nrule=.*\\nrequire_pass=false' | sudo tee /etc/please.ini\n$ sudo chown root:root ./target/release/please\n$ sudo chmod u+s ./target/release/please\n$ cat <<TIOCSTI_C_EOF | tee TIOCSTI.c\n#include <sys/ioctl.h>\n\nint main(void) {\n  const char *text = \"id\\n\";\n  while (*text)\n    ioctl(0, TIOCSTI, text++);\n  return 0;\n}\nTIOCSTI_C_EOF\n$ gcc -std=c99 -Wall -Wextra -pedantic -o /tmp/TIOCSTI TIOCSTI.c\n$ ./target/release/please -u nobody /tmp/TIOCSTI  # runs id(1) as ${USER} rather than nobody\n```\n\nPlease note that:\n\nThis affects both the case where root wants to drop privileges as well when non-root wants to gain other privileges.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0101",
      "package": "pleaser",
      "date": "2021-05-27",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31155",
      "categories": [
        "privilege-escalation"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "aliases": [
        "CVE-2021-31155",
        "GHSA-vc5p-j8vw-mc6x"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4"
      ]
    },
    "text": "\n\n# Permissions bypass in pleaser \n\nFailure to normalize the umask in pleaser before 0.4 allows a local attacker to gain full root privileges if they are allowed to execute at least one command.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0104",
      "package": "pleaser",
      "date": "2021-05-27",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31153",
      "categories": [
        "file-disclosure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
      "aliases": [
        "CVE-2021-31153",
        "GHSA-f3fg-5j9p-vchc"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4"
      ]
    },
    "text": "\n\n# File exposure in pleaser\n\npleaser before 0.4 allows a local unprivileged attacker to gain knowledge about the existence of files or directories in privileged locations via the search_path function, the --check option, or the -d option.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0102",
      "package": "pleaser",
      "date": "2021-05-27",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31154",
      "categories": [
        "privilege-escalation"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "aliases": [
        "CVE-2021-31154",
        "GHSA-pp74-39w2-v4w9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4"
      ]
    },
    "text": "\n\n# Permissions bypass in pleaser\n\npleaseedit in pleaser before 0.4 uses predictable temporary filenames in /tmp and the target directory. This allows a local attacker to gain full root privileges by staging a symlink attack.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0071",
      "package": "rsa",
      "date": "2023-11-22",
      "keywords": [
        "cryptography"
      ],
      "categories": [
        "crypto-failure"
      ],
      "url": "https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643",
      "references": [
        "https://people.redhat.com/~hkario/marvin/"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "aliases": [
        "CVE-2023-49092",
        "GHSA-c38w-74pg-36hr",
        "GHSA-4grx-2x9w-596c"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Marvin Attack: potential key recovery through timing sidechannels\n\n### Impact\nDue to a non-constant-time implementation, information about the private key is leaked through timing information which is observable over the network. An attacker may be able to use that information to recover the key.\n\n### Patches\nNo patch is yet available, however work is underway to migrate to a fully constant-time implementation.\n\n### Workarounds\nThe only currently available workaround is to avoid using the `rsa` crate in settings where attackers are able to observe timing information, e.g. local use on a non-compromised computer is fine.\n\n### References\nThis vulnerability was discovered as part of the \"[Marvin Attack]\", which revealed several implementations of RSA including OpenSSL had not properly mitigated timing sidechannel attacks.\n\n[Marvin Attack]: https://people.redhat.com/~hkario/marvin/\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0018",
      "package": "block-cipher-trait",
      "date": "2020-05-26",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/traits/pull/139"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `block-cipher`\n\nThis crate has been renamed from `block-cipher-trait` to `block-cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/block-cipher>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0035",
      "package": "rand_core",
      "aliases": [
        "GHSA-mmc9-pwm7-qj5w",
        "CVE-2020-25576"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-04-19",
      "informational": "unsound",
      "url": "https://github.com/rust-random/rand/blob/master/rand_core/CHANGELOG.md#050---2019-06-06"
    },
    "affected": {
      "functions": {
        "rand_core::BlockRng::fill_bytes": [
          "< 0.4.2"
        ],
        "rand_core::BlockRng::next_u64": [
          "< 0.4.2"
        ]
      }
    },
    "versions": {
      "patched": [
        "^ 0.3.1",
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Unaligned memory access\n\nAffected versions of this crate violated alignment when casting byte slices to\ninteger slices, resulting in undefined behavior.\n\nThe flaw was corrected by Ralf Jung and Diggory Hardy.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0023",
      "package": "rand_core",
      "aliases": [
        "CVE-2021-27378",
        "GHSA-w7j2-35mf-95p7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-12",
      "url": "https://github.com/rust-random/rand/pull/1096",
      "categories": [
        "crypto-failure"
      ],
      "keywords": []
    },
    "affected": {
      "functions": {
        "rand_core::le::read_u32_into": [
          "< 0.6.2, >= 0.6.0"
        ],
        "rand_core::le::read_u64_into": [
          "< 0.6.2, >= 0.6.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ],
      "unaffected": [
        "< 0.6.0"
      ]
    },
    "text": "\n\n# Incorrect check on buffer length when seeding RNGs\n\nSummary: rand_core::le::read_u32_into and read_u64_into have incorrect checks on the source buffer length, allowing the destination buffer to be under-filled.\n\nImplications: some downstream RNGs, including Hc128Rng (but not the more widely used ChaCha*Rng), allow seeding using the SeedableRng::from_seed trait-function with too short keys.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0015",
      "package": "compact_arena",
      "aliases": [
        "CVE-2019-16139",
        "GHSA-7j36-gc4r-9x3r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-05-21",
      "keywords": [
        "uninitialized-memory"
      ],
      "url": "https://github.com/llogiq/compact_arena/issues/22"
    },
    "affected": {
      "functions": {
        "compact_arena::SmallArena::new": [
          "< 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Flaw in generativity allows out-of-bounds access\n\nAffected versions of this crate did not properly implement the generativity,\nbecause the invariant lifetimes were not necessarily `drop`ped.\n\nThis allows an attacker to mix up two arenas, using indices created from one\narena with another one. This might lead to an out-of-bounds read or write\naccess into the memory reserved for the arena.\n\nThe flaw was corrected by implementing generativity correctly in version 0.4.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0041",
      "package": "sized-chunks",
      "aliases": [
        "CVE-2020-25791",
        "CVE-2020-25792",
        "CVE-2020-25793",
        "CVE-2020-25794",
        "CVE-2020-25795",
        "CVE-2020-25796",
        "GHSA-64gv-qg2v-vxv6",
        "GHSA-9p9m-9xww-qjcx",
        "GHSA-fqpx-cq8x-9wp4",
        "GHSA-mp6f-p9gp-vpj9",
        "GHSA-rfgg-vccr-m46m",
        "GHSA-x54v-qxxr-93qc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-06",
      "url": "https://github.com/bodil/sized-chunks/issues/11"
    },
    "versions": {
      "patched": [
        ">= 0.6.3"
      ]
    },
    "text": "\n\n# Multiple soundness issues in Chunk and InlineArray\n\nChunk:\n\n* Array size is not checked when constructed with `unit()` and `pair()`.\n* Array size is not checked when constructed with `From<InlineArray<A, T>>`.\n* `Clone` and `insert_from` are not panic-safe; A panicking iterator causes memory safety issues with them.\n\nInlineArray:\n\n* Generates unaligned references for types with a large alignment requirement.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0020",
      "package": "libpulse-binding",
      "date": "2018-12-22",
      "url": "https://github.com/advisories/GHSA-6gvc-4jvj-pwq4",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2018-25001",
        "GHSA-6gvc-4jvj-pwq4",
        "GHSA-f56g-chqp-22m9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N"
    },
    "versions": {
      "patched": [
        ">= 2.5.0"
      ],
      "unaffected": [
        "< 1.0.5"
      ]
    },
    "text": "\n\n# Possible use-after-free with `proplist::Iterator`\n\nAffected versions contained a possible use-after-free issue with property list iteration\ndue to a lack of a lifetime constraint tying the lifetime of a `proplist::Iterator` to the\n`Proplist` object for which it was created. This made it possible for users, without\nexperiencing a compiler error/warning, to destroy the `Proplist` object before the iterator,\nthus destroying the underlying C object the iterator works upon, before the iterator may be\nfinished with it.\n\nThis impacts all versions of the crate before `2.5.0` back to `1.0.5`. Before version\n`1.0.5` the function that produces the iterator was broken to the point of being useless.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0021",
      "package": "libpulse-binding",
      "date": "2018-06-15",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2018-25027",
        "CVE-2018-25028",
        "GHSA-ghpq-vjxw-ch5w",
        "GHSA-hxjf-h2mh-r6hj",
        "GHSA-jqpv-jm4m-86j9"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.1"
      ]
    },
    "affected": {
      "functions": {
        "libpulse_binding::stream::Stream::get_format_info": [
          "< 1.2.1"
        ],
        "libpulse_binding::stream::Stream::get_context": [
          "< 1.2.1"
        ]
      }
    },
    "text": "\n\n# Use-after-free with objects returned by `Stream`'s `get_format_info` and `get_context` methods\n\nAffected versions contained a pair of use-after-free issues with the objects returned by the `get_format_info` and `get_context` methods of `Stream` objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0038",
      "package": "libpulse-binding",
      "date": "2019-03-10",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2019-25055",
        "GHSA-wcxc-jf6c-8rx9",
        "GHSA-xvcg-2q82-r87j"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.6.0"
      ]
    },
    "text": "\n\n# Fix for UB in failure to catch panics crossing FFI boundaries\n\nAffected versions of this crate failed to catch panics crossing FFI boundaries via callbacks, which\nis a form of UB. This flaw was corrected by [this commit][1] which was included in version 2.6.0.\n\n[1]: https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0055",
      "package": "libpulse-binding",
      "date": "2020-10-21",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0020.html",
      "withdrawn": "2020-10-22"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0"
      ]
    },
    "text": "\n\n# Please see RUSTSEC-2018-0020\n\nThis vulnerability was misfiled under the wrong year and has been withdrawn.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0034",
      "package": "pkcs11",
      "date": "2022-07-22",
      "url": "https://github.com/mheese/rust-pkcs11/issues/57",
      "categories": [
        "code-execution",
        "memory-corruption",
        "crypto-failure"
      ],
      "keywords": [
        "segfault",
        "undefined behaviour"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# Safety issues in `pkcs11`\n\n### Impact\n\nThe interface of `pkcs11` is subject to a number of safety issues, mainly related to handling of raw pointers. Despite presenting a safe interface, many of the functions and methods that rely on inputs which contain pointers (attributes and mechanisms in particular) can lead to segmentation faults and undefined behaviour when those pointers get dereferenced. For more details see the issues referenced below.\n\nOther problems that have been identified by the community include use-after-free ([mheese/rust-pkcs11#53](https://github.com/mheese/rust-pkcs11/pull/53)) and unsound uses of `transmute_copy` ([mheese/rust-pkcs11#55](https://github.com/mheese/rust-pkcs11/issues/55)).\n\n### Workarounds\n\nUsers of the crate need to be _extremely_ careful in all the calls made to avoid segmentation faults and undefined behaviour due to use of stale pointers. Whenever a pointer is derived from a value and passed to the library, that value's lifetime must be guaranteed to outlast all calls that rely on the pointer. For example, users should **avoid** creating or converting values within a separate scope (say, in a dedicated function), deriving a pointer, then extracting the pointer from that scope leaving the value to get dropped before passing the pointer to `pkcs11`.\n\n### References\n\n- [mheese/rust-pkcs11#38](https://github.com/mheese/rust-pkcs11/issues/38)\n- [mheese/rust-pkcs11#53](https://github.com/mheese/rust-pkcs11/pull/53)\n- [mheese/rust-pkcs11#55](https://github.com/mheese/rust-pkcs11/issues/55)\n- [mheese/rust-pkcs11#54](https://github.com/mheese/rust-pkcs11/issues/54)\n- [mheese/rust-pkcs11#50](https://github.com/mheese/rust-pkcs11/issues/50)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0115",
      "package": "zeroize_derive",
      "date": "2021-09-24",
      "url": "https://github.com/iqlusioninc/crates/issues/876",
      "aliases": [
        "CVE-2021-45706",
        "GHSA-c5hx-w945-j4pq"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.1"
      ]
    },
    "text": "\n\n# `#[zeroize(drop)]` doesn't implement `Drop` for `enum`s\n\nAffected versions of this crate did not implement `Drop` when `#[zeroize(drop)]` was used on an `enum`.\n\nThis can result in memory not being zeroed out after dropping it, which is exactly what is intended when adding this attribute.\n\nThe flaw was corrected in version 1.2 and `#[zeroize(drop)]` on `enum`s now properly implements `Drop`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0150",
      "package": "disrustor",
      "date": "2020-12-17",
      "url": "https://github.com/sklose/disrustor/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36470",
        "GHSA-w9r2-qrpm-4rmj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3"
      ]
    },
    "text": "\n\n# RingBuffer can create multiple mutable references and cause data races\n\nThe `RingBuffer` type retrieves mutable references from the `DataProvider` in a\nnon-atomic manner, potentially allowing the creation of multiple mutable\nreferences. `RingBuffer` also implements the `Send` and `Sync` traits for all\ntypes `T`.\n\nThis allows undefined behavior from the aliased mutable references as well\nas data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0354",
      "package": "vodozemac",
      "date": "2024-07-17",
      "url": "https://github.com/matrix-org/vodozemac/security/advisories/GHSA-j8cm-g7r6-hfpq",
      "categories": [
        "crypto-failure",
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2024-40640",
        "GHSA-j8cm-g7r6-hfpq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n#  Usage of non-constant time base64 decoder could lead to leakage of secret key material \n\nVersions before 0.7.0 of vodozemac use a non-constant time base64 implementation\nfor importing key material for Megolm group sessions and `PkDecryption` Ed25519\nsecret keys. This flaw might allow an attacker to infer some information about\nthe secret key material through a side-channel attack.\n\n## Impact\n\nThe use of a non-constant time base64 implementation might allow an attacker to\nobserve timing variations in the encoding and decoding operations of the secret\nkey material. This could potentially provide insights into the underlying secret\nkey material.\n\nThe impact of this vulnerability is considered low because exploiting the\nattacker is required to have access to high precision timing measurements, as\nwell as repeated access to the base64 encoding or decoding processes.\nAdditionally, the estimated leakage amount is bounded and low according to the\nreferenced paper[[1]].\n\n[1]: https://arxiv.org/abs/2108.04600\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0342",
      "package": "vodozemac",
      "date": "2024-05-02",
      "url": "https://github.com/matrix-org/vodozemac/security/advisories/GHSA-c3hm-hxwf-g5c6",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2024-34063",
        "GHSA-c3hm-hxwf-g5c6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.0"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "text": "\n\n# Degraded secret zeroization capabilities \n\nVersions 0.5.0 and 0.5.1 of vodozemac have degraded secret zeroization capabilities,\ndue to changes in third-party cryptographic dependencies (the Dalek crates),\nwhich moved secret zeroization capabilities behind a feature flag while\nvodozemac disabled the default feature set.\n\n## Impact\n\nThe degraded zeroization capabilities could result in the production of more\nmemory copies of encryption secrets and secrets could linger in memory longer\nthan necessary. This marginally increases the risk of sensitive data exposure.\n\nOverall, we consider the impact of this issue to be low. Although cryptographic\nbest practices recommend the clearing of sensitive information from memory once\nit's no longer needed, the inherent limitations of Rust regarding absolute\nzeroization reduce the practical severity of this lapse.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0046",
      "package": "actix-service",
      "aliases": [
        "CVE-2020-35899",
        "GHSA-whc7-5p35-4ww2"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-08",
      "informational": "unsound",
      "url": "https://github.com/actix/actix-net/pull/158"
    },
    "versions": {
      "patched": [
        ">= 1.0.6"
      ]
    },
    "text": "\n\n# bespoke Cell implementation allows obtaining several mutable references to the same data\n\nThe custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0049",
      "package": "through",
      "aliases": [
        "CVE-2021-29940",
        "GHSA-5hpj-m323-cphm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-18",
      "url": "https://github.com/gretchenfrage/through/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `through` and `through_and` causes a double free if the map function panics\n\n`through` and `through_and` take a mutable reference as well as a mapping\nfunction to change the provided reference. They do this by calling `ptr::read`\non the reference which duplicates ownership and then calling the mapping\nfunction.\n\nIf the mapping function panics, both the original object and the one\nduplicated by `ptr::read` get dropped, causing a double free.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0078",
      "package": "tracing",
      "date": "2023-10-19",
      "url": "https://github.com/tokio-rs/tracing/pull/2765",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ],
      "aliases": [
        "GHSA-8f24-6m29-wm2r"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.40"
      ],
      "unaffected": [
        "<= 0.1.37"
      ]
    },
    "affected": {
      "functions": {
        "tracing::instrument::Instrumented::into_inner": [
          ">= 0.1.38",
          "< 0.1.40"
        ]
      }
    },
    "text": "\n\n# Potential stack use-after-free in `Instrumented::into_inner`\n\nThe implementation of the [`Instrumented::into_inner`] method in affected\nversions of this crate contains undefined behavior due to incorrect use of\n[`std::mem::forget`] The function creates `*const` pointers to `self`, calls\n[`mem::forget(self)`][`std::mem::forget`], and then moves values out of those\npointers using [`std::ptr::read`].\n\n```rust\n// To manually destructure `Instrumented` without `Drop`, we\n// move it into a ManuallyDrop and use pointers to its fields\nlet span: *const Span = &this.span;\nlet inner: *const ManuallyDrop<T> = &this.inner;\nmem::forget(self);\n// SAFETY: Those pointers are valid for reads, because `Drop` didn't\n//         run, and properly aligned, because `Instrumented` isn't\n//         `#[repr(packed)]`.\nlet _span = unsafe { span.read() };\nlet inner = unsafe { inner.read() };\n```\n\nHowever, the [`mem::forget` documentation][`std::mem::forget`] states:\n\n> Any resources the value manages, such as heap memory or a file handle, will\n> linger forever in an unreachable state. **However, it does not guarantee that\n> pointers to this memory will remain valid.**\n\nThis means that these pointers are no longer valid. This could result in a stack\nuse-after-free if LLVM chooses to reuse `self`'s stack slot for a rebinding\nafter the call to [`std::mem::forget`].\n\nThis undefined behavior has not been observed to cause miscompilation as of Rust\n1.73.0. However, any use of this method with the affected versions of `tracing`\nare unsound.\n\nThe flaw was corrected in commit [20a1762] ([PR #2765]) by replacing the use of\n[`std::mem::forget`] with `std::mem::ManuallyDrop`, ensuring that the stack slot\nis not reused and the pointers remain valid when they are read. The fix is\npublished in `tracing` [v0.1.40]. Affected versions have been yanked from\ncrates.io.\n\nThanks to [Taylor Cramer] and [Manish Goregaokar] for finding and correcting\nthis issue!\n\n[`Instrumented::into_inner`]:\n    https://docs.rs/tracing/latest/tracing/instrument/struct.Instrumented.html#method.into_inner\n[`std::mem::forget`]: https://doc.rust-lang.org/std/mem/fn.forget.html\n[`std::ptr::read`]:\n    https://doc.rust-lang.org/std/primitive.pointer.html#method.read-1\n[20a1762]:\n    https://github.com/tokio-rs/tracing/commit/20a1762b3fd5f1fafead198fd18e469c68683721\n[PR #2765]: https://github.com/tokio-rs/tracing/pull/2765\n[v0.1.40]: https://crates.io/crates/tracing/0.1.40\n[Taylor Cramer]: https://github.com/cramertj\n[Manish Goregaokar]: https://github.com/manishearth\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0075",
      "package": "ark-r1cs-std",
      "date": "2021-07-08",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "r1cs",
        "zksnark",
        "arkworks"
      ],
      "url": "https://github.com/arkworks-rs/r1cs-std/pull/70",
      "aliases": [
        "CVE-2021-38194",
        "GHSA-qj3v-q2vj-4c8h"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "affected": {
      "functions": {
        "ark_r1cs_std::FieldVar::mul_by_inverse": [
          "< 0.3.0"
        ]
      }
    },
    "text": "\n\n# Flaw in `FieldVar::mul_by_inverse` allows unsound R1CS constraint systems\n\nVersions `0.2.0` to `0.3.0` of ark-r1cs-std did not enforce any constraints in the `FieldVar::mul_by_inverse` method, allowing a malicious prover to produce an unsound proof that passes all verifier checks.\nThis method was used primarily in scalar multiplication for [`short_weierstrass::ProjectiveVar`](https://docs.rs/ark-r1cs-std/0.3.0/ark_r1cs_std/groups/curves/short_weierstrass/struct.ProjectiveVar.html).\n\nThis bug was fixed in commit `47ddbaa`, and was released as part of version `0.3.1` on `crates.io`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0005",
      "package": "ftd2xx-embedded-hal",
      "date": "2022-01-22",
      "informational": "unmaintained",
      "url": "https://github.com/newAM/ftd2xx-embedded-hal/pull/40"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `ftdi-embedded-hal`\n\nThis crate has been renamed from `ftd2xx-embedded-hal` to `ftdi-embedded-hal`.\n\nThe new repository location is:\n\n<https://github.com/ftdi-rs/ftdi-embedded-hal>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0070",
      "package": "lock_api",
      "aliases": [
        "CVE-2020-35910",
        "CVE-2020-35911",
        "CVE-2020-35912",
        "CVE-2020-35913",
        "CVE-2020-35914",
        "GHSA-5wg8-7c9q-794v",
        "GHSA-gmv4-vmx3-x9f3",
        "GHSA-hj9h-wrgg-hgmx",
        "GHSA-ppj3-7jw3-8vc4",
        "GHSA-vh4p-6j7g-f4j9"
      ],
      "date": "2020-11-08",
      "url": "https://github.com/Amanieu/parking_lot/pull/262",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "affected": {
      "functions": {
        "lock_api::MappedMutexGuard": [
          ">= 0.1.0"
        ],
        "lock_api::MappedRwLockReadGuard": [
          ">= 0.1.0"
        ],
        "lock_api::MappedRwLockWriteGuard": [
          ">= 0.1.0"
        ],
        "lock_api::RwLockReadGuard": [
          ">= 0.1.0"
        ],
        "lock_api::RwLockWriteGuard": [
          ">= 0.1.0"
        ]
      }
    },
    "text": "\n\n# Some lock_api lock guard objects can cause data races\n\nAffected versions of lock_api had unsound implementations of the `Send` or\n`Sync` traits for some guard objects, namely:\n\n* MappedMutexGuard\n* MappedRwLockReadGuard\n* MappedRwLockWriteGuard\n* RwLockReadGuard\n* RwLockWriteGuard\n\nThese guards could allow data races through types that are not safe to `Send`\nacross thread boundaries in safe Rust code.\n\nThis issue was fixed by changing the trait bounds on the `Mapped` guard types\nand removing the `Sync` trait for the `RwLock` guards.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0044",
      "package": "markdown",
      "date": "2022-01-17",
      "informational": "unmaintained",
      "url": "https://github.com/johannhof/markdown.rs/issues/48"
    },
    "versions": {
      "patched": [
        ">= 1.0.0-alpha.1"
      ]
    },
    "text": "\n\n# `markdown` (1.0.0 and higher) is maintained\n\nA new `markdown` crate has been brought over by a new maintainer replacing the old crate.\n\nAs of time of writing only pre-releases seem to be available for the 1.0.0 version of the crate.\n\nThe crate GitHub repository is now [wooorm/markdown-rs](https://github.com/wooorm/markdown-rs)\n\n# `markdown` (0.3.0 and lower) was unmaintained\n\nThe old [`markdown`](https://crates.io/crates/markdown) crate was no longer actively maintained.\n\nThe crate GitHub repository was [johannhof/markdown.rs](https://github.com/johannhof/markdown.rs)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0030",
      "package": "streebog",
      "aliases": [
        "CVE-2019-25006",
        "CVE-2019-25007",
        "GHSA-39wr-f4ff-xm6p",
        "GHSA-gf93-h79q-6jjv"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2019-10-06",
      "url": "https://github.com/RustCrypto/hashes/pull/91"
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ]
    },
    "text": "\n\n# Incorrect implementation of the Streebog hash functions\n\nInternal `update-sigma` function was implemented incorrectly and depending on\n`debug-assertions` it could've caused an incorrect result or panic for certain\ninputs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0331",
      "package": "puccinier",
      "date": "2024-03-31",
      "url": "https://github.com/catppuccin/toolbox/issues/66",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Puccinier is unmainted.\n\nThe tool has been deprecated in favor of Catppuccin's new tool, [whiskers](https://github.com/catppuccin/toolbox/tree/main/whiskers) [(crates.io)](https://crates.io/crates/catppuccin-whiskers).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0071",
      "package": "rusoto_credential",
      "date": "2022-04-24",
      "url": "https://github.com/rusoto/rusoto/issues/1651",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Rusoto is unmaintained\n\nThe maintainers of Rusoto advise that all its crates are deprecated. This includes the common crates `rusoto_core`, `rusoto_signature`, `rusoto_credential`, and service crates such as `rusoto_s3` and `rusoto_ec2`.\n\nUsers should migrate to the [AWS SDK for Rust](https://github.com/awslabs/aws-sdk-rust), which is maintained by AWS.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0013",
      "package": "libgit2-sys",
      "date": "2024-02-06",
      "url": "https://github.com/rust-lang/git2-rs/pull/1017",
      "references": [
        "https://github.com/libgit2/libgit2/releases/tag/v1.7.2"
      ],
      "categories": [
        "denial-of-service",
        "code-execution",
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
      "related": [
        "CVE-2024-24575",
        "CVE-2024-24577",
        "GHSA-54mf-x2rh-hq9v",
        "GHSA-j2v7-4f6v-gpg8"
      ],
      "aliases": [
        "GHSA-22q8-ghmq-63vf"
      ]
    },
    "affected": {
      "functions": {
        "libgit2_sys::git_revparse_single": [
          "< 0.16.2, >= 0.13.0"
        ],
        "libgit2_sys::git_index_add": [
          "< 0.16.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.16.2"
      ]
    },
    "text": "\n\n# Memory corruption, denial of service, and arbitrary code execution in libgit2\n\nThe [libgit2](https://github.com/libgit2/libgit2/) project fixed three security issues in the 1.7.2 release. These issues are:\n\n* The `git_revparse_single` function can potentially enter an infinite loop on a well-crafted input, potentially causing a Denial of Service. This function is exposed in the `git2` crate via the [`Repository::revparse_single`](https://docs.rs/git2/latest/git2/struct.Repository.html#method.revparse_single) method.\n* The `git_index_add` function may cause heap corruption and possibly lead to arbitrary code execution. This function is exposed in the `git2` crate via the [`Index::add`](https://docs.rs/git2/latest/git2/struct.Index.html#method.add) method.\n* The smart transport negotiation may experience an out-of-bounds read when a remote server did not advertise capabilities.\n\nThe `libgit2-sys` crate bundles libgit2, or optionally links to a system libgit2 library. In either case, versions of the libgit2 library less than 1.7.2 are vulnerable. The 0.16.2 release of `libgit2-sys` bundles the fixed version of 1.7.2, and requires a system libgit2 version of at least 1.7.2.\n\nIt is recommended that all users upgrade.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0003",
      "package": "libgit2-sys",
      "date": "2023-01-20",
      "url": "https://github.com/rust-lang/git2-rs/security/advisories/GHSA-m4ch-rfv5-x5g3",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "ssh",
        "mitm",
        "git"
      ],
      "aliases": [
        "CVE-2023-22742",
        "GHSA-m4ch-rfv5-x5g3",
        "GHSA-8643-3wh5-rmjq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.13.5, < 0.14.0",
        ">= 0.14.2"
      ]
    },
    "text": "\n\n# git2 does not verify SSH keys by default\n\nThe git2 and libgit2-sys crates are Rust wrappers around the\n[libgit2]() C library. It was discovered that libgit2 1.5.0\nand below did not verify SSH host keys when establishing an SSH connection,\nexposing users of the library to Man-In-the-Middle attacks.\n\nThe libgit2 team assigned [CVE-2023-22742][libgit2-advisory] to this\nvulnerability. The following versions of the libgit2-sys Rust crate have been\nreleased:\n\n* libgit2-sys 0.14.2, updating the underlying libgit2 C library to version 1.5.1.\n* libgit2-sys 0.13.5, updating the underlying libgit2 C library to version 1.4.5.\n\nA new git2 crate version has also been released, 0.16.1. This version only\nbumps its libgit2-sys dependency to ensure no vulnerable libgit2-sys versions\nare used, but contains no code changes: if you update the libgit2-sys version\nthere is no need to also update the git2 crate version.\n\n[You can learn more about this vulnerability in libgit2's advisory][libgit2-advisory]\n\n[libgit2]: https://libgit2.org/\n[libgit2-advisory]: https://github.com/libgit2/libgit2/security/advisories/GHSA-8643-3wh5-rmjq\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0351",
      "package": "gix-ref",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-49jc-r788-3fc9",
      "references": [
        "https://github.com/advisories/GHSA-49jc-r788-3fc9",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35197"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L",
      "aliases": [
        "CVE-2024-35197",
        "GHSA-49jc-r788-3fc9"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.44.0"
      ]
    },
    "text": "\n\n# Refs and paths with reserved Windows device names access the devices\n\n### Summary\n\nOn Windows, fetching refs that clash with legacy device names reads from the devices, and checking out paths that clash with such names writes arbitrary data to the devices. This allows a repository, when cloned, to cause indefinite blocking or the production of arbitrary message that appear to have come from the application, and potentially other harmful effects under limited circumstances.\n\n### Details\n\nIt is possible to create a Git repository that contains references or filenames that Windows treats as legacy DOS-style aliases for system devices. When such a repository is cloned:\n\n- In references, `gix-ref` does not include a check for such names before attempting to access them on disk, which reads from the devices, though the ability to exfiltrate data appears limited.\n- In paths, `gix-worktree-state` does not treat such names as collisions and instead writes to them, which writes arbitrary attacker-controlled data to the devices.\n\nSome such device names refer to devices that are often absent or inaccessible. But a few are guaranteed to be available, allowing some attacks to be carried out with low complexity. For both reading refs and writing paths, one important case is the console:\n\n- Reading a ref whose last component (e.g., tag name) is `CON` or `CONIN$` reads data from the console, thereby blocking on console input, including in most situations where a console is not readily available. This may facilitate denial of service attacks.\n- Checking out a file named `CON` or `CONOUT$` writes its contents to the console. This allows an untrusted repository to produce arbitrary text that appears to be a message from the application. Such text may facilitate social engineering if it is selected to instruct the user to perform a particular action.\n\nAnother potentially important case is serial ports. For example, `COM1` refers to the first serial port, if present. A malicious repository may be able to disrupt intended use of serial ports or attempt to interact with a device. In some configurations, it may be possible to interfere with the operation of a physical or virtual serial console. On Windows, local access to serial ports is often permitted even for limited user accounts without elevation.\n\n[Naming Files, Paths, and Namespaces](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions) covers most reserved names. `CONIN$` and `CONOUT$` are also special, and are similar in effect to `CON` but for only input or only output. These names are case-insensitive and can also be accessed with file extensions (e.g, `CON.txt` is equivalent to `CON`) and with some variations involving added spaces or colons.\n\n### PoC\n\n#### Ref example\n\nCreate a repository on a non-Windows system (or in WSL) with at least one commit. Use `git tag CON` to create a lightweight tag named `CON`. Place the repository somewhere it can be cloned on Windows. A `file://` URL is sufficient for testing if a private remote is unavailable. If using `git push`, pass `--tags` so the remote has the tag.\n\nOn a Windows system, clone the repository with `gix clone`. This command will block immediately, reading input from the console. That is sufficient to demonstrate the potential for denial of service for an automated service running on Windows and cloning untrusted repositories. The experiment can be stopped with <kbd>Ctrl</kbd>+<kbd>C</kbd>.\n\nHowever, if desired, input can be provided. Ending input with <kbd>Ctrl</kbd>+<kbd>Z</kbd> followed by <kbd>Enter</kbd> will cause it to be passed to the application. This will lead to an error message, the specific details of which vary by whether the input is empty or nonempty, and whether it matches or does not match the hexadecimal hash of the tagged commit.\n\n#### Path example\n\nCreate a repository on a non-Windows system (or in WSL) and commit a file named `CON` with the contents:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n```\n\nWhile that example text serves to illustrate the risk, any distinctive text is sufficient to observe the vulnerability. Place the repository somewhere it can be cloned on Windows. As above, a `file://` URL is sufficient.\n\nOn a Windows system, clone the repository with `gix clone`. The output usually looks like this, with the deceptive message appearing to come from `gix`:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n 04:45:15 indexing done 3.0 objects in 0.00s (12.1K objects/s)\n 04:45:15 decompressing done 309B in 0.00s (1.2MB/s)\n 04:45:15     Resolving done 3.0 objects in 0.05s (58.0 objects/s)\n 04:45:15      Decoding done 309B in 0.05s (6.0KB/s)\n 04:45:15 writing index file done 1.2KB in 0.00s (7.0MB/s)\n 04:45:15  create index file done 3.0 objects in 0.05s (55.0 objects/s)\n 04:45:15          read pack done 294B in 0.05s (5.4KB/s)\nError: IO error while writing blob or reading file metadata or changing filetype\n\nCaused by:\n    Incorrect function. (os error 1)\n```\n\nThe exact placement of the message is nondeterministic. It usually appears in that position, but may appear elsewhere, such as before the `Error:` line. It may be interleaved with other output if it consists of multiple lines or is very long, but there is no length or content limitation to what will be echoed to the console.\n\n### Impact\n\nIf Windows is not used, or untrusted repositories are not cloned or otherwise used, then there is no impact.\n\nThe impact is expected to be limited in common configurations, but may vary widely depending on what devices exist, how they are being used, how much knowledge an attacker has of the precise details of their use, and whether the user is likely to trust information that appears in a console. Accessing devices through refs is expected to be less dangerous than accessing them through filenames, since it is trivial to attempt to write arbitrary data using filenames.\n\nFor attacks using the `CON` or `CONOUT$` device names, the greatest risk is if a command the user would not otherwise run, and would not be convinced to run by untrusted instructions, seems reasonable when a trusted application such as `gix` appears to recommend it. The user may then be misled into running an attacker's command.\n\nA minor degradation in availability may also be possible, such as with a very large file named `CON`, though the user could usually interrupt the application.\n"
  },
  {
    "advisory": {
      "categories": [
        "denial-of-service",
        "memory-corruption"
      ],
      "date": "2020-01-16",
      "id": "RUSTSEC-2020-0002",
      "package": "prost",
      "aliases": [
        "CVE-2020-35858",
        "GHSA-gv73-9mwv-fwgq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "keywords": [
        "stack overflow"
      ],
      "url": "https://github.com/danburkert/prost/issues/267"
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Parsing a specially crafted message can result in a stack overflow\n\nAffected versions of this crate contained a bug in which decoding untrusted\ninput could overflow the stack.\n\nOn architectures with stack probes (like x86), this can be used for denial of\nservice attacks, while on architectures without stack probes (like ARM)\noverflowing the stack is unsound and can result in potential memory corruption\n(or even RCE).\n \nThe flaw was quickly corrected by @danburkert and released in version 0.6.1.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0082",
      "package": "ordered-float",
      "aliases": [
        "CVE-2020-35923",
        "GHSA-566x-hhrf-qf8m"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-06",
      "url": "https://github.com/reem/rust-ordered-float/pull/71",
      "categories": [],
      "keywords": [
        "unwind"
      ]
    },
    "versions": {
      "patched": [
        "^1.1.1",
        ">= 2.0.1"
      ],
      "unaffected": [
        "< 0.2.2"
      ]
    },
    "affected": {},
    "text": "\n\n# ordered_float:NotNan may contain NaN after panic in assignment operators\n\nAfter using an assignment operators such as `NotNan::add_assign`, `NotNan::mul_assign`, etc., it was possible for the resulting `NotNan` value to contain a `NaN`.  This could cause undefined behavior in safe code, because the safe `NotNan::cmp` method contains internal unsafe code that assumes the value is never `NaN`.  (It could also cause undefined behavior in third-party unsafe code that makes the same assumption, as well as logic errors in safe code.)\n\nThis was mitigated starting in version 0.4.0, by panicking if the assigned value is NaN.  However, in affected versions from 0.4.0 onward, code that uses the `NotNan` value during unwinding, or that continues after catching the panic, could still observe the invalid value and trigger undefined behavior.\n\nThe flaw is fully corrected in versions 1.1.1 and 2.0.1, by ensuring that the assignment operators panic without modifying the operand, if the result would be `NaN`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0042",
      "package": "rustdecimal",
      "date": "2022-05-10",
      "url": "https://groups.google.com/g/rustlang-security-announcements/c/5DVtC8pgJLw?pli=1",
      "categories": [
        "code-execution"
      ],
      "keywords": [
        "typosquatting"
      ],
      "aliases": [
        "GHSA-7pwq-f4pq-78gm",
        "MAL-2022-1"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# malicious crate `rustdecimal`\n\nThe Rust Security Response WG and the crates.io team [were notified][1] on\n2022-05-02 of the existence of the malicious crate `rustdecimal`, which\ncontained malware. The crate name was intentionally similar to the name of the\npopular [`rust_decimal`][2] crate, hoping that potential victims would misspell\nits name (an attack called \"typosquatting\").\n\nTo protect the security of the ecosystem, the crates.io team permanently\nremoved the crate from the registry as soon as it was made aware of the\nmalware. An analysis of all the crates on crates.io was also performed, and no\nother crate with similar code patterns was found.\n\nKeep in mind that the [`rust_decimal`][2] crate was **not** compromised, and it\nis still safe to use.\n\n## Analysis of the crate\n\nThe crate had less than 500 downloads since its first release on 2022-03-25,\nand no crates on the crates.io registry depended on it.\n\nThe crate contained identical source code and functionality as the legit\n`rust_decimal` crate, except for the `Decimal::new` function.\n\nWhen the function was called, it checked whether the `GITLAB_CI` environment\nvariable was set, and if so it downloaded a binary payload into\n`/tmp/git-updater.bin` and executed it. The binary payload supported both Linux\nand macOS, but not for Windows.\n\nAn analysis of the binary payload was not possible, as the download URL didn't\nwork anymore when the analysis was performed.\n\n## Recommendations\n\nIf your project or organization is running GitLab CI, we strongly recommend\nchecking whether your project or one of its dependencies depended on the\n`rustdecimal` crate, starting from 2022-03-25. If you notice a dependency on\nthat crate, you should consider your CI environment to be compromised.\n\nIn general, we recommend regularly auditing your dependencies, and only\ndepending on crates whose author you trust. If you notice any suspicious\nbehavior in a crate's source code please follow [the Rust security\npolicy][3] and report it to the Rust Security Response WG.\n\n## Acknowledgements\n\nWe want to thank GitHub user [`@safinaskar`][4] for identifying the\nmalicious crate in [this GitHub issue][1].\n\n[1]: https://github.com/paupino/rust-decimal/issues/514#issuecomment-1115408888\n[2]: https://crates.io/crates/rust_decimal\n[3]: https://www.rust-lang.org/policies/security\n[4]: https://github.com/safinaskar \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0007",
      "package": "asn1_der",
      "aliases": [
        "CVE-2019-15549",
        "GHSA-v5r6-6r3c-wqxc"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-06-13",
      "keywords": [
        "dos"
      ],
      "url": "https://github.com/KizzyCode/asn1_der/issues/1"
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ]
    },
    "text": "\n\n# Processing of maliciously crafted length fields causes memory allocation SIGABRTs\n\nAffected versions of this crate tried to preallocate a vector for an arbitrary amount of bytes announced by the ASN.1-DER length field without further checks.\n\nThis allows an attacker to trigger a SIGABRT by creating length fields that announce more bytes than the allocator can provide.\n \nThe flaw was corrected by not preallocating memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0046",
      "package": "rocksdb",
      "date": "2022-05-11",
      "url": "https://github.com/rust-rocksdb/rust-rocksdb/pull/616",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "out-of-bounds read"
      ],
      "aliases": [
        "GHSA-xpp3-xrff-w6rh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.19.0"
      ]
    },
    "affected": {
      "functions": {
        "rocksdb::DBWithThreadMode::open_cf_descriptors_with_ttl": [
          "< 0.19.0"
        ]
      }
    },
    "text": "\n\n# Out-of-bounds read when opening multiple column families with TTL\n\nAffected versions of this crate called the RocksDB C API\n`rocksdb_open_column_families_with_ttl()` with a pointer to a single integer\nTTL value, but one TTL value for each column family is expected.\n\nThis is only relevant when using\n`rocksdb::DBWithThreadMode::open_cf_descriptors_with_ttl()` with multiple\ncolumn families.\n\nThis bug has been fixed in v0.19.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0003",
      "package": "portaudio",
      "aliases": [
        "CVE-2016-10933",
        "GHSA-pq6v-x7gp-7776"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2016-08-01",
      "keywords": [
        "ssl",
        "mitm"
      ],
      "url": "https://github.com/RustAudio/rust-portaudio/issues/144"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# HTTP download and execution allows MitM RCE\n\nThe build script in the portaudio crate will attempt to download via HTTP\nthe portaudio source and build it.\n\nA Mallory in the middle can intercept the download with their own archive\nand get RCE.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0018",
      "package": "totp-rs",
      "date": "2022-05-09",
      "url": "https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:N/A:N",
      "keywords": [
        "side-channel",
        "timing-attack"
      ],
      "aliases": [
        "CVE-2022-29185",
        "GHSA-8vxv-2g8p-2249"
      ]
    },
    "affected": {
      "functions": {
        "totp_rs::TOTP::check": [
          "< 1.1.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.1.0"
      ]
    },
    "text": "\n\n# Timing attack\n\nAffecting versions did not compare tokens in constant time, which could make it possible for an attacker to guess the 2fa token of a user.\n\nThis has been fixed by using using the crate constant_time_eq for comparison.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0072",
      "package": "tokio",
      "date": "2021-07-07",
      "url": "https://github.com/tokio-rs/tokio/issues/3929",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "race condition",
        "send"
      ],
      "aliases": [
        "CVE-2021-38191",
        "GHSA-2grh-hm3w-w7hv"
      ]
    },
    "affected": {
      "functions": {
        "tokio::task::JoinHandle::abort": [
          "<= 1.8.0, >= 0.3.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.5.1, < 1.6.0",
        ">= 1.6.3, < 1.7.0",
        ">= 1.7.2, < 1.8.0",
        ">= 1.8.1"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Task dropped in wrong thread when aborting `LocalSet` task\n\nWhen aborting a task with `JoinHandle::abort`, the future is dropped in the\nthread calling abort if the task is not currently being executed. This is\nincorrect for tasks spawned on a `LocalSet`.\n\nThis can easily result in race conditions as many projects use `Rc` or `RefCell`\nin their Tokio tasks for better performance.\n\nSee [tokio#3929][issue] for more details.\n\n[issue]: https://github.com/tokio-rs/tokio/issues/3929\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0005",
      "package": "tokio",
      "date": "2023-01-11",
      "url": "https://github.com/tokio-rs/tokio/issues/5372",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-4q83-7cq4-p6wg"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.18.5, < 1.19.0",
        ">= 1.20.4, < 1.21.0",
        ">= 1.24.2"
      ],
      "unaffected": [
        "< 0.2.0"
      ]
    },
    "text": "\n\n# `tokio::io::ReadHalf<T>::unsplit` is Unsound\n\n`tokio::io::ReadHalf<T>::unsplit` can violate the `Pin` contract\n\nThe soundness issue is described in the [tokio/issues#5372](https://github.com/tokio-rs/tokio/issues/5372)\n\nSpecific set of conditions needed to trigger an issue (a !Unpin type in ReadHalf)\nis unusual, combined with the difficulty of making any arbitrary use-after-free\nexploitable in Rust without doing a lot of careful alignment of data types in\nthe surrounding code.\n\nThe `tokio` feature `io-util` is also required to be enabled to trigger this\nsoundness issue.\n\nThanks to zachs18 reporting the issue to Tokio team responsibly and taiki-e\nand carllerche appropriately responding and fixing the soundness bug.\n\nTokio before 0.2.0 used `futures` 0.1 that did not have `Pin`, so it is not\naffected by this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0001",
      "package": "tokio",
      "aliases": [
        "CVE-2023-22466",
        "GHSA-7rrj-xr53-82p7"
      ],
      "date": "2023-01-04",
      "url": "https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7",
      "references": [
        "https://github.com/tokio-rs/tokio/pull/5336",
        "https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients"
      ],
      "keywords": [
        "configuration failure"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.18.4, < 1.19.0",
        ">= 1.20.3, < 1.21.0",
        ">= 1.23.1"
      ],
      "unaffected": [
        "< 1.7.0"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "text": "\n\n# reject_remote_clients Configuration corruption\n\nOn Windows, configuring a named pipe server with [pipe_mode] will force [ServerOptions]::[reject_remote_clients] as `false`.\n\nThis drops any intended explicit configuration for the [reject_remote_clients] that may have been set as `true` previously.\n\nThe default setting of [reject_remote_clients] is normally `true` meaning the default is also overridden as `false`.\n\n## Workarounds\n\nEnsure that [pipe_mode] is set first after initializing a [ServerOptions]. For example:\n\n```rust\nlet mut opts = ServerOptions::new();\nopts.pipe_mode(PipeMode::Message);\nopts.reject_remote_clients(true);\n```\n\n[ServerOptions]: https://docs.rs/tokio/latest/tokio/net/windows/named_pipe/struct.ServerOptions.html\n[pipe_mode]: https://docs.rs/tokio/latest/tokio/net/windows/named_pipe/struct.ServerOptions.html#method.pipe_mode\n[reject_remote_clients]: https://docs.rs/tokio/latest/tokio/net/windows/named_pipe/struct.ServerOptions.html#method.reject_remote_clients\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0124",
      "package": "tokio",
      "aliases": [
        "CVE-2021-45710",
        "GHSA-fg7r-2g4j-5cgr"
      ],
      "date": "2021-11-16",
      "url": "https://github.com/tokio-rs/tokio/issues/4225",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "race condition"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.8.4, < 1.9.0",
        ">= 1.13.1"
      ],
      "unaffected": [
        "< 0.1.14"
      ]
    },
    "affected": {
      "functions": {
        "tokio::sync::oneshot::Receiver::close": [
          "<= 1.13.0, >= 0.1.14"
        ]
      }
    },
    "text": "\n\n# Data race when sending and receiving after closing a `oneshot` channel\n\nIf a `tokio::sync::oneshot` channel is closed (via the\n[`oneshot::Receiver::close`] method), a data race may occur if the\n`oneshot::Sender::send` method is called while the corresponding\n`oneshot::Receiver` is `await`ed or calling `try_recv`.\n\nWhen these methods are called concurrently on a closed channel, the two halves\nof the channel can concurrently access a shared memory location, resulting in a\ndata race. This has been observed to [cause memory corruption][corruption].\n\nNote that the race only occurs when **both** halves of the channel are used\nafter the `Receiver` half has called `close`. Code where `close` is not used, or where the\n`Receiver` is not `await`ed and `try_recv` is not called after calling `close`,\nis not affected.\n\nSee [tokio#4225][issue] for more details.\n\n[corruption]: https://github.com/tokio-rs/tokio/issues/4225#issuecomment-967434847\n[issue]: https://github.com/tokio-rs/tokio/issues/4225\n[`oneshot::Receiver::close`]: https://docs.rs/tokio/1.14.0/tokio/sync/oneshot/struct.Receiver.html#method.close\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0002",
      "package": "dashmap",
      "date": "2022-01-10",
      "url": "https://github.com/xacrimon/dashmap/issues/167",
      "categories": [
        "memory-exposure",
        "memory-corruption"
      ],
      "keywords": [
        "segfault",
        "use-after-free"
      ],
      "aliases": [
        "GHSA-mpg5-fvwp-42m2"
      ]
    },
    "affected": {
      "functions": {
        "dashmap::mapref::multiple::RefMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMulti::value": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMulti::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::multiple::RefMutMulti::pair_mut": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::value": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::Ref::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::key": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::pair": [
          ">= 5.0.0"
        ],
        "dashmap::mapref::one::RefMut::pair_mut": [
          ">= 5.0.0"
        ],
        "dashmap::setref::multiple::RefMulti::key": [
          ">= 5.0.0"
        ],
        "dashmap::setref::one::Ref::key": [
          ">= 5.0.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 5.1.0"
      ],
      "unaffected": [
        "< 5.0.0"
      ]
    },
    "text": "\n\n# Unsoundness in `dashmap` references\n\nReference returned by some methods of `Ref` (and similar types) may outlive the `Ref` and escape the lock.\nThis causes undefined behavior and may result in a segfault.\n\nMore information in [`dashmap#167`](https://github.com/xacrimon/dashmap/issues/167) issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0011",
      "package": "memoffset",
      "aliases": [
        "CVE-2019-15553",
        "GHSA-rh89-x75f-rh3c"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2019-07-16",
      "informational": "unsound",
      "url": "https://github.com/Gilnaa/memoffset/issues/9#issuecomment-505461490"
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# Flaw in offset_of and span_of causes SIGILL, drops uninitialized memory of arbitrary type on panic in client code\n\nAffected versions of this crate caused traps and/or memory unsafety by zero-initializing references.\nThey also could lead to uninitialized memory being dropped if the field for which the offset is requested was behind a deref coercion, and that deref coercion caused a panic.\n\nThe flaw was corrected by using `MaybeUninit`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0045",
      "package": "memoffset",
      "date": "2023-06-21",
      "url": "https://github.com/Gilnaa/memoffset/issues/24",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memoffset",
        "offset"
      ],
      "aliases": [
        "GHSA-wfg4-322g-9vqv"
      ]
    },
    "affected": {
      "functions": {
        "memoffset::offset_of": [
          "< 0.6.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ]
    },
    "text": "\n\n# memoffset allows reading uninitialized memory\nmemoffset allows attempt of reading data from address `0` with arbitrary type. This behavior is an undefined behavior because address `0` to `std::mem::size_of<T>` may not have valid bit-pattern with `T`. Old implementation dereferences uninitialized memory obtained from `std::mem::align_of`. Older implementation prior to it allows using uninitialized data obtained from `std::mem::uninitialized` with arbitrary type then compute offset by taking the address of field-projection. This may also result in an undefined behavior for \"father\" that includes (directly or transitively) type that [does not allow to be uninitialized](https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html).\n\nThis flaw was corrected by using `std::ptr::addr_of` in <https://github.com/Gilnaa/memoffset/pull/50>.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0155",
      "package": "acc_reader",
      "date": "2020-12-27",
      "url": "https://github.com/netvl/acc_reader/issues/1",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36513",
        "CVE-2020-36514",
        "GHSA-799f-r78p-gq9c",
        "GHSA-hv9v-7w3v-rj6f",
        "GHSA-p4cr-64x4-f92f"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Read` on uninitialized buffer in `fill_buf()` and `read_up_to()`\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0109",
      "package": "stderr",
      "date": "2020-12-22",
      "url": "https://github.com/biluohc/stderr/issues/5",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# stderr is unmaintained; use eprintln instead\n\nThe `stderr` crate is no longer maintained by its current owner. \n\nThe author recommends using the `eprintln` macro from the standard library as a\nreplacement.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0115",
      "package": "ruspiro-singleton",
      "date": "2020-11-16",
      "url": "https://github.com/RusPiRo/ruspiro-singleton/issues/10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36435",
        "GHSA-fqq2-xp7m-xvm8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# Singleton lacks bounds on Send and Sync.\n\n`Singleton<T>` is meant to be a static object that can be initialized lazily. In\norder to satisfy the requirement that `static` items must implement `Sync`,\n`Singleton` implemented both `Sync` and `Send` unconditionally.\n\nThis allows for a bug where non-`Sync` types such as `Cell` can be used in\nsingletons and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `b0d2bd20e` by adding trait bounds, requiring\nthe contaiend type to implement `Sync`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0034",
      "package": "arr",
      "aliases": [
        "CVE-2020-35886",
        "CVE-2020-35887",
        "CVE-2020-35888",
        "GHSA-36xw-hgfv-jwm7",
        "GHSA-c7fw-cr3w-wvfc",
        "GHSA-fhvj-7f9p-w788"
      ],
      "date": "2020-08-25",
      "url": "https://github.com/sjep/array/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple security issues including data race, buffer overflow, and uninitialized memory drop\n\n`arr` crate contains multiple security issues. Specifically,\n\n1. It incorrectly implements Sync/Send bounds, which allows to smuggle non-Sync/Send types across the thread boundary.\n2. `Index` and `IndexMut` implementation does not check the array bound.\n3. `Array::new_from_template()` drops uninitialized memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0019",
      "package": "kuchiki",
      "date": "2023-01-21",
      "url": "https://github.com/kuchiki-rs/kuchiki/commit/f92e4c047fdc30619555da282ac7ccce1d313aa6",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `kuchiki` is unmaintained\n\nThe `kuchiki` repo was marked as archived in [this](https://github.com/kuchiki-rs/kuchiki/commit/f92e4c047fdc30619555da282ac7ccce1d313aa6) commit.\n\n## Possible Alternatives\n\nPossible alternatives may include:\n\n- [kuchikiki](https://crates.io/crates/kuchikiki)\n- [html5ever](https://crates.io/crates/html5ever)\n- [xml-rs](https://crates.io/crates/xml-rs)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0001",
      "package": "mdbook",
      "date": "2021-01-04",
      "url": "https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0",
      "categories": [
        "code-execution"
      ],
      "keywords": [
        "xss"
      ],
      "aliases": [
        "CVE-2020-26297"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.4.5"
      ],
      "unaffected": [
        "<= 0.1.3"
      ]
    },
    "text": "\n\n# XSS in mdBook's search page\n\n> This is a cross-post of [the official security advisory][ml]. The official post\n> contains a signed version with our PGP key, as well.\n\n[ml]: https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0\n\nThe Rust Security Response Working Group was recently notified of a security\nissue affecting the search feature of mdBook, which could allow an attacker to\nexecute arbitrary JavaScript code on the page.\n\nThe CVE for this vulnerability is [CVE-2020-26297][1].\n\n## Overview\n\nThe search feature of mdBook (introduced in version 0.1.4) was affected by a\ncross site scripting vulnerability that allowed an attacker to execute\narbitrary JavaScript code on an user's browser by tricking the user into typing\na malicious search query, or tricking the user into clicking a link to the\nsearch page with the malicious search query prefilled.\n\nmdBook 0.4.5 fixes the vulnerability by properly escaping the search query.\n\n## Mitigations\n\nOwners of websites built with mdBook have to upgrade to mdBook 0.4.5 or greater\nand rebuild their website contents with it. It's possible to install mdBook\n0.4.5 on the local system with:\n\n```\ncargo install mdbook --version 0.4.5 --force\n```\n\n## Acknowledgements\n\nThanks to Kamil Vavra for responsibly disclosing the vulnerability to us\naccording to [our security policy][2].\n\n## Timeline of events\n\nAll times are listed in UTC.\n\n* 2020-12-30 20:14 - The issue is reported to the Rust Security Response WG\n* 2020-12-30 20:32 - The issue is acknowledged and the investigation began\n* 2020-12-30 21:21 - Found the cause of the vulnerability and prepared the patch\n* 2021-01-04 15:00 - Patched version released and vulnerability disclosed\n\n[1]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26297\n[2]: https://www.rust-lang.org/policies/security\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0106",
      "package": "bat",
      "date": "2021-07-15",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-36753",
      "categories": [
        "code-execution"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "aliases": [
        "CVE-2021-36753",
        "GHSA-p24j-h477-76q3"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.18.2"
      ]
    },
    "text": "\n\n# Uncontrolled Search Path Element in sharkdp/bat \n\nbat on windows before 0.18.2 executes programs named less.exe from the current working directory. This can lead to unintended code execution.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0021",
      "package": "nb-connect",
      "aliases": [
        "CVE-2021-27376",
        "GHSA-rm4w-6696-r77p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-14",
      "url": "https://github.com/smol-rs/nb-connect/issues/1",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 1.0.3"
      ]
    },
    "text": "\n\n# `nb-connect` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`nb-connect`](https://crates.io/crates/nb-connect) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0054",
      "package": "mail-internals",
      "date": "2023-08-07",
      "url": "https://git.sr.ht/~nabijaczleweli/mail-internals.crate/commit/05443c864b204e7f1512caf2d53e8cce4dd340fc",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "mail",
        "mail-api"
      ],
      "aliases": [
        "GHSA-rcx8-48pc-v9q8"
      ]
    },
    "affected": {
      "functions": {
        "mail_internals::utils::vec_insert_bytes": [
          ">= 0.2.0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Use-after-free in `vec_insert_bytes`\nIncorrect reallocation logic in the function [`vec_insert_bytes`](https://docs.rs/mail-internals/0.2.3/mail_internals/utils/fn.vec_insert_bytes.html) causes a use-after-free.\n\nThis function does not have to be called directly to trigger the vulnerability because many methods on [`EncodingWriter`](https://docs.rs/mail-internals/0.2.3/mail_internals/encoder/struct.EncodingWriter.html) call this function internally.\n\nThe mail-\\* suite is unmaintained and the upstream sources have been actively vandalised.\nA fixed `mail-internals-ng` (and `mail-headers-ng` and `mail-core-ng`) crate has been published which fixes this, and a dependency on another unsound crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0030",
      "package": "versionize",
      "date": "2023-03-24",
      "url": "https://github.com/firecracker-microvm/versionize/pull/53",
      "categories": [
        "memory-exposure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L",
      "aliases": [
        "CVE-2023-28448",
        "GHSA-8vxc-r5wp-vgvc"
      ]
    },
    "affected": {
      "os": [
        "linux"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.10"
      ]
    },
    "text": "\n\n# `Versionize::deserialize` implementation for `FamStructWrapper<T>` is lacking bound checks, potentially leading to out of bounds memory accesses \n\nAn issue was discovered in the `Versionize::deserialize` implementation provided by the `versionize` crate for `vmm_sys_util::fam::FamStructWrapper`, which can lead to out of bounds memory accesses. The impact started with version 0.1.1. The issue was corrected in version 0.1.10 by inserting a check that verifies, for any deserialized header, the lengths of compared flexible arrays are equal and aborting deserialization otherwise.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0022",
      "package": "ozone",
      "aliases": [
        "CVE-2020-35877",
        "CVE-2020-35878",
        "GHSA-m3ww-7hrp-gw9w",
        "GHSA-p2q9-9cq6-h3jw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-07-04"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Ozone contains several memory safety issues\n\nOzone contains several memory safety issues including [out-of-bound access](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/buffer.rs#L38-L48)\nand dropping of [uninitialized memory](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/map.rs#L94-L101).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0335",
      "package": "gix-transport",
      "date": "2024-04-13",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-98p4-xjmm-8mfh",
      "categories": [
        "code-execution"
      ],
      "aliases": [
        "CVE-2024-32884",
        "GHSA-98p4-xjmm-8mfh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.42.0"
      ]
    },
    "text": "\n\n# gix-transport indirect code execution via malicious username\n\n### Summary\n\n`gix-transport` does not check the username part of a URL for text that the external `ssh` program would interpret as an option. A specially crafted clone URL can smuggle options to SSH. The possibilities are syntactically limited, but if a malicious clone URL is used by an application whose current working directory contains a malicious file, arbitrary code execution occurs.\n\nThe first `gix` crate with the fix [is version 0.62.0](https://crates.io/crates/gix/0.62.0), and the first fixed `gix` CLI is [version 0.35](https://github.com/Byron/gitoxide/releases/tag/v0.35.0). `gix-transport` [at version v0.42](https://crates.io/crates/gix-transport/0.42.0) is the lowest-level plumbing crate with the fix.\n\n### Details\n\nThis is related to the patched vulnerability [RUSTSEC-2023-0064](https://rustsec.org/advisories/RUSTSEC-2023-0064.html), but appears less severe due to a greater attack complexity. Since <https://github.com/Byron/gitoxide/pull/1032>, `gix-transport` checks the host and path portions of a URL for text that has a `-` in a position that will cause `ssh` to interpret part of all of the URL as an option argument. But it does not check the non-mandatory username portion of the URL.\n\nAs in Git, when an address is a URL of the form `ssh://username@hostname/path`, or when it takes the special form `username@hostname:dirs/repo`, this is treated as an SSH URL. `gix-transport` will replace some characters in `username` with their `%`-based URL encodings, but otherwise passes `username@hostname` as an argument to the external `ssh` command. This happens even if `username` begins with a hyphen. In that case, `ssh` treats that argument as an option argument, and attempts to interpret and honor it as a sequence of one or more options possibly followed by an operand for the last option.\n\nThis is harder to exploit than [RUSTSEC-2023-0064](https://rustsec.org/advisories/RUSTSEC-2023-0064.html), because the possibilities are constrained by:\n\n- The difficulty of forming an option argument `ssh` accepts, given that characters such as `=`, `/`, and `\\`, are URL-encoded, `:` is removed, and the argument passed to `ssh` contains the `@` sign and subsequent host identifier, which in an effective attack must be parseable as a suffix of the operand passed to the last option.\n\n  The inability to include a literal `=` prevents the use of `-oNAME=VALUE` (e.g., `-oProxyCommand=payload`). The inability to include a literal `/` or `\\` prevents smuggling in a path operand residing outside the current working directory, including on Windows. (Although a `~` character may be smuggled in, `ssh` does not perform its own tilde expansion, so it does not form an absolute path.)\n\n- The difficulty, or perhaps impossibility, of completing a connection (other than when arbitrary code execution has been achieved). This complicates or altogether prevents the use of options such as `-A` and `-X` together with a connection to a real but malicious server. The reason a connection cannot generally be completed when exploiting this vulnerability is that, because the argument `gix-transport` intends as a URL is treated as an option argument, `ssh` treats the subsequent non-option argument `git-upload-pack` as the host instead of the command, but it is not a valid host name.\n\n  Although `ssh` supports aliases for hosts, even if `git-upload-pack` could be made an alias, that is made difficult by the URL-encoding transformation.\n\nHowever, an attacker who is able to cause a specially named `ssh` configuration file to be placed in the current working directory can smuggle in an `-F` option referencing the file, and this allows arbitrary command execution.\n\nThis scenario is especially plausible because programs that operate on git repositories are often run in untrusted git repositories, sometimes even to operate on another repository. Situations where this is likely, such that an attacker could predict or arrange it, may for some applications include a malicious repository with a malicious submodule configuration.\n\nOther avenues of exploitation exist, but appear to be less severe. For example, the `-E` option can be smuggled to create or append to a file in the current directory (or its target, if it is a symlink). There may also be other significant ways to exploit this that have not yet been discovered, or that would arise with new options in future versions of `ssh`.\n\n### PoC\n\nTo reproduce the known case that facilitates arbitrary code execution, first create a file in the current directory named `configfile@example.com`, of the form\n\n```text\nProxyCommand payload\n```\n\nwhere `payload` is a command with an observable side effect. On Unix-like systems, this could be `date | tee vulnerable` or an `xdg-open`, `open`, or other command command to launch a graphical application. On Windows, this could be the name of a graphical application already in the search path, such as `calc.exe`.\n\n(Although the syntax permitted in the value of `ProxyCommand` may vary by platform, this is not limited to running commands in the current directory. That limitation only applies to paths directly smuggled in the username, not to the contents of a separate malicious configuration file. Arbitrary other settings may be specified in `configfile@example.com` as well.)\n\nThen run:\n\n```sh\ngix clone 'ssh://-Fconfigfile@example.com/abc'\n```\n\nOr:\n\n```sh\ngix clone -- '-Fconfigfile@example.com:abc/def'\n```\n\n(The `--` is required to ensure that `gix` is really passing the argument as a URL for use in `gix-transport`, rather than interpreting it as an option itself, which would not necessarily be a vulnerability.)\n\nIn either case, the payload specified in `configfile@example.com` runs, and its side effect can be observed.\n\nOther cases may likewise be produced, in either of the above two forms of SSH addresses. For example, to create or append to the file `errors@example.com`, or to create or append to its target if it is a symlink:\n\n```sh\ngix clone 'ssh://-Eerrors@example.com/abc'\n```\n\n```sh\ngix clone -- '-Eerrors@example.com:abc/def'\n```\n\n### Impact\n\nAs in [RUSTSEC-2023-0064](https://rustsec.org/advisories/RUSTSEC-2023-0064.html), this would typically require user interaction to trigger an attempt to clone or otherwise connect using the malicious URL. Furthermore, known means of exploiting this vulnerability to execute arbitrary commands require further preparatory steps to establish a specially named file in the current directory. The impact is therefore expected to be lesser, though it is difficult to predict it with certainty because it is not known exactly what scenarios will arise when using the `gix-transport` library.\n\nUsers who use applications that make use of `gix-transport` are potentially vulnerable, especially:\n\n- On repositories with submodules that are automatically added, depending how the application manages submodules.\n- When operating on other repositories from inside an untrusted repository.\n- When reviewing contributions from untrusted developers by checking out a branch from an untrusted fork and performing clones from that location.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0064",
      "package": "gix-transport",
      "date": "2023-09-23",
      "url": "https://github.com/Byron/gitoxide/pull/1032",
      "references": [
        "https://secure.phabricator.com/T12961"
      ],
      "categories": [
        "code-execution"
      ],
      "aliases": [
        "GHSA-rrjw-j4m2-mf34"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.36.1"
      ]
    },
    "text": "\n\n# gix-transport code execution vulnerability\n\nThe `gix-transport` crate prior to the patched version 0.36.1 would allow attackers to\nuse malicious ssh clone URLs to pass arbitrary arguments to the `ssh` program, leading\nto arbitrary code execution.\n\nPoC: `gix clone 'ssh://-oProxyCommand=open$IFS-aCalculator/foo'`\n\nThis will launch a calculator on OSX.\n\nSee <https://secure.phabricator.com/T12961> for more details on similar vulnerabilities in `git`.\n\nThanks to [vin01](https://github.com/vin01) for disclosing the issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0153",
      "package": "encoding",
      "date": "2021-12-05",
      "url": "https://github.com/lifthrasiir/rust-encoding/issues/127",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `encoding` is unmaintained\n\nLast release was on 2016-08-28. The [issue](https://github.com/lifthrasiir/rust-encoding/issues/127) inquiring as to the status of the crate has gone unanswered by the maintainer.\n\n## Possible alternatives\n\n- [encoding_rs](https://crates.io/crates/encoding_rs)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0037",
      "package": "diesel",
      "aliases": [
        "CVE-2021-28305",
        "GHSA-j8q9-5rp9-4mv9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-05",
      "url": "https://github.com/diesel-rs/diesel/pull/2663",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use after free"
      ]
    },
    "affected": {
      "functions": {
        "diesel::SqliteConnection::query_by_name": [
          "< 1.4.6"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.4.6"
      ]
    },
    "text": "\n\n# Fix a use-after-free bug in diesels Sqlite backend\n\nWe've misused `sqlite3_column_name`. The\n[SQLite](https://www.sqlite.org/c3ref/column_name.html) documentation\nstates that the following:\n\n> The returned string pointer is valid until either the prepared statement\n> is destroyed by sqlite3_finalize() or until the statement is automatically\n> reprepared by the first call to sqlite3_step() for a particular\n> run or until the next call to sqlite3_column_name()\n> or sqlite3_column_name16() on the same column.\n\nAs part of our `query_by_name` infrastructure we've first received all\nfield names for the prepared statement and stored them as string slices\nfor later use. After that we called `sqlite3_step()` for the first time,\nwhich invalids the pointer and therefore the stored string slice.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0365",
      "package": "diesel",
      "date": "2024-08-23",
      "url": "https://github.com/diesel-rs/diesel/pull/4170",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "sql",
        "injection",
        "overflow",
        "truncation"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.2.3"
      ]
    },
    "text": "\n\n# Binary Protocol Misinterpretation caused by Truncating or Overflowing Casts\n\nThe following presentation at this year's DEF CON was brought to our attention on the Diesel Gitter Channel:\n\n> SQL Injection isn't Dead: Smuggling Queries at the Protocol Level  \n> <http://web.archive.org/web/20240812130923/https://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20presentations/DEF%20CON%2032%20-%20Paul%20Gerste%20-%20SQL%20Injection%20Isn't%20Dead%20Smuggling%20Queries%20at%20the%20Protocol%20Level.pdf>  \n> (Archive link for posterity.)\nEssentially, encoding a value larger than 4GiB can cause the length prefix in the protocol to overflow, \ncausing the server to interpret the rest of the string as binary protocol commands or other data.\n\nIt appears Diesel _does_ perform truncating casts in a way that could be problematic, \nfor example: <https://github.com/diesel-rs/diesel/blob/ae82c4a5a133db65612b7436356f549bfecda1c7/diesel/src/pg/connection/stmt/mod.rs#L36>\n\nThis code has existed essentially since the beginning, \nso it is reasonable to assume that all published versions `<= 2.2.2` are affected.\n\n## Mitigation\n\nThe prefered migration to the outlined problem is to update to a Diesel version newer than 2.2.2, which includes \nfixes for the problem. \n\nAs always, you should make sure your application is validating untrustworthy user input. \nReject any input over 4 GiB, or any input that could _encode_ to a string longer than 4 GiB. \nDynamically built queries are also potentially problematic if it pushes the message size over this 4 GiB bound.\n\nFor web application backends, consider adding some middleware that limits the size of request bodies by default.\n\n## Resolution\n\nDiesel now uses `#[deny]` directives for the following Clippy lints:\n\n* [`cast_possible_truncation`](https://rust-lang.github.io/rust-clippy/master/#/cast_possible_truncation)\n* [`cast_possible_wrap`](https://rust-lang.github.io/rust-clippy/master/#/cast_possible_wrap)\n* [`cast_sign_loss`](https://rust-lang.github.io/rust-clippy/master/#/cast_sign_loss)\n\nto prevent casts that will lead to precision loss or other trunctations. Additionally we performed an \naudit of the relevant code.\n\nA fix is included in the `2.2.3` release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0061",
      "package": "libwebp-sys",
      "date": "2023-09-12",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "webp"
      ],
      "aliases": [
        "CVE-2023-4863",
        "CVE-2023-5129",
        "GHSA-j7hp-h8jx-5ppr"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.3"
      ]
    },
    "text": "\n\n# libwebp: OOB write in BuildHuffmanTable\n\n[Google](https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html) and [Mozilla](https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/) have released security advisories for RCE due to heap overflow in libwebp. Google warns the vulnerability has been exploited in the wild.\n\nlibwebp needs to be updated to 1.3.2 to include a patch for \"OOB write in BuildHuffmanTable\".\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0028",
      "package": "neon",
      "date": "2022-05-22",
      "url": "https://github.com/neon-bindings/neon/issues/896",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "incorrect-lifetime"
      ],
      "aliases": [
        "GHSA-8mj7-wxmc-f424"
      ]
    },
    "affected": {
      "functions": {
        "neon::types::JsArrayBuffer::external": [
          "< 0.10.1, >= 0.8.0"
        ],
        "neon::types::JsBuffer::external": [
          "< 0.10.1, >= 0.8.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.1"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n\n# Use after free in Neon external buffers\n\nNeon provides functionality for creating JavaScript `ArrayBuffer` (and the `Buffer` subtype) instances backed by bytes allocated outside of V8/Node. The [`JsArrayBuffer::external`](https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external) and [`JsBuffer::external`](https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external) did not require `T: 'static` prior to Neon `0.10.1`. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript `ArrayBuffer`.\n\nThe following example demonstrates use after free. It compiles on versions `<0.10.1` and fails to compile afterward.\n\n```rust\npub fn soundness_hole(mut cx: FunctionContext) -> JsResult<JsArrayBuffer> {\n    let mut data = vec![0u8, 1, 2, 3];\n    \n    // Creating an external from `&mut [u8]` instead of `Vec<u8>` since there is a blanket impl\n    // of `AsMut<T> for &mut T`\n    let buf = JsArrayBuffer::external(&mut cx, data.as_mut_slice());\n\n    // `buf` is still holding a reference to `data`!\n    drop(data);\n\n    Ok(buf)\n}\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0080",
      "package": "miow",
      "aliases": [
        "CVE-2020-35921",
        "GHSA-jrcf-4jp8-m28v"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-13",
      "url": "https://github.com/yoshuawuyts/miow/issues/38",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        "^ 0.2.2",
        ">= 0.3.6"
      ]
    },
    "text": "\n\n# `miow` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`miow`](https://crates.io/crates/miow) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0144",
      "package": "lzw",
      "date": "2020-02-10",
      "url": "https://github.com/nwin/lzw/issues/2",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.10.0"
      ]
    },
    "text": "\n\n# lzw is unmaintained\n\nThe author of the `lzw` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`weezl`](https://crates.io/crates/weezl)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0162",
      "package": "tokio-proto",
      "date": "2020-02-06",
      "informational": "unmaintained",
      "url": "https://github.com/tokio-rs/tokio-proto/commit/56c720ea3c74efa8f39e36c24e609628222b16a1"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `tokio-proto` is deprecated/unmaintained\n\nThe [`tokio-proto`](https://crates.io/crates/tokio-proto) crate has been deprecated, and [its GitHub repository](https://github.com/tokio-rs/tokio-proto) has been archived.\nUsers may be interested in [`tokio-tower`](https://crates.io/crates/tokio-tower) instead, per https://github.com/tokio-rs/tokio/issues/118#issuecomment-452969665\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0341",
      "package": "tls-listener",
      "date": "2024-03-15",
      "url": "https://github.com/tmccombs/tls-listener/security/advisories/GHSA-2qph-qpvm-2qf7",
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "aliases": [
        "CVE-2024-28854",
        "GHSA-2qph-qpvm-2qf7"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.0"
      ]
    },
    "affected": {
      "functions": {
        "tls_listener::TlsListener::new": [
          "< 0.10.0"
        ]
      }
    },
    "text": "\n\n# Slow loris vulnerability with default configuration\n\ntls-listener is a rust lang wrapper around a connection listener to support TLS. With the default configuration of tls-listener, a malicious user can open 6.4 `TcpStream`s a second, sending 0 bytes, and can trigger a DoS. The default configuration options make any public service using `TlsListener::new()` vulnerable to a slow-loris DoS attack. This impacts any publicly accessible service using the default configuration of tls-listener in versions prior to 0.10.0. Users are advised to upgrade. Users unable to upgrade may mitigate this by passing a large value, such as `usize::MAX` as the parameter to `Builder::max_handshakes`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0134",
      "package": "rental",
      "date": "2021-12-27",
      "informational": "unmaintained",
      "url": "https://github.com/jpernst/rental/commit/213671ab3aab3452efd7e2290c6bb714ee327014"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# rental is unmaintained, author has moved on\n\nThe author encourages users to explore other solutions, or maintain a fork.\n\nMaintained alternatives include:\n\n* [`ouroboros`](https://crates.io/crates/ouroboros)\n* [`fortify`](https://crates.io/crates/fortify)\n* [`escher`](https://crates.io/crates/escher)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0367",
      "package": "gix-path",
      "date": "2024-08-31",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-v26r-4c9c-h3j6",
      "references": [
        "https://github.com/advisories/GHSA-v26r-4c9c-h3j6",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-45305"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:N",
      "keywords": [
        "configuration-failure",
        "information-leak"
      ],
      "aliases": [
        "CVE-2024-45305",
        "GHSA-v26r-4c9c-h3j6"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "functions": {
        "gix_path::env::installation_config": [
          "*"
        ],
        "gix_path::env::installation_config_prefix": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.10"
      ]
    },
    "text": "\n\n# gix-path uses local config across repos when it is the highest scope\n\n### Summary\n\n`gix-path` executes `git` to find the path of a configuration file that belongs to the `git` installation itself, but mistakenly treats the local repository's configuration as system-wide if no higher scoped configuration is found. In rare cases, this causes a less trusted repository to be treated as more trusted, or leaks sensitive information from one repository to another, such as sending credentials to another repository's remote.\n\n### Details\n\nIn `gix_path::env`, the underlying implementation of the `installation_config` and `installation_config_prefix` functions calls `git config -l --show-origin` and parses the first line of the output to extract the path to the configuration file holding the configuration variable of highest [scope](https://git-scm.com/docs/git-config#SCOPES):\n\n<https://github.com/Byron/gitoxide/blob/12251eb052df30105538fa831e641eea557f13d8/gix-path/src/env/git/mod.rs#L91>\n\n<https://github.com/Byron/gitoxide/blob/12251eb052df30105538fa831e641eea557f13d8/gix-path/src/env/git/mod.rs#L112>\n\nWhile the configuration variable of highest scope is not usually in the local scope, there are practical situations where this occurs:\n\n- A configuration file truly associated with the installation is not present on all systems and can occasionally be empty. Likewise, there may be no variables in the global scope.\n- Configuration files associated with those higher scopes may be deliberately skipped by setting the `GIT_CONFIG_SYSTEM` and `GIT_CONFIG_GLOBAL` environment variables to `/dev/null` (or to `NUL` on Windows). This prevents `gix-path` from finding the path of configuration files for those scopes, while not preventing downstream components such as the function in `gix-config` from reporting a local path as being associated with the installation.\n- The `GIT_CONFIG_NOSYSTEM` environment variable can be used to disable configuration associated with the installation. (`GIT_CONFIG_NOSYSTEM=1` is more powerful than `GIT_CONFIG_SYSTEM=/dev/null` on systems where an additional \"unknown\" scope is associated with the installation, as occurs on macOS with Apple Git.) This will cause the local scope to be the highest nonempty scope under even more situations, though in practice it is less dangerous because most, though possibly not all, downstream components would disregard the value.\n\nA user may use either or both of the latter two techniques to turn off an undesired configuration or to create a more replicable environment. Such a user would expect that this results in a more controlled configuration.\n\nOften, when located inside one repository, a user performs operations on that repository or that are not specific to any repository. In such use, local configuration is typically desired or at least acceptable, and mistaking it as coming from another scope is not typically harmful.\n\nHowever, sometimes a user is in one repository and operates on another repository. A major case where this occurs is cloning one repository while located in another. This can be done in an ad-hoc fashion, including when cloning the repository outside of the one we are inside. It may also potentially be automated by an application for purposes such as submodule handling. Two kinds of problems are anticipated:\n\n- A less secure configuration may be set for a specific repository where it is judged acceptable, even though it would not be wanted for other repositories, such as to enable a protocol or set up debugging.\n- More likely, a configuration that supplies secrets for use in one repository's remote can be used to send those secrets to another repository's remote.\n\n### PoC\n\nIn this example, we send mock `Authorization: Basic ...` credentials meant for one repository's remote to another remote, by running `gix` while inside the first repository to clone the second repository.\n\nThese instructions are written for a Unix shell, but they will work in other shells, including in PowerShell on Windows if the method of setting environment variables is adapted and `/dev/null` is replaced with `NUL`. This procedure is likely to demonstrate the problem on all systems *except* macOS. This is due to the high-scoped \"unknown\" configuration that usually accompanies Apple Git, and reflects that gix-path is in practice much less vulnerable on macOS (though still potentially vulnerable).\n\n1. Install [`dummyhttp`](https://crates.io/crates/dummyhttp) to serve as a local HTTP server for the demonstration.\n\n2. Obtain a build of `gitoxide` with the `max` feature set enabled. While this vulnerability affects other builds, this example requires `max` for `http.extraHeader` support.\n\n   Running `cargo install gitoxide` will install such a build though it may build against a patched version of `gix-path`. Cloning the repository ([`12251eb`](https://github.com/Byron/gitoxide/commit/12251eb052df30105538fa831e641eea557f13d8) and earlier are affected) and building with `cargo build` or `cargo install --path .` are also sufficient. In contrast, installing from published binaries with `binstall` or `quickinstall` does not provide the `max` feature, as of this writing.\n\n3. Run: `dummyhttp -i 127.0.0.1 -c 403 -v`\n\n4. In a separate terminal, create a new local repository and set up a mock remote and `http.extraHeader` configuration:\n\n   ```sh\n   git init myrepo\n   cd myrepo\n   git remote add origin http://127.0.0.1:8080/mygit.git\n   git config --local http.extraHeader 'Authorization: Basic abcde'\n   ```\n\n5. Make sure the testing setup is working by running `gix fetch` in the repository and checking that it fails in the expected way. In the terminal where that is run, a message should be shown indicating an HTTP 403 error. The more interesting output is in the terminal where `dummyhttp` is running, which should look like this:\n\n   ```text\n   2024-30-30 03:30:16 127.0.0.1:55689 GET /myrepo.git/info/refs?service=git-upload-pack HTTP/1.1\n   \u250c\u2500Incoming request\n   \u2502 GET /myrepo.git/info/refs?service=git-upload-pack HTTP/1.1\n   \u2502 Accept: */*\n   \u2502 Authorization: Basic abcde\n   \u2502 Git-Protocol: version=2\n   \u2502 Host: 127.0.0.1:8080\n   \u2502 User-Agent: git/oxide-0.42.2\n   \u250c\u2500Outgoing response\n   \u2502 HTTP/1.1 403 Forbidden\n   \u2502 Content-Length: 9\n   \u2502 Content-Type: text/plain; charset=utf-8\n   \u2502 Date: Fri, 30 Aug 2024 03:30:16 -0400\n   ```\n\n   Some details may differ, especially dates and times. But `Authorization: Basic abcde` should be shown.\n\n6. Now, in the terminal where you ran `gix fetch`, try cloning a separate repository:\n\n   ```sh\n   gix clone http://127.0.0.1:8080/other.git\n   ```\n\n   Check the output appended in the terminal where `dummyhttp` is running. This is to observe that `Authorization: Basic abcde` was rightly *not* sent.\n\n   Alternatively, if it *does* appear, then your system may be in one of the uncommon configurations that is vulnerable without further action.\n\n7. Now rerun that command, but with a modified environment, to cause `gix-path` to wrongly treat configuration from the local scope as being associated with the `git` installation:\n\n   ```sh\n   env GIT_CONFIG_SYSTEM=/dev/null GIT_CONFIG_GLOBAL=/dev/null gix clone http://127.0.0.1:8080/other.git\n   ```\n\n   Check the output appended in the terminal where `dummyhttp` is running. Observe that `Authorization: Basic abcde` was wrongly sent.\n\nWhile this procedure uses the same remote host for both repositories, this is not a required element. If the second repository had a different, untrusted host, the extra header would still be sent.\n\n### Impact\n\nIt is believed to be very difficult to exploit this vulnerability deliberately, due to the need either to anticipate a situation in which higher-scoped configuration variables would be absent, or to arrange for this to happen. Although any operating system may be affected, users running Apple Git on macOS are much less likely to be affected.\n\nIn the example shown above, more secure general practices would avoid it: using a credential manager, or even using `http.<url>.extraHeader` with as specific a `<url>` as possible, rather than the more general `http.extraHeader`. Many scenarios are analogous: if each repository's configuration is as secure as possible for how the repository is used, and secrets are stored securely and separately, then the circumstances under which an unacceptably unsecure configuration is used, or under which a leak of credentials would occur, become unlikely.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0355",
      "package": "gix-path",
      "date": "2024-07-18",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-mgvv-9p9g-3jv4",
      "references": [
        "https://github.com/advisories/GHSA-mgvv-9p9g-3jv4"
      ],
      "categories": [
        "code-execution",
        "privilege-escalation"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:L",
      "keywords": [
        "search-path"
      ],
      "aliases": [
        "CVE-2024-40644",
        "GHSA-mgvv-9p9g-3jv4"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "os": [
        "windows"
      ],
      "functions": {
        "gix_path::env::exe_invocation": [
          "*"
        ],
        "gix_path::env::installation_config": [
          "*"
        ],
        "gix_path::env::installation_config_prefix": [
          "*"
        ],
        "gix_path::env::system_prefix": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.9"
      ],
      "unaffected": [
        "< 0.10.8"
      ]
    },
    "text": "\n\n# gix-path can use a fake program files location\n\n### Summary\n\nWhen looking for Git for Windows so it can run it to report its paths, `gix-path` can be tricked into running another `git.exe` placed in an untrusted location by a limited user account.\n\n### Details\n\nWindows permits limited user accounts without administrative privileges to create new directories in the root of the system drive. While `gix-path` first looks for `git` using a `PATH` search, in version 0.10.8 it also has a fallback strategy on Windows of checking [two hard-coded paths](https://github.com/Byron/gitoxide/blob/6cd8b4665bb7582f744c3244abaef812be39ec35/gix-path/src/env/git.rs#L9-L14) intended to be the 64-bit and 32-bit Program Files directories:\n\n```rust\n/// Other places to find Git in.\n#[cfg(windows)]\npub(super) static ALTERNATIVE_LOCATIONS: &[&str] = &[\n    \"C:/Program Files/Git/mingw64/bin\",\n    \"C:/Program Files (x86)/Git/mingw32/bin\",\n];\n```\n\nExisting functions, as well as the newly introduced `exe_invocation` function, were updated to make use of these alternative locations. This causes facilities in `gix_path::env` to directly execute `git.exe` in those locations, as well as to return its path or whatever configuration it reports to callers who rely on it.\n\nAlthough unusual setups where the system drive is not `C:`, or even where Program Files directories have non-default names, are technically possible, the main problem arises on a 32-bit Windows system. Such a system has no `C:\\Program Files (x86)` directory.\n\nA limited user on a 32-bit Windows system can therefore create the `C:\\Program Files (x86)` directory and populate it with arbitrary contents. Once a payload has been placed at the second of the two hard-coded paths in this way, other user accounts including administrators will execute it if they run an application that uses `gix-path` and do not have `git` in a `PATH` directory.\n\n(While having `git` found in a `PATH` search prevents exploitation, merely having it installed in the default location under the real `C:\\Program Files` directory does not. This is because the first hard-coded path's `mingw64` component assumes a 64-bit installation.)\n\n### PoC\n\nOn a 32-bit (x86) Windows 10 system, with or without Git for Windows installed:\n\n1. Create a limited user account in `lusrmgr.msc` or the Settings application.\n2. Log in with that account and, using Windows Explorer or the `mkdir` command in PowerShell, create the directories `C:\\Program Files (x86)\\Git\\mingw32\\bin`. Although a limited user account cannot create regular files directly in `C:\\`, it can create directories including one called `Program Files (x86)`.\n3. Place a copy of `C:\\Windows\\system32\\calc.exe` in `C:\\Program Files (x86)\\Git\\mingw32\\bin` and rename it from `calc.exe` to `git.exe`. A different test payload may be used if preferred, and the executable need not already be signed or trusted.\n4. Log out, and log in as a different user. This user may be an administrator.\n5. If `gitoxide` is not installed, install it. If `cargo install gitoxide` is used for the installation, then the version of `gix-path` used in the installation can be observed.\n6. The vulnerability is only exploitable if `git` cannot be found in a `PATH` search. So, in PowerShell, run `gcm git` to check if `git` is present in the `PATH`. If so, temporarily remove it. One way to do this is for the current shell only, by running `$env:PATH` to inspect it and by assigning `$env:PATH = '...'` where `...` omits directories that contain `git`.\n7. Some commands that can be run outside a repository, and most commands that can be run inside a repository, will run the Calculator or other payload at least once per invocation. Try `gix clone foo` or, inside of a repository, `gix status`, `gix config`, `gix is-changed`, `gix fetch`, `ein t hours`, or `ein t query`. This is not exhaustive; most other `gix` and `ein` commands that access existing repository state or a network resource likewise run the payload.\n\n### Impact\n\nOnly Windows is affected. Exploitation is unlikely except on a 32-bit system. In particular, running a 32-bit build on a 64-bit system is not a risk factor. Furthermore, the attacker must have a user account on the system, though it may be a relatively unprivileged account. Such a user can perform privilege escalation and execute code as another user, though it may be difficult to do so reliably because the targeted user account must run an application or service that uses `gix-path` and must not have `git` in its `PATH`.\n\nThe main exploitable configuration is one where Git for Windows has been installed but not added to `PATH`. This is one of the options in its installer, though not the default option. Alternatively, an affected program that sanitizes its `PATH` to remove seemingly nonessential directories could allow exploitation. But for the most part, if the target user has configured a `PATH` in which the real `git.exe` can be found, then this cannot be exploited.\n\nThis vulnerability is comparable to [CVE-2022-24765](https://github.com/git-for-windows/git/security/advisories/GHSA-vw2c-22j4-2fh2), in which an uncontrolled path like `C:\\.git\\config`, which a limited user can create, could supply configuration used by other users. However, in this case, exploitation is slightly simpler because, rather than using configuration, an executable is directly run.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0371",
      "package": "gix-path",
      "date": "2024-09-06",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-m8rp-vv92-46c7",
      "references": [
        "https://github.com/advisories/GHSA-m8rp-vv92-46c7"
      ],
      "categories": [
        "code-execution",
        "privilege-escalation"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:N",
      "keywords": [
        "escape-sequences"
      ],
      "aliases": [
        "CVE-2024-45405",
        "GHSA-m8rp-vv92-46c7"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "functions": {
        "gix_path::env::installation_config": [
          "*"
        ],
        "gix_path::env::installation_config_prefix": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.11"
      ]
    },
    "text": "\n\n# gix-path improperly resolves configuration path reported by Git\n\n### Summary\n\n`gix-path` runs `git` to find the path of a configuration file associated with the `git` installation, but improperly resolves paths containing unusual or non-ASCII characters, in rare cases enabling a local attacker to inject configuration leading to code execution.\n\n### Details\n\nIn `gix_path::env`, the underlying implementation of the `installation_config` and `installation_config_prefix` functions calls `git config -l --show-origin` to find the path of a file to treat as belonging to the `git` installation.\n\nAffected versions of `gix-path` do not pass `-z`/`--null` to cause `git` to report literal paths ([`650a1b5`](https://github.com/Byron/gitoxide/commit/650a1b5cf25e086197cc55a68525a411e1c28031)). Instead, to cover the occasional case that `git` outputs a quoted path, they attempt to parse the path by stripping the quotation marks:\n\n<https://github.com/Byron/gitoxide/blob/1cfe577d461293879e91538dbc4bbfe01722e1e8/gix-path/src/env/git/mod.rs#L138-L142>\n\nThe problem is that, when a path is quoted, it may change in substantial ways beyond the concatenation of quotation marks. If not reversed, these changes can result in another valid path that is not equivalent to the original.\n\nThis is not limited to paths with unusual characters such as quotation marks or newlines. Unless `git` is explicitly configured with `core.quotePath` set to `false`, it also happens when the path contains most non-ASCII characters, including accented or non-English letters. For example, `\u00e9` is transformed to `\\303\\251`, with literal backslashes. (This is an octal representation of the bytes in its UTF-8 encoding. This behavior is not limited to systems that encode paths with UTF-8 on disk.)\n\nRarely, the configuration file `gix-path` wrongly attempts to open can be created by an attacker who has a limited user account on the system. The attacker would often need to request an account username tailored to carrying out the attack.\n\n### PoC\n\n#### Quick demonstration on Unix\n\nOn a Unix-like system in which Git supports no higher scope than `system` for configuration variables (i.e., not on macOS with Apple Git), in a locale that supports UTF-8, with `gitoxide` installed, run:\n\n```sh\nmkdir myrepo\ncd myrepo\ngit init\nprintf '[real]\\n\\trealvar = realval\\n' > '\u00e9'\nprintf '[fake]\\n\\tfakevar = fakeval\\n' > '\\303\\251'\nGIT_CONFIG_SYSTEM='\u00e9' gix config\n```\n\nIf the above conditions are satisfied and the `gix` command was built against an affected version of `gix-path`, then the last command's output looks something like this:\n\n```text\n# From '\\303\\251' (GitInstallation)\n[fake]\n        fakevar = fakeval\n\n# From '\u00e9' (System)\n[real]\n        realvar = realval\n\n# From '/home/ubuntu/.gitconfig' (User)\n[init]\n        defaultBranch = main\n\n# From './.git/config' (Local)\n[core]\n        repositoryformatversion = 0\n        filemode = true\n        bare = false\n        logallrefupdates = true\n```\n\n#### Demonstration across user accounts on Windows\n\nOn a test system running Windows on which Git for Windows is *not* installed system-wide\u2014resembling a scenario in which users who wish to use Git are expected to install it themselves for their accounts\u2014create two accounts, with these usernames:\n\n- *Ren\u00e9e*, the target of the attack. This user may be a limited user or an administrator. Its user profile directory is assumed to be `C:\\Users\\Ren\u00e9e`.\n- *Ren*, the user who carries out the attack. This user should be a limited user, since an administrator would not need to exploit this vulnerability to inject configuration. Its user profile directory is assumed to be `C:\\Users\\Ren`.\n\nAs *Ren*, run these commands in PowerShell:\n\n```powershell\n$d = \"$HOME\\303\\251e\\AppData\\Local\\Programs\\Git\\etc\"\nmkdir $d\ngit config --file $d\\gitconfig core.sshCommand calc.exe\nicacls $HOME\\303 /grant 'Ren\u00e9e:(RX)' /T\n```\n\n(The `gitconfig` file can instead be written manually, in which case *Ren* need not have `git`.)\n\nAs *Ren\u00e9e*:\n\n1. Install Git for Windows in the default location for non-systemwide installations, which for that user account is inside `C:\\Users\\Ren\u00e9e\\AppData\\Local\\Programs`. For a non-administrative installation, Git for Windows will pick this location automatically. Allow the installer to place the directory containing `git` in the user's `PATH`, as it does by default.\n\n   (The scenario can be modified for any location the attacker can predict. So, for example, *Ren\u00e9e* can install Git for Windows with [`scoop`](https://scoop.sh/), and *Ren* could carry out the attack with correspondingly modified path components in place of `AppData\\Local\\Programs\\Git`.)\n\n2. Install `gitoxide` using any common technique, such as by [installing Rust](https://www.rust-lang.org/tools/install) and then running `cargo install gitoxide`.\n\n3. Open a PowerShell window and run a `gix` command that attempts to run the SSH client for transport. For example:\n\n   ```pwsh\n   gix clone ssh://localhost/myrepo.git\n   ```\n\n   At least one, and usually two, instances of the Windows calculator will pop up. This happens because `calc.exe` was configured in the fake configuration file the user *Ren* was able to cause to be used, by placing it at the location `gix-path` wrongly resolved the path of *Ren\u00e9e*'s own configuration file to.\n\nThe `gitconfig` file written by the attacker can be adjusted with an arbitrary choice of payload, or to set other configuration variables.\n\n### Impact\n\nOn a single-user system, it is not possible to exploit this, unless `GIT_CONFIG_SYSTEM` and `GIT_CONFIG_GLOBAL` have been set to unusual values or Git has been installed in an unusual way. Such a scenario is not expected.\n\nExploitation is unlikely even on a multi-user system, though it is plausible in some uncommon configurations or use cases. It is especially unlikely with Apple Git on macOS, due to its very high scoped configuration in `/Library` or `/Applications` that would be detected instead, as in [CVE-2024-45305](https://github.com/advisories/GHSA-v26r-4c9c-h3j6).\n\nThe likelihood of exploitation may be higher on Windows, where attacks such as those shown in the Windows proof-of-concept above can be performed due to the status of `\\` as a directory separator, and where there is no restriction on usernames containing accented or non-English letters (though the latter is also permitted on some other systems). Even then, complex user interaction is required. In most cases, a system administrator would have to approve an innocuous-seeming username, and then the targeted user (who could be the same or a different user) would have to use an application that uses `gix-path`.\n\nIn general, exploitation is more likely to succeed if at least one of the following applies:\n\n- Users are expected to install `git` themselves, and are likely to do so in predictable locations.\n- Locations where `git` is installed, whether due to usernames in their paths or otherwise, contain characters that `git` quotes by default in paths, such as non-English letters and accented letters.\n- A custom `system`-scope configuration file is specified with the `GIT_CONFIG_SYSTEM` environment variable, and its path is in an unusual location or has strangely named components.\n- A `system`-scope configuration file is absent, empty, or suppressed by means other than `GIT_CONFIG_NOSYSTEM`. Currently, `gix-path` can treat a `global`-scope configuration file as belonging to the installation if no higher scope configuration file is available. This increases the likelihood of exploitation even on a system where `git` is installed system-wide in an ordinary way.\n\nHowever, exploitation is expected to be very difficult even under any combination of those factors.\n\nAlthough the effect here is similar to [CVE-2022-24765](https://github.com/git-for-windows/git/security/advisories/GHSA-vw2c-22j4-2fh2) once exploited, a greater degree of user interaction would usually be required, and the attack complexity here is much higher because the necessary conditions are uncommon and challenging to predict.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0054",
      "package": "rkyv",
      "date": "2021-04-28",
      "url": "https://github.com/djkoloski/rkyv/issues/113",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "uninitialized",
        "memory",
        "information",
        "leak"
      ],
      "aliases": [
        "CVE-2021-31919",
        "GHSA-w5cr-frph-hw7f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.6.0"
      ]
    },
    "affected": {
      "functions": {
        "rkyv::Archive::resolve": [
          "< 0.6.0"
        ]
      }
    },
    "text": "\n\n# Archives may contain uninitialized memory\n\n`rkyv` is a serialization framework that writes struct-compatible memory to be stored or\ntransmitted. During serialization, struct padding bytes and unused enum bytes may not be\ninitialized. These bytes may be written to disk or sent over unsecured channels.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0023",
      "package": "openssl",
      "date": "2023-03-24",
      "url": "https://github.com/sfackler/rust-openssl/pull/1854",
      "categories": [
        "file-disclosure"
      ],
      "aliases": [
        "GHSA-9qwg-crg9-m2vc"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::extension::SubjectAlternativeName::new": [
          "< 0.10.48, >=0.9.7"
        ],
        "openssl::x509::extension::ExtendedKeyUsage::other": [
          "< 0.10.48, >=0.9.7"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.48"
      ]
    },
    "text": "\n\n# `openssl` `SubjectAlternativeName` and `ExtendedKeyUsage::other` allow arbitrary file read\n\n`SubjectAlternativeName` and `ExtendedKeyUsage` arguments were parsed using the OpenSSL\nfunction `X509V3_EXT_nconf`. This function parses all input using an OpenSSL mini-language\nwhich can perform arbitrary file reads.\n\nThanks to David Benjamin (Google) for reporting this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0044",
      "package": "openssl",
      "date": "2023-06-20",
      "url": "https://github.com/sfackler/rust-openssl/issues/1965",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "GHSA-xcf7-rvmh-g6q4"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::verify::X509VerifyParamRef::set_host": [
          "< 0.10.55, >=0.10.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.55"
      ]
    },
    "text": "\n\n# `openssl` `X509VerifyParamRef::set_host` buffer over-read\n\nWhen this function was passed an empty string, `openssl` would attempt to call `strlen` on it, reading arbitrary memory until it reached a NUL byte.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0357",
      "package": "openssl",
      "date": "2024-07-21",
      "url": "https://github.com/sfackler/rust-openssl/pull/2266"
    },
    "affected": {
      "functions": {
        "openssl::bio::MemBio::get_buf": [
          "< 0.10.66, >=0.8.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.66"
      ]
    },
    "text": "\n\n# `MemBio::get_buf` has undefined behavior with empty buffers\n\nPreviously, `MemBio::get_buf` called `slice::from_raw_parts` with a null-pointer, which violates the functions invariants, leading to undefined behavior. In debug builds this would produce an assertion failure. This is now fixed.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0001",
      "package": "openssl",
      "aliases": [
        "CVE-2016-10931",
        "GHSA-34p9-f4q3-c4r7"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2016-11-05",
      "keywords": [
        "ssl",
        "mitm"
      ],
      "url": "https://github.com/sfackler/rust-openssl/releases/tag/v0.9.0"
    },
    "versions": {
      "patched": [
        ">= 0.9.0"
      ]
    },
    "text": "\n\n# SSL/TLS MitM vulnerability due to insecure defaults\n\nAll versions of rust-openssl prior to 0.9.0 contained numerous insecure defaults\nincluding off-by-default certificate verification and no API to perform hostname\nverification.\n\nUnless configured correctly by a developer, these defaults could allow an attacker\nto perform man-in-the-middle attacks.\n\nThe problem was addressed in newer versions by enabling certificate verification\nby default and exposing APIs to perform hostname verification. Use the\n`SslConnector` and `SslAcceptor` types to take advantage of these new features\n(as opposed to the lower-level `SslContext` type).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0022",
      "package": "openssl",
      "date": "2023-03-24",
      "url": "https://github.com/sfackler/rust-openssl/pull/1854",
      "categories": [
        "thread-safety"
      ],
      "aliases": [
        "GHSA-3gxf-9r58-2ghg"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::X509NameBuilder::build": [
          "< 0.10.48, >=0.9.7"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.48"
      ]
    },
    "text": "\n\n# `openssl` `X509NameBuilder::build` returned object is not thread safe\n\nOpenSSL has a `modified` bit that it can set on on `X509_NAME` objects. If this\nbit is set then the object is not thread-safe even when it appears the code is\nnot modifying the value.\n\nThanks to David Benjamin (Google) for reporting this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0072",
      "package": "openssl",
      "date": "2023-11-23",
      "url": "https://github.com/sfackler/rust-openssl/issues/2096",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-xphf-cx8h-7q9g"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::store::X509StoreRef::objects": [
          "< 0.10.60, >=0.10.29"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.60"
      ]
    },
    "text": "\n\n# `openssl` `X509StoreRef::objects` is unsound\n\nThis function returned a shared reference into an OpenSSL datastructure but did not account for interior mutability. OpenSSL may modify the data behind this reference, meaning accesses can race and the reference is unsound.\n\nUse of this function should be replaced with `X509StoreRef::all_certificates`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0024",
      "package": "openssl",
      "date": "2023-03-24",
      "url": "https://github.com/sfackler/rust-openssl/pull/1854",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "GHSA-6hcf-g6gr-hhcr"
      ]
    },
    "affected": {
      "functions": {
        "openssl::x509::X509Extension::new": [
          "< 0.10.48, >=0.9.7"
        ],
        "openssl::x509::X509Extension::new_nid": [
          "< 0.10.48, >=0.9.7"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.10.48"
      ]
    },
    "text": "\n\n# `openssl` `X509Extension::new` and `X509Extension::new_nid` null pointer dereference\n\nThese functions would crash when the context argument was None with certain extension types.\n\nThanks to David Benjamin (Google) for reporting this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0010",
      "package": "openssl",
      "aliases": [
        "CVE-2018-20997",
        "GHSA-xjxc-vfw2-cg96"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-06-01",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/sfackler/rust-openssl/pull/942"
    },
    "versions": {
      "patched": [
        ">= 0.10.9"
      ],
      "unaffected": [
        "< 0.10.8"
      ]
    },
    "text": "\n\n# Use after free in CMS Signing\n\nAffected versions of the OpenSSL crate used structures after they'd been freed.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0049",
      "package": "actix-codec",
      "aliases": [
        "CVE-2020-35902",
        "GHSA-rqgx-hpg4-456r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-30",
      "url": "https://github.com/actix/actix-net/issues/91"
    },
    "versions": {
      "patched": [
        ">= 0.3.0-beta.1"
      ]
    },
    "text": "\n\n# Use-after-free in Framed due to lack of pinning\n\nAffected versions of this crate did not require the buffer wrapped in `Framed` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the affected functions accept `Pin<&mut Self>` instead of `&mut self`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0003",
      "package": "security-framework",
      "aliases": [
        "CVE-2017-18588",
        "GHSA-jqqr-c2r2-9cvr"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
      "date": "2017-03-15",
      "keywords": [
        "mitm"
      ],
      "url": "https://github.com/sfackler/rust-security-framework/pull/27"
    },
    "versions": {
      "patched": [
        ">= 0.1.12"
      ]
    },
    "text": "\n\n# Hostname verification skipped when custom root certs used\n\nIf custom root certificates were registered with a `ClientBuilder`, the\nhostname of the target server would not be validated against its presented leaf\ncertificate.\n\nThis issue was fixed by properly configuring the trust evaluation logic to\nperform that check.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0136",
      "package": "sass-rs",
      "date": "2021-04-07",
      "url": "https://github.com/compass-rs/sass-rs/issues/83",
      "informational": "unmaintained",
      "keywords": [
        "sass",
        "scss",
        "libsass"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `sass-rs` has been deprecated\n\nThe `sass-rs` crate is not maintained anymore as libsass is deprecated.\nConsider using https://github.com/connorskees/grass or https://github.com/kaj/rsass instead.\n(Author's recommendation.)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0019",
      "package": "actix-web",
      "categories": [
        "memory-corruption"
      ],
      "date": "2018-06-08",
      "url": "https://github.com/actix/actix-web/issues/289",
      "aliases": [
        "CVE-2018-25024",
        "CVE-2018-25025",
        "CVE-2018-25026",
        "GHSA-7x36-h62w-vw65",
        "GHSA-9qj6-4rfq-vm84",
        "GHSA-fgfm-hqjw-3265",
        "GHSA-w65j-g6c7-g3m4"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.15"
      ]
    },
    "text": "\n\n# Multiple memory safety issues\n\nAffected versions contain multiple memory safety issues, such as:\n\n - Unsoundly coercing immutable references to mutable references\n - Unsoundly extending lifetimes of strings\n - Adding the `Send` marker trait to objects that cannot be safely sent between threads\n\nThis may result in a variety of memory corruption scenarios, most likely use-after-free.\n \nA significant refactoring effort has been conducted to resolve these issues.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0029",
      "package": "rgb",
      "aliases": [
        "CVE-2020-25016",
        "GHSA-g4rw-8m5q-6453"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "date": "2020-06-14",
      "informational": "unsound",
      "keywords": [
        "type confusion"
      ],
      "url": "https://github.com/kornelski/rust-rgb/issues/35"
    },
    "versions": {
      "patched": [
        ">= 0.8.20"
      ],
      "unaffected": [
        "< 0.5.4"
      ]
    },
    "text": "\n\n# Allows viewing and modifying arbitrary structs as bytes\n\nAffected versions of rgb crate allow viewing and modifying data of any type `T` wrapped in `RGB<T>` as bytes,\nand do not correctly constrain `RGB<T>` and other wrapper structures to the types for which it is safe to do so.\n\nSafety violation possible for a type wrapped in `RGB<T>` and similar wrapper structures:\n\n * If `T` contains padding, viewing it as bytes may lead to exposure of contents of uninitialized memory.\n * If `T` contains a pointer, modifying it as bytes may lead to dereferencing of arbitrary pointers.\n * Any safety and/or validity invariants for `T` may be violated.\n \nThe issue was resolved by requiring all types wrapped in structures provided by RGB crate to implement an unsafe marker trait.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0132",
      "package": "compu-brotli-sys",
      "date": "2021-12-20",
      "url": "https://github.com/google/brotli/releases/tag/v1.0.9",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "CVE-2020-8927",
        "GHSA-5v8v-66v8-mwm7"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 1.0.9"
      ]
    },
    "text": "\n\n# Integer overflow in the bundled Brotli C library\n\nA buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nIf one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0035",
      "package": "quinn",
      "aliases": [
        "CVE-2021-28036",
        "GHSA-fhv4-fx3v-77w6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-03-04",
      "url": "https://github.com/quinn-rs/quinn/issues/968",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        "^0.5.4",
        "^0.6.2",
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# `quinn` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`quinn`](https://crates.io/crates/quinn) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0090",
      "package": "libsqlite3-sys",
      "date": "2022-08-03",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2022-35737",
      "categories": [
        "denial-of-service",
        "code-execution"
      ],
      "aliases": [
        "CVE-2022-35737",
        "GHSA-jw36-hf63-69r9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.25.1"
      ]
    },
    "text": "\n\n# `libsqlite3-sys` via C SQLite CVE-2022-35737\n\nIt was sometimes possible for SQLite versions >= 1.0.12, < 3.39.2 to allow an array-bounds overflow when large string were input into SQLite's `printf` function.\n\nAs `libsqlite3-sys` bundles SQLite, it is susceptible to the vulnerability. `libsqlite3-sys` was updated to bundle the patched version of SQLite [here](https://github.com/rusqlite/rusqlite/releases/tag/sys0.25.1).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0123",
      "package": "libp2p-deflate",
      "date": "2020-01-24",
      "url": "https://github.com/libp2p/rust-libp2p/issues/1932",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2020-36443",
        "GHSA-gvcp-948f-8f2p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.27.1"
      ]
    },
    "text": "\n\n# Contents of uninitialized memory exposed in DeflateOutput's AsyncRead implementation\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided trait function `AsyncRead::poll_read()`.\n\nArbitrary `AsyncRead::poll_read()` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 5ba266a by ensuring the newly allocated part of the buffer is zero-initialized before passing it to a user-provided `AsyncRead::poll_read()`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0035",
      "package": "chunky",
      "date": "2020-08-25",
      "informational": "unsound",
      "url": "https://github.com/aeplay/chunky/issues/2",
      "aliases": [
        "CVE-2020-36433",
        "GHSA-qg24-8xj4-gj2h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Chunk API does not respect align requirement\n\nChunk API does not respect the align requirement of types. Unaligned reference can be created with the API, which is an undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0062",
      "package": "matrix-sdk",
      "date": "2022-10-24",
      "url": "https://github.com/matrix-org/matrix-rust-sdk/issues/1110",
      "aliases": [
        "GHSA-fc4h-xcf3-qj5f"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.2"
      ],
      "unaffected": [
        "< 0.6.0"
      ]
    },
    "text": "\n\n# matrix-sdk 0.6.0 logs access tokens\n\nWhen sending Matrix requests using an affected version of `matrix-sdk` in an application that\nwrites logs using `tracing-subscriber` (in a way that includes fields of tracing spans such as\n`tracing_subscriber`s default text output from the `fmt` module), these logs will contain the\nuser's access token.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0046",
      "package": "cyfs-base",
      "date": "2023-06-15",
      "informational": "unsound",
      "url": "https://github.com/buckyos/CYFS/issues/275",
      "keywords": [
        "alignment",
        "unsound"
      ],
      "aliases": [
        "GHSA-g753-ghr7-q33w"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Misaligned pointer dereference in `ChunkId::new`\nThe function `ChunkId::new` creates a misaligned pointer by casting mutable pointer of `u8` slice which has alignment 1 to the mutable pointer of `u32` which has alignment 4, and dereference the misaligned pointer leading UB, which should not be allowed in safe function.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0084",
      "package": "libp2p",
      "date": "2022-07-12",
      "url": "https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8",
      "aliases": [
        "CVE-2022-23486",
        "GHSA-jvgw-gccv-q5p8"
      ],
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.45.1"
      ]
    },
    "text": "\n# libp2p Lack of resource management DoS\n\nlibp2p allows a potential attacker to cause victim p2p node to run out of memory\n\nThe out of memory failure can cause crashes where libp2p is intended to be used\nwithin large scale networks leading to potential Denial of Service (DoS) vector\n\nUsers should upgrade or reference the [DoS mitigation strategies](https://docs.libp2p.io/reference/dos-mitigation/).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0006",
      "package": "cache",
      "aliases": [
        "CVE-2021-25903",
        "GHSA-gh87-6jr3-8q47"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-01",
      "url": "https://github.com/krl/cache/issues/2",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "soundness"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Exposes internally used raw pointer\n\nAffected versions of this crate dereference a raw pointer that can be modified\nwithout using `unsafe` code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0128",
      "package": "cache",
      "date": "2020-11-24",
      "url": "https://github.com/krl/cache/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36448",
        "GHSA-g78p-g85h-q6ww"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Cache<K>: Send/Sync impls needs trait bounds on `K`\n\nAffected versions of this crate unconditionally implement Send/Sync for `Cache<K>`.\nThis allows users to insert `K` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<T>>` or `Rc<T>` as `K` in `Cache<K>`. It is also possible to create data races by using types like `Cell<T>` or `RefCell<T>` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0017",
      "package": "internment",
      "aliases": [
        "CVE-2020-35874",
        "GHSA-96w3-p368-4h8c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-05-28",
      "url": "https://github.com/droundy/internment/issues/11"
    },
    "affected": {
      "functions": {
        "internment::ArcIntern::drop": [
          ">= 0.3.12"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ],
      "unaffected": [
        "< 0.3.12"
      ]
    },
    "text": "\n\n# Use after free in ArcIntern::drop\n\n`ArcIntern::drop` has a race condition where it can release memory\nwhich is about to get another user. The new user will get a reference\nto freed memory.\n\nThis was fixed by serializing access to an interned object while it\nis being deallocated.\n\nVersions prior to 0.3.12 used stronger locking which avoided the problem.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0036",
      "package": "internment",
      "aliases": [
        "CVE-2021-28037",
        "GHSA-gppw-3h6h-v6q2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-03-03",
      "url": "https://github.com/droundy/internment/issues/20",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Intern<T>: Data race allowed on T\n\nAffected versions of this crate unconditionally implements `Sync` for `Intern<T>`.\nThis allows users to create data race on `T: !Sync`, which may lead to undefined behavior\n(for example, memory corruption).\n\nThe flaw was corrected in commit 2928a87 by adding the trait bound `T: Sync` in the `Sync` impl of `Intern<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0068",
      "package": "cocoon",
      "date": "2023-10-15",
      "url": "https://github.com/fadeevab/cocoon/issues/22",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N",
      "keywords": [
        "nonce",
        "stream-cipher"
      ],
      "aliases": [
        "GHSA-6878-6wc2-pf5h"
      ]
    },
    "affected": {
      "functions": {
        "cocoon::Cocoon::encrypt": [
          "<= 0.3.3"
        ],
        "cocoon::Cocoon::dump": [
          "<= 0.3.3"
        ],
        "cocoon::Cocoon::wrap": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::encrypt": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::dump": [
          "<= 0.3.3"
        ],
        "cocoon::MiniCocoon::wrap": [
          "<= 0.3.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Sequential calls of encryption API (`encrypt`, `wrap`, and `dump`) result in nonce reuse\n\n**Problem**: Trying to create a new encrypted message with the same cocoon\nobject generates the same ciphertext. It mostly affects `MiniCocoon` and\n`Cocoon` objects with custom seeds and RNGs (where `StdRng` is used under\nthe hood).\n\n**Note**: The issue does **NOT** affect objects created with **`Cocoon::new`**\nwhich utilizes `ThreadRng`.\n\n**Cause**: `StdRng` produces the same nonce because `StdRng::clone` resets its\nstate.\n\n**Measure**: Make encryption API mutable (`encrypt`, `wrap`, and `dump`).\n\n**Workaround**: Create a new cocoon object with a new **seed** per each\nencryption.\n\n## How to Reproduce\n\n```rust\nlet cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data1)?;\n\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n```\n\n## Workaround\n\nFor `cocoon <= 0.3.3`, create a new cocoon with a different **seed**\nper each `encrypt`/`wrap`/`dump` call.\n\n```rust\nlet cocoon = MiniCocoon::from_password(b\"password\", &[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data1)?;\n\n// Another seed: &[2; 32].\nlet cocoon = MiniCocoon::from_password(b\"password\", &[2; 32]);\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [53, 223, 209, 96, 130, 99, 209, 108, 83, 189, 123, 81, 19, 1]\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0004",
      "package": "base64",
      "aliases": [
        "CVE-2017-1000430",
        "GHSA-x67x-vg9m-65c3"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2017-05-03",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319"
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "text": "\n\n# Integer overflow leads to heap-based buffer overflow in encode_config_buf\n\nAffected versions of this crate suffered from an integer overflow bug when\ncalculating the size of a buffer to use when encoding base64 using the\n`encode_config_buf` and `encode_config` functions.  If the input string\nwas large, this would cause a buffer to be allocated that was too small.\nSince this function writes to the buffer using unsafe code, it would\nallow an attacker to write beyond the buffer, causing memory corruption\nand possibly the execution of arbitrary code.\n\nThis flaw was corrected by using checked arithmetic to calculate\nthe size of the buffer.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0142",
      "package": "syncpool",
      "date": "2020-11-29",
      "url": "https://github.com/Chopinsky/byte_buffer/issues/2",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2020-36462",
        "GHSA-r88h-6987-g79f",
        "GHSA-vp6r-mrq9-8f4h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.6"
      ]
    },
    "text": "\n\n# Send bound needed on T (for Send impl of `Bucket2`)\n\nAffected versions of this crate unconditionally implements `Send` for `Bucket2`. This allows sending non-Send types to other threads.\n\nThis can lead to data races when non Send types like `Cell<T>` or `Rc<T>` are contained inside `Bucket2` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nThe flaw was corrected in commit 15b2828 by adding a `T: Send` bound to the `Send` impl of `Bucket2<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0001",
      "package": "ferris-says",
      "date": "2024-01-13",
      "url": "https://github.com/rust-lang/ferris-says/pull/21",
      "informational": "unsound",
      "aliases": [
        "GHSA-v363-rrf2-5fmj"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ],
      "unaffected": [
        "<= 0.1.2"
      ]
    },
    "text": "\n\n# Unsound use of str::from_utf8_unchecked on bytes which are not UTF-8\n\nAffected versions receive a `&[u8]` from the caller through a safe API, and pass\nit directly to the unsafe `str::from_utf8_unchecked` function.\n\nThe behavior of `ferris_says::say` is undefined if the bytes from the caller\ndon't happen to be valid UTF-8.\n\nThe flaw was corrected in [ferris-says#21] by using the safe `str::from_utf8`\ninstead, and returning an error on invalid input. However this fix has not yet\nbeen published to crates.io as a patch version for 0.2.\n\nSeparately, [ferris-says#32] has introduced a different API for version 0.3\nwhich accepts input as `&str` rather than `&[u8]`, so is unaffected by this bug.\n\n[ferris-says#21]: https://github.com/rust-lang/ferris-says/pull/21\n[ferris-says#32]: https://github.com/rust-lang/ferris-says/pull/32\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0036",
      "package": "r2d2_odbc",
      "date": "2022-01-17",
      "informational": "unmaintained",
      "url": "https://github.com/Koka/r2d2-odbc/issues/128#issuecomment-958629171"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# project abandoned\n\nThe `r2d2-odbc-api` crate might be an alternative.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0012",
      "package": "arrow2",
      "date": "2022-03-04",
      "url": "https://github.com/jorgecarleitao/arrow2/issues/880",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-5j8w-r7g8-5472"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.1, < 0.8",
        ">= 0.8.2, < 0.9",
        ">= 0.9.2, < 0.10",
        ">= 0.10.0"
      ]
    },
    "text": "\n\n# Arrow2 allows double free in `safe` code\n\nThe struct `Ffi_ArrowArray` implements `#derive(Clone)` that is inconsistent with\nits custom implementation of `Drop`, resulting in a double free when cloned.\n\nCloning this struct in `safe` results in a segmentation fault, which is unsound.\n\nThis derive was removed from this struct. All users are advised to either:\n* bump the patch version of this crate (for versions `v0.7,v0.8,v0.9`), or\n* migrate to a more recent version of  the crate (when using `<0.7`).\n\nDoing so elimitates this vulnerability (code no longer compiles).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0081",
      "package": "safemem",
      "date": "2023-02-14",
      "url": "https://github.com/abonander/safemem",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# safemem is unmaintained\n\nThe latest crates.io release was in 2019. The repository has been archived by the author.\n\n## Migration\n\n- `safemem::copy_over(slice, src_idx, dest_idx, len);` can be replaced with `slice.copy_within(src_idx..src_idx+len, dest_idx);` as of `rust 1.37.0`.\n- `safemem::write_bytes(slice, byte);` can be replaced with `slice.fill(byte);` as of `rust 1.50.0`\n- `safemem::prepend(slice, vec);` can be replaced with\n\n  ```rust\n  let old_len = vec.len();\n  vec.extend_from_slice(slice);\n  vec.rotate_left(old_len);\n  ```\n  \n  as of `rust 1.26.0`\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0023",
      "package": "static_type_map",
      "date": "2022-05-11",
      "informational": "unmaintained",
      "url": "https://github.com/malobre/erased_set/issues/6"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `static_type_map` has been renamed to `erased_set`\n\nPlease use the `erased_set` crate going forward:\n\n<https://github.com/malobre/erased_set>\n\nThere will be no further releases of `static_type_map`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0130",
      "package": "bunch",
      "date": "2020-11-12",
      "url": "https://github.com/krl/bunch/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36450",
        "GHSA-jwph-qp5h-f9wj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Bunch<T> unconditionally implements Send/Sync\n\nAffected versions of this crate unconditionally implements `Send`/`Sync` for `Bunch<T>`.\nThis allows users to insert `T: !Sync` to `Bunch<T>`. It is possible to create a data race to a `T: !Sync` by invoking the `Bunch::get()` API (which returns `&T`) from multiple threads. It is also possible to send `T: !Send` to other threads by inserting `T` inside `Bunch<T>` and sending `Bunch<T>` to another thread, allowing to create a data race by inserting types like `T = Rc<_>`.\n\nSuch data races can lead to memory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0088",
      "package": "magnetic",
      "aliases": [
        "CVE-2020-35925",
        "GHSA-wv4p-jp67-jr97"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-29",
      "url": "https://github.com/johnshaw/magnetic/issues/9",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.1"
      ]
    },
    "text": "\n\n# MPMCConsumer/Producer allows sending non-Send type across threads\n\nAffected versions of this crate unconditionally implemented `Sync` and `Send` traits for `MPMCConsumer` and `MPMCProducer` types.\n\nThis allows users to send types that do not implement `Send` trait across thread boundaries, which can cause a data race.\n\nThe flaw was corrected in the 2.0.1 release by adding `T: Send` bound to affected Sync/Send trait implementations.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0348",
      "package": "gix-index",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-7w47-3wg8-547c",
      "references": [
        "https://github.com/advisories/GHSA-7w47-3wg8-547c",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35186"
      ],
      "categories": [
        "code-execution"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
      "keywords": [
        "directory-traversal"
      ],
      "aliases": [
        "CVE-2024-35186",
        "GHSA-7w47-3wg8-547c"
      ],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": [
        ">= 0.33.0"
      ]
    },
    "text": "\n\n# Traversal outside working tree enables arbitrary code execution\n\n### Summary\n\nDuring checkout, gitoxide does not verify that paths point to locations in the working tree. A specially crafted repository can, when cloned, place new files anywhere writable by the application.\n\n### Details\n\nAlthough `gix-worktree-state` checks for collisions with existing files, it does not itself check if a path is really in the working tree when performing a checkout, nor do the path checks in `gix-fs` and `gix-worktree` prevent this. Cloning an untrusted repository containing specially crafted tree or blob names will create new files outside the repository, or inside the repository or a submodule's `.git` directory. The simplest cases are:\n\n- A tree named `..` to traverse upward. This facilitates arbitrary code execution because files can be placed in one or more locations where they are likely to be executed soon.\n- A tree named `.git` to enter a `.git` directory. This facilitates arbitrary code execution because hooks can be installed.\n\nA number of alternatives that achieve the same effect are also possible, some of which correspond to specific vulnerabilities that have affected Git in the past:\n\n- A tree or blob whose name contains one or more `/`, to traverse upward or downward. For example, even without containing any tree named `..` or `.git`, a repository can represent a file named `../outside` or `.git/hooks/pre-commit`. This is distinct from the more intuitive case a repository containing trees that represent those paths.\n- In Windows, a tree or blob whose name contains one or more `\\`, to traverse upward or downward. (Unlike `/`, these are valid on other systems.) See [GHSA-xjx4-8694-q2fq](https://github.com/git/git/security/advisories/GHSA-xjx4-8694-q2fq).\n- On a case-insensitive filesystem (such as NTFS, APFS, or HFS+), a tree named as a case variant of `.git`.\n- On HFS+, a tree named like `.git` or a case variant, with characters added that HFS+ ignores [in collation](https://developer.apple.com/library/archive/technotes/tn/tn1150.html#StringComparisonAlgorithm). See https://github.com/git/git/commit/6162a1d323d24fd8cbbb1a6145a91fb849b2568f.\n- On NTFS, a tree equivalent to `.git` (or a case variant) by the use of [NTFS stream](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c54dec26-1551-4d3a-a0ea-4fa40f848eb3) notation, such as `.git::$INDEX_ALLOCATION`. See [GHSA-5wph-8frv-58vj](https://github.com/git/git/security/advisories/GHSA-5wph-8frv-58vj).\n- On an NTFS volume with [8.3 aliasing](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#short-vs-long-names) enabled, a tree named as `git~1` (or a case variant). See [GHSA-589j-mmg9-733v](https://github.com/git/git/security/advisories/GHSA-589j-mmg9-733v).\n\nWhen a checkout creates some files outside the repository directory but fails to complete, the repository directory is usually removed, but the outside files remain.\n\n### PoC\n\nFor simplicity, these examples stage a stand-in file with a valid name, modify the index, and commit. The instructions assume `sed` supports `-i`, which is the case on most systems. If using Windows, a Git Bash shell should be used.\n\n#### Example: Downward traversal to install hooks\n\n1. Create a new repository with `git init dangerous-repo-installs-hook` and `cd` into the directory.\n2. Create the stand-in called `.git@hooks@pre-commit`, with the *contents*:\n   ```sh\n   #!/bin/sh\n   printf 'Vulnerable!\\n'\n   date >vulnerable\n   ```\n3. Stage the stand-in: `git add --chmod=+x .git@hooks@pre-commit`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.git@hooks@pre-commit|.git/hooks/pre-commit|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, on another or the same machine:\n\n1. Clone the repository with a `gix clone \u2026` command.\n2. Enter the newly created directory.\n3. *Optionally* run `ls -l .git/hooks` to observe that the `pre-commit` hook is already present.\n4. Make a new file and commit it with `git`. This causes the payload surreptitiously installed as a `pre-commit` hook to run, printing the message `Vulnerable!` and creating a file in the current directory containing the current date and time.\n\nNote that the effect is not limited to modifying the current directory. The payload could be written to perform any action that the user who runs `git commit` is capable of.\n\n#### Example: Upward traversal to create a file above the working tree\n\n1. Create a new repository with `git init dangerous-repo-reaches-up`, and `cd` into the directory.\n2. Create the stand-in: `echo 'A file outside the working tree, somehow.' >..@outside`\n3. Stage the stand-in: `git add ..@outside`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.\\.@outside|../outside|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, as above, on the same or another machine, clone the repository with a `gix clone \u2026` command. Observe that a file named `outside` is present alongside (not inside) the cloned directory.\n\n### Impact\n\nAny use of `gix` or another application that makes use of `gix-worktree-state`, or otherwise relies on `gix-fs` and `gix-worktree` for validation, is affected, if used to clone untrusted repositories. The above description focuses on code execution, as that leads to a complete loss of confidentiality, integrity, and availability, but creating files outside a working tree without attempting to execute code can directly impact integrity as well.\n\nIn use cases where no untrusted repository is ever cloned, this vulnerability has no impact. Furthermore, the impact of this vulnerability *may* be lower when `gix` is used to clone a repository for CI/CD purposes, even if untrusted, since in such uses the environment is usually isolated and arbitrary code is usually run deliberately from the repository with necessary safeguards in place.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0352",
      "package": "gix-index",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-49jc-r788-3fc9",
      "references": [
        "https://github.com/advisories/GHSA-49jc-r788-3fc9",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35197"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L",
      "aliases": [
        "CVE-2024-35197",
        "GHSA-49jc-r788-3fc9"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.33.0"
      ]
    },
    "text": "\n\n# Refs and paths with reserved Windows device names access the devices\n\n### Summary\n\nOn Windows, fetching refs that clash with legacy device names reads from the devices, and checking out paths that clash with such names writes arbitrary data to the devices. This allows a repository, when cloned, to cause indefinite blocking or the production of arbitrary message that appear to have come from the application, and potentially other harmful effects under limited circumstances.\n\n### Details\n\nIt is possible to create a Git repository that contains references or filenames that Windows treats as legacy DOS-style aliases for system devices. When such a repository is cloned:\n\n- In references, `gix-ref` does not include a check for such names before attempting to access them on disk, which reads from the devices, though the ability to exfiltrate data appears limited.\n- In paths, `gix-worktree-state` does not treat such names as collisions and instead writes to them, which writes arbitrary attacker-controlled data to the devices.\n\nSome such device names refer to devices that are often absent or inaccessible. But a few are guaranteed to be available, allowing some attacks to be carried out with low complexity. For both reading refs and writing paths, one important case is the console:\n\n- Reading a ref whose last component (e.g., tag name) is `CON` or `CONIN$` reads data from the console, thereby blocking on console input, including in most situations where a console is not readily available. This may facilitate denial of service attacks.\n- Checking out a file named `CON` or `CONOUT$` writes its contents to the console. This allows an untrusted repository to produce arbitrary text that appears to be a message from the application. Such text may facilitate social engineering if it is selected to instruct the user to perform a particular action.\n\nAnother potentially important case is serial ports. For example, `COM1` refers to the first serial port, if present. A malicious repository may be able to disrupt intended use of serial ports or attempt to interact with a device. In some configurations, it may be possible to interfere with the operation of a physical or virtual serial console. On Windows, local access to serial ports is often permitted even for limited user accounts without elevation.\n\n[Naming Files, Paths, and Namespaces](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions) covers most reserved names. `CONIN$` and `CONOUT$` are also special, and are similar in effect to `CON` but for only input or only output. These names are case-insensitive and can also be accessed with file extensions (e.g, `CON.txt` is equivalent to `CON`) and with some variations involving added spaces or colons.\n\n### PoC\n\n#### Ref example\n\nCreate a repository on a non-Windows system (or in WSL) with at least one commit. Use `git tag CON` to create a lightweight tag named `CON`. Place the repository somewhere it can be cloned on Windows. A `file://` URL is sufficient for testing if a private remote is unavailable. If using `git push`, pass `--tags` so the remote has the tag.\n\nOn a Windows system, clone the repository with `gix clone`. This command will block immediately, reading input from the console. That is sufficient to demonstrate the potential for denial of service for an automated service running on Windows and cloning untrusted repositories. The experiment can be stopped with <kbd>Ctrl</kbd>+<kbd>C</kbd>.\n\nHowever, if desired, input can be provided. Ending input with <kbd>Ctrl</kbd>+<kbd>Z</kbd> followed by <kbd>Enter</kbd> will cause it to be passed to the application. This will lead to an error message, the specific details of which vary by whether the input is empty or nonempty, and whether it matches or does not match the hexadecimal hash of the tagged commit.\n\n#### Path example\n\nCreate a repository on a non-Windows system (or in WSL) and commit a file named `CON` with the contents:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n```\n\nWhile that example text serves to illustrate the risk, any distinctive text is sufficient to observe the vulnerability. Place the repository somewhere it can be cloned on Windows. As above, a `file://` URL is sufficient.\n\nOn a Windows system, clone the repository with `gix clone`. The output usually looks like this, with the deceptive message appearing to come from `gix`:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n 04:45:15 indexing done 3.0 objects in 0.00s (12.1K objects/s)\n 04:45:15 decompressing done 309B in 0.00s (1.2MB/s)\n 04:45:15     Resolving done 3.0 objects in 0.05s (58.0 objects/s)\n 04:45:15      Decoding done 309B in 0.05s (6.0KB/s)\n 04:45:15 writing index file done 1.2KB in 0.00s (7.0MB/s)\n 04:45:15  create index file done 3.0 objects in 0.05s (55.0 objects/s)\n 04:45:15          read pack done 294B in 0.05s (5.4KB/s)\nError: IO error while writing blob or reading file metadata or changing filetype\n\nCaused by:\n    Incorrect function. (os error 1)\n```\n\nThe exact placement of the message is nondeterministic. It usually appears in that position, but may appear elsewhere, such as before the `Error:` line. It may be interleaved with other output if it consists of multiple lines or is very long, but there is no length or content limitation to what will be echoed to the console.\n\n### Impact\n\nIf Windows is not used, or untrusted repositories are not cloned or otherwise used, then there is no impact.\n\nThe impact is expected to be limited in common configurations, but may vary widely depending on what devices exist, how they are being used, how much knowledge an attacker has of the precise details of their use, and whether the user is likely to trust information that appears in a console. Accessing devices through refs is expected to be less dangerous than accessing them through filenames, since it is trivial to attempt to write arbitrary data using filenames.\n\nFor attacks using the `CON` or `CONOUT$` device names, the greatest risk is if a command the user would not otherwise run, and would not be convinced to run by untrusted instructions, seems reasonable when a trusted application such as `gix` appears to recommend it. The user may then be misled into running an attacker's command.\n\nA minor degradation in availability may also be possible, such as with a very large file named `CON`, though the user could usually interrupt the application.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0057",
      "package": "inventory",
      "date": "2023-09-10",
      "url": "https://github.com/dtolnay/inventory/pull/43",
      "informational": "unsound",
      "keywords": [
        "life-before-main"
      ],
      "aliases": [
        "GHSA-ghc8-5cgm-5rpf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Fails to prohibit standard library access prior to initialization of Rust standard library runtime\n\nAffected versions allow arbitrary caller-provided code to execute before the\nlifetime of `main`.\n\nIf the caller-provided code accesses particular pieces of the standard library\nthat require an initialized Rust runtime, such as `std::io` or `std::thread`,\nthese may not behave as documented. Panics are likely; UB is possible.\n\nThe flaw was corrected by enforcing that only code written within the\n`inventory` crate, which is guaranteed not to access runtime-dependent parts of\nthe standard library, runs before `main`. Caller-provided code is restricted to\nrunning at compile time.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0058",
      "package": "inventory",
      "date": "2023-09-10",
      "url": "https://github.com/dtolnay/inventory/pull/42",
      "informational": "unsound",
      "categories": [
        "thread-safety"
      ],
      "keywords": [
        "life-before-main"
      ],
      "aliases": [
        "GHSA-36xm-35qq-795w"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Exposes reference to non-Sync data to an arbitrary thread\n\nAffected versions do not enforce a `Sync` bound on the type of caller-provided\nvalue held in the plugin registry. References to these values are made\naccessible to arbitrary threads other than the one that constructed them.\n\nA caller could use this flaw to submit thread-unsafe data into inventory, then\naccess it as a reference simultaneously from multiple threads.\n\nThe flaw was corrected by enforcing that data submitted by the caller into\ninventory is `Sync`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0152",
      "package": "out-reference",
      "date": "2021-01-20",
      "url": "https://github.com/RustyYato/out-ref/issues/1",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "unsound",
        "raw-pointer"
      ],
      "aliases": [
        "GHSA-p7mj-xvxg-grff"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ],
      "unaffected": [
        "< 0.1.0"
      ]
    },
    "affected": {
      "functions": {
        "out_reference::Out::from_raw": [
          ">= 0.1.0, < 0.2.0"
        ]
      }
    },
    "text": "\n\n# `out_reference::Out::from_raw` should be `unsafe`\n\n`Out::from_raw` in affected versions allows writing a value to invalid memory address without requiring `unsafe`.\n\nThe soundness issue has been addressed by making `Out::from_raw` an unsafe function.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0037",
      "package": "async-graphql",
      "date": "2022-07-21",
      "url": "https://github.com/async-graphql/async-graphql/commit/521769b80039fc8043d1c9883e3d6e5b57359072",
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "aliases": [
        "GHSA-xq3c-8gqm-v648"
      ],
      "related": [
        "GHSA-4rx6-g5vg-5f3j"
      ]
    },
    "versions": {
      "patched": [
        ">= 4.0.6"
      ]
    },
    "text": "\n\n# Denial of service on deeply nested fragment requests\n\nDeeply nested fragments in a GraphQL request may cause a stack overflow in the server.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0099",
      "package": "cosmos_sdk",
      "date": "2021-08-25",
      "informational": "unmaintained",
      "url": "https://github.com/cosmos/cosmos-rust/issues/113"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# Crate has been renamed to `cosmrs`\n\nThe `cosmos_sdk` crate, which provides a basic Rust SDK for the Cosmos ecosystem,\nhas rebranded to \u201cCosmRS\u201d in the spirit of other projects like CosmJS and CosmWasm.\n\nYou can find the new home here:\n\nhttps://github.com/cosmos/cosmos-rust/tree/main/cosmrs\n\nThe new crate name is `cosmrs`:\n\nhttps://crates.io/crates/cosmrs\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0077",
      "package": "memmap",
      "date": "2020-12-02",
      "url": "https://github.com/danburkert/memmap-rs/issues/90",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.7.0"
      ]
    },
    "text": "\n\n# memmap is unmaintained\n\nThe author of the `memmap` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`memmap2`](https://github.com/RazrFalcon/memmap2-rs)\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0031",
      "package": "nano_arena",
      "aliases": [
        "CVE-2021-28032",
        "GHSA-wp34-mqw5-jj85"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-31",
      "url": "https://github.com/bennetthardwick/nano-arena/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "aliasing",
        "unsound"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "affected": {
      "functions": {
        "nano_arena::Arena::split_at": [
          "< 0.5.2"
        ],
        "nano_arena::ArenaSplit::split_at": [
          "< 0.5.2"
        ]
      }
    },
    "text": "\n\n# split_at allows obtaining multiple mutable references to the same data\n\nAffected versions of this crate assumed that `Borrow<Idx>` was guaranteed to\nreturn the same value on `.borrow()`. The borrowed index value was used to\nretrieve a mutable reference to a value.\n\nIf the `Borrow<Idx>` implementation returned a different index, the split arena\nwould allow retrieving the index as a mutable reference creating two mutable\nreferences to the same element. This violates Rust's aliasing rules and allows\nfor memory safety issues such as writing out of bounds and use-after-frees.\n\nThe flaw was corrected in commit `6b83f9d` by storing the `.borrow()` value in\na temporary variable.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0042",
      "package": "ouroboros",
      "date": "2023-06-11",
      "url": "https://github.com/joshua-maros/ouroboros/issues/88",
      "informational": "unsound",
      "aliases": [
        "GHSA-87mf-9wg6-ppf8"
      ]
    },
    "versions": {
      "patched": [
        ">=0.16.0"
      ]
    },
    "text": "\n\n# Ouroboros is Unsound\n\n## Summary\n\nOuroboros has a soundness problem, but a fix has been implemented in 0.16.0.\n\n## More details:\n\nIn 0.15.0, Ouroboros works internally by creating a struct where all \nuses of 'this are replaced by 'static. However, a recent addition to \nMiri checks that references passed to functions are valid during the \nentire execution of the function, even when those references are \npassed inside a struct. This poses an issue for dropping \nself-referencing values, as the reference becomes invalid during the \ndropping process. Effectively, since self-referencing structs are \nnot allowed in vanilla Rust, there is no allowance for dropping data\nduring a function that has also been given a reference to that data. \nThere's usually no way to pass a and &a to the same function.\n\nA fix was attempted, where the struct would be turned in to a raw \nbyte array and only transformed back into the underlying data type \ninside each function. This is allowable as a reference can be \ncreated and die over the body of a function, as long as the \nreference was created inside the function. However, this is also \nnot sound if the original struct contains padding. There is no \nway to initialize padding bytes to a known value that Miri will \naccept, so when it is cast to an array some of the bytes contain \nuninitialized values. This is not acceptable (despite the fact \nthat these bytes are never read) due to the potential for \noptimizations that may read from the uninitialized bytes. Besides \nwhich, this fix does not allow for template or constant parameters \nas there is no way to check the size of a templated type without \ngiving specific, concrete values for the template parameters.\n\nThe final solution was to use this fix while wrapping the raw byte\narray in `MaybeUninit<>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0108",
      "package": "eventio",
      "aliases": [
        "CVE-2020-36216",
        "GHSA-69vj-xx27-g45w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-20",
      "url": "https://github.com/petabi/eventio/issues/33",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.1"
      ]
    },
    "text": "\n\n# Soundness issue: Input<R> can be misused to create data race to an object\n\n`Input<R>` implements `Send` without requiring `R: Send`.\n\nAffected versions of this crate allows users to send non-Send types to other threads,\nwhich can lead to undefined behavior such as data race and memory corruption.\n\nThe flaw was corrected in version 0.5.1 by adding `R: Send` bound to the `Send` impl of `Input<R>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0032",
      "package": "alpm-rs",
      "aliases": [
        "CVE-2020-35885",
        "GHSA-qc4m-gc8r-mg8m"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-08-20",
      "informational": "unsound",
      "url": "https://github.com/pigeonhands/rust-arch/issues/2"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# StrcCtx deallocates a memory region that it doesn't own\n\n`StrcCtx` deallocate a memory region that it doesn't own when `StrcCtx` is created without using `StrcCtx::new`.\nThis can introduce memory safety issues such as double-free and use-after-free to client programs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0083",
      "package": "blurhash",
      "date": "2023-09-19",
      "url": "https://github.com/whisperfish/blurhash-rs/security/advisories/GHSA-cxvp-82cq-57h2",
      "references": [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-42447"
      ],
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
      "keywords": [
        "panic",
        "untrusted input",
        "parsing"
      ],
      "aliases": [
        "CVE-2023-42447",
        "cxvp-82cq-57h2"
      ]
    },
    "affected": {
      "functions": {
        "blurhash::decode": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# blurhash: panic on parsing crafted blurhash inputs\n\n## Impact\nThe blurhash parsing code may panic due to multiple panic-guarded out-of-bounds accesses on untrusted input.\n\nIn a typical deployment, this may get triggered by feeding a maliciously crafted blurhashes over the network. These may include:\n- UTF-8 compliant strings containing multi-byte UTF-8 characters\n\n## Patches\nThe patches were released under version 0.2.0, which may require user intervention because of slight API churn.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0111",
      "package": "tremor-script",
      "date": "2021-09-16",
      "url": "https://github.com/tremor-rs/tremor-runtime/pull/1217",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2021-45701",
        "CVE-2021-45702",
        "GHSA-3pp4-64mp-9cg9",
        "GHSA-9qvw-46gf-4fv8",
        "GHSA-q2x5-6q7q-r872"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.11.6"
      ],
      "unaffected": [
        "<= 0.7.2"
      ]
    },
    "text": "\n\n# Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`\n\nAffected versions of this crate maintains references to memory that might have been freed already.\nIf affects the following two `tremor-script` language constructs:\n\n* A [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) where we assign the result back to the target expression\n  and the expression to be merged needs to reference the `event`:\n\n```\nlet state = merge state of event end;\n```\n\n* A [Patch](https://www.tremor.rs/docs/tremor-script/index#patch) where we assign the result back to the target expression\n  and the patch operations used need to reference the `event`:\n\n```\nlet state = patch state of insert event.key => event.value end;\n```\n\nFor constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization\nwas applied to manipulate the target value in-place, instead of cloning it.\n\nOur `Value` struct which underpins all event data in `tremor-script`, is representing as borrowed strings `beef::Cow<'lifetime, str>` \nthat reference the actual `Vec<u8>` the event is based upon. We keep the raw byte-array next to the event structure inside our `Event` struct as a self-referential struct,\nso we make sure that the structured `Value` and its references are valid across its whole lifetime.\n\nThe optimization was considered safe as long as it was only possible to merge or patche `event` data or static data.\nWhen `state` was introduced to `tremor-script` a new possibility existed, to keep `Value` data around for longer than the lifetime of an event.\nIf `event` data is merged or patched into `state` without cloning `state` first, it can still reference keys or values from\nthe previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.\n\n\n## Workaround\n\nIf an upgrade is not possible, a possible workaround is to avoid the optimization\nby introducing a temporary variable and not immediately reassigning to `state`:\n\n```\nlet tmp = merge state of event end;\nlet state = tmp\n```\n\n## Fix\n\nThe flaw was corrected in `tremor-script` version 0.11.6 via commit [1a2efcd](https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e) by removing the optimization\nand always clone the target expression of a [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) or [Patch](https://www.tremor.rs/docs/tremor-script/index#patch.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0103",
      "package": "molecule",
      "date": "2021-07-30",
      "url": "https://github.com/nervosnetwork/molecule/security/advisories/GHSA-82hm-vh7g-hrh9",
      "aliases": [
        "CVE-2021-45697",
        "GHSA-6p3c-v8vc-c244",
        "GHSA-82hm-vh7g-hrh9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.2"
      ]
    },
    "text": "\n\n#  Partial read is incorrect in molecule\n\nAnyone who uses total_size(..) function to partial read the length of any FixVec will get an incorrect result, due to an incorrect implementation. This has been resolved in the 0.7.2 release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0364",
      "package": "gitoxide-core",
      "date": "2024-08-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h",
      "references": [
        "https://github.com/advisories/GHSA-88g2-r9rw-g55h",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-43785",
        "https://github.com/Byron/gitoxide/issues/1534"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N",
      "keywords": [
        "terminal",
        "control-characters",
        "escape-sequences"
      ],
      "aliases": [
        "CVE-2024-43785",
        "GHSA-88g2-r9rw-g55h"
      ],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# gitoxide-core does not neutralize special characters for terminals\n\n### Summary\n\nThe `gix` and `ein` commands write pathnames and other metadata literally to terminals, even if they contain characters terminals treat specially, including ANSI escape sequences. This sometimes allows an untrusted repository to misrepresent its contents and to alter or concoct error messages.\n\n### Details\n\n`gitoxide-core`, which provides most underlying functionality of the `gix` and `ein` commands, does not neutralize newlines, backspaces, or control characters\u2014including those that form ANSI escape sequences\u2014that appear in a repository's paths, author and committer names, commit messages, or other metadata. Such text may be written as part of the output of a command, as well as appearing in error messages when an operation fails.\n\nANSI escape sequences are of particular concern because, when printed to a terminal, they can change colors, including to render subsequent text unreadable; reposition the cursor to write text in a different location, including where text has already been written; clear the terminal; set the terminal title-bar text to arbitrary values; render the terminal temporarily unusable; and other such operations.\n\nThe effect is mostly an annoyance. But the author of a malicious repository who can predict how information from the repository may be accessed can cause files in the repository to be concealed or otherwise misrepresented, as well as rewrite all or part of error messages, or mimic error messages convincingly by repositioning the cursor and writing colored text.\n\n### PoC\n\nOn a Unix-like system in a POSIX-compatible shell, run:\n\n```sh\ngit init misleading-path\ncd misleading-path\ntouch \"$(printf '\\033]0;Boo!\\007\\033[2K\\r\\033[91mError: Repository is corrupted. Run \\033[96mEVIL_COMMAND\\033[91m to attempt recovery.\\033[0m')\"\ngit add .\ngit commit -m 'Initial commit'\n```\n\nIn the repository\u2014or, if desired, in a clone of it, to show that this is exploitable by getting a user to clone an untrusted repository\u2014run this command, which outputs entries in a three-column form showing type, hash, and filename:\n\n```sh\ngix tree entries\n```\n\nAlthough the output is of that form, it does not appear to be. Instead, the output in a terminal looks like this, colorized to appear to be an error message, with `EVIL_COMMAND` in another color, and with no other text:\n\n```text\nError: Repository is corrupted. Run EVIL_COMMAND to attempt recovery.\n```\n\nIn some terminals, a beep or other sound will be made. In most terminals, the title bar text will be changed to `Boo!`, though in some shells this may be immediately undone when printing the prompt. These elements are included to showcase the abilities of ANSI escape sequences, but they are not usually themselves threats.\n\nTo see what is actually produced, `gix tree entries` can be piped to a command that displays special characters symbolically, such as `less` or `cat -v` if available.\n\n```text\nBLOB e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ESC]0;Boo!^GESC[2K^MESC[91mError: Repository is corrupted. Run ESC[96mEVIL_COMMANDESC[91m to attempt recovery.ESC[0m\n```\n\nThat shows the effect on `gix tree entries`, but various other commands are also affected, and the escape sequences and other special characters can also appear in non-path metadata, such as in the `user.name` used to create a commit.\n\n### Impact\n\nFor users who do not clone or operate in clones of untrusted repositories, there is no impact.\n\nWindows is much less affected than Unix-like systems due to limitations on what characters can appear in filenames, and because traditionally Windows terminals do not support as many ANSI escape sequences.\n\nBecause different `gix` and `ein` commands display different data in different formats, the author of a malicious repository must guess how it will be used, which complicates crafting truly convincing output, though it may be possible to craft a repository where `gix clone` fails to clone it but produces a misleading message.\n\nAlthough this is mainly exploitable on systems *other* than Windows, in the ability to produce misleading output this superficially resembles [CVE-2024-35197](https://github.com/advisories/GHSA-49jc-r788-3fc9). But this is much more limited, because:\n\n- The misleading output can only be made to go where the application is already sending output. Redirection is not defeated, and devices to access cannot be chosen by the attacker.\n- The misleading output can only be take place *when* the application is already producing output. This limitation complicates the production of believable messages.\n- Only terminals are affected. Even if a standard stream is redirected to another file or device, these special characters would not have a special effect, unless echoed later without sanitization.\n- Reading and blocking cannot be performed.\n- Applications other than the gitoxide `gix` and `ein` executables are unaffected. The exception is if another application uses `gitoxide-core`. But this is explicitly discouraged in the `gitoxide-core` documentation and is believed to be rare.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0048",
      "package": "stackvector",
      "aliases": [
        "CVE-2021-29939",
        "GHSA-9frf-r7c7-j2vg"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-19",
      "url": "https://github.com/Alexhuszagh/rust-stackvector/issues/2",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.9"
      ]
    },
    "text": "\n\n# StackVec::extend can write out of bounds when size_hint is incorrect\n\n`StackVec::extend` used the lower and upper bounds from an Iterator's\n`size_hint` to determine how many items to push into the stack based vector.\n\nIf the `size_hint` implementation returned a lower bound that was larger than\nthe upper bound, `StackVec` would write out of bounds and overwrite memory\non the stack. As mentioned by the [size_hint](https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods)\ndocumentation, `size_hint` is mainly for optimization and incorrect\nimplementations should not lead to memory safety issues.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0369",
      "package": "phonenumber",
      "date": "2024-07-07",
      "url": "https://github.com/whisperfish/rust-phonenumber/security/advisories/GHSA-mjw4-jj88-v687",
      "references": [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-39697"
      ],
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
      "keywords": [
        "panic",
        "untrusted input",
        "parsing"
      ],
      "aliases": [
        "CVE-2024-39697",
        "GHSA-mjw4-jj88-v687"
      ]
    },
    "affected": {
      "functions": {
        "phonenumber::parse": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">=0.3.6"
      ],
      "unaffected": [
        "< 0.3.3"
      ]
    },
    "text": "\n\n# phonenumber:  panic on parsing crafted phonenumber inputs\n\n### Impact\n\nThe phonenumber parsing code may panic due to a reachable `assert!` guard on the phonenumber string.\n\nIn a typical deployment of rust-phonenumber, this may get triggered by feeding a maliciously crafted phonenumber, e.g. over the network, specifically strings of the form `+dwPAA;phone-context=AA`, where the \"number\" part potentially parses as a number larger than 2^56.\n\nSince f69abee1/0.3.4/#52.\n\n0.2.x series is not affected.\n\n### Patches\nPatches have been published as version `0.3.6+8.13.36`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0082",
      "package": "phonenumber",
      "date": "2023-09-19",
      "url": "https://github.com/whisperfish/rust-phonenumber/security/advisories/GHSA-whhr-7f2w-qqj2",
      "references": [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-42444"
      ],
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H",
      "keywords": [
        "panic",
        "untrusted input",
        "parsing"
      ],
      "aliases": [
        "CVE-2023-42444",
        "whhr-7f2w-qqj2"
      ]
    },
    "affected": {
      "functions": {
        "phonenumber::parse": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.2.5, <0.3.0",
        ">=0.3.3"
      ]
    },
    "text": "\n\n# phonenumber:  panic on parsing crafted RF3966 phonenumber inputs \n\n### Impact\nThe phonenumber parsing code may panic due to a panic-guarded out-of-bounds access on the phonenumber string.\n\nIn a typical deployment of `rust-phonenumber`, this may get triggered by feeding a maliciously crafted phonenumber over the network, specifically the string `.;phone-context=`.\n\n### Patches\nPatches will be published as version `0.3.3+8.13.9` and backported as `0.2.5+8.11.3`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0083",
      "package": "evm",
      "date": "2022-10-25",
      "url": "https://github.com/rust-blockchain/evm/pull/133",
      "aliases": [
        "CVE-2022-39354",
        "GHSA-hhc4-47rh-cr34"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "categories": [
        "crypto-failure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.36.0"
      ]
    },
    "text": "\n\n# evm incorrect state transition\n\nSputnikVM, also called evm, is a Rust implementation of Ethereum Virtual Machine.\n\nA custom stateful precompile can use the `is_static` parameter to determine if\nthe call is executed in a static context (via `STATICCALL`), and thus decide\nif stateful operations should be done.\n\nPrior to version 0.36.0, the passed `is_static` parameter was incorrect -- it\nwas only set to `true` if the call came from a direct `STATICCALL` opcode.\n\nHowever, once a static call context is entered, it should stay static. The issue\nonly impacts custom precompiles that actually uses `is_static`.\n\nFor those affected, the issue can lead to possible incorrect state transitions.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0145",
      "package": "atty",
      "date": "2021-07-04",
      "url": "https://github.com/softprops/atty/issues/50",
      "references": [
        "https://github.com/softprops/atty/pull/51",
        "https://github.com/softprops/atty/issues/57"
      ],
      "keywords": [
        "unaligned-read"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-g98v-hv3f-hcfr"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Potential unaligned read\n\nOn windows, `atty` dereferences a potentially unaligned pointer.\n\nIn practice however, the pointer won't be unaligned unless a custom global allocator is used.\n\nIn particular, the `System` allocator on windows uses `HeapAlloc`, which guarantees a large enough alignment.\n\n# atty is Unmaintained\n\nA Pull Request with a fix has been provided over a year ago but the maintainer seems to be unreachable.\n\nLast release of `atty` was almost 3 years ago.\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n - [std::io::IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) - Stable since Rust 1.70.0\n - [is-terminal](https://crates.io/crates/is-terminal) - Standalone crate supporting Rust older than 1.70.0\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0375",
      "package": "atty",
      "date": "2024-09-25",
      "informational": "unmaintained",
      "url": "https://github.com/softprops/atty/issues/57"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `atty` is unmaintained\n\nThe maintainer of `atty` has [published](https://github.com/softprops/atty/commit/5bfdbe9e48c6ca6a4909e8d5b04f5e843a257e93) an official notice that the crate is no longer\nunder development, and that users should instead rely on the functionality in the standard library's [`IsTerminal`](https://doc.rust-lang.org/std/io/trait.IsTerminal.html) trait.\n\n## Alternative(s)\n\n- [std::io::IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) - Stable since Rust 1.70.0 and the recommended replacement per the `atty` maintainer.\n- [is-terminal](https://crates.io/crates/is-terminal) - Standalone crate supporting Rust older than 1.70.0\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0007",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-4304",
        "GHSA-p52g-cm5j-mjv4"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 111.25, < 300.0",
        ">= 300.0.12"
      ]
    },
    "text": "\n\n# Timing Oracle in RSA Decryption\n\nA timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0032",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-2097",
        "GHSA-3wx7-46ch-7rq2"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-07-05",
      "url": "https://www.openssl.org/news/secadv/20220705.txt"
    },
    "versions": {
      "patched": [
        ">= 111.22, < 300.0",
        ">= 300.0.9"
      ]
    },
    "text": "\n\n# AES OCB fails to encrypt some bytes\n\nAES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised\nimplementation will not encrypt the entirety of the data under some\ncircumstances.  This could reveal sixteen bytes of data that was\npreexisting in the memory that wasn't written.  In the special case of\n\"in place\" encryption, sixteen bytes of the plaintext would be revealed.\n\nSince OpenSSL does not support OCB based cipher suites for TLS and DTLS,\nthey are both unaffected.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0027",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-1343",
        "GHSA-mfm6-r9g2-q4r7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-05-03",
      "url": "https://www.openssl.org/news/secadv/20220503.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.6"
      ],
      "unaffected": [
        "< 300.0"
      ]
    },
    "text": "\n\n# `OCSP_basic_verify` may incorrectly verify the response signing certificate\n\nThe function `OCSP_basic_verify` verifies the signer certificate on an OCSP\nresponse. In the case where the (non-default) flag OCSP_NOCHECKS is used then\nthe response will be positive (meaning a successful verification) even in the\ncase where the response signing certificate fails to verify.\n\nIt is anticipated that most users of `OCSP_basic_verify` will not use the\nOCSP_NOCHECKS flag. In this case the `OCSP_basic_verify` function will return\na negative value (indicating a fatal error) in the case of a certificate\nverification failure. The normal expected return value in this case would be 0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0056",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-3450",
        "GHSA-8hfj-xrj2-pm22"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "categories": [
        "crypto-failure"
      ],
      "date": "2021-05-01",
      "url": "https://www.openssl.org/news/secadv/20210325.txt"
    },
    "versions": {
      "patched": [
        ">= 111.15"
      ],
      "unaffected": [
        "< 111.11"
      ]
    },
    "text": "\n\n# CA certificate check bypass with X509_V_FLAG_X509_STRICT\n\nThe X509_V_FLAG_X509_STRICT flag enables additional security checks of the\ncertificates present in a certificate chain. It is not set by default.\n\nStarting from OpenSSL version 1.1.1h a check to disallow certificates in\nthe chain that have explicitly encoded elliptic curve parameters was added\nas an additional strict check.\n\nAn error in the implementation of this check meant that the result of a\nprevious check to confirm that certificates in the chain are valid CA\ncertificates was overwritten. This effectively bypasses the check\nthat non-CA certificates must not be able to issue other certificates.\n\nIf a \"purpose\" has been configured then there is a subsequent opportunity\nfor checks that the certificate is a valid CA.  All of the named \"purpose\"\nvalues implemented in libcrypto perform this check.  Therefore, where\na purpose is set the certificate chain will still be rejected even when the\nstrict flag has been used. A purpose is set by default in libssl client and\nserver certificate verification routines, but it can be overridden or\nremoved by an application.\n\nIn order to be affected, an application must explicitly set the\nX509_V_FLAG_X509_STRICT verification flag and either not set a purpose\nfor the certificate verification or, in the case of TLS client or server\napplications, override the default purpose.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0013",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0401",
        "GHSA-vrh7-x64v-7vxq"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.12"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# `NULL` dereference during PKCS7 data verification\n\nA `NULL` pointer can be dereferenced when signatures are being\nverified on PKCS7 `signed` or `signedAndEnveloped` data. In case the hash\nalgorithm used for the signature is known to the OpenSSL library but\nthe implementation of the hash algorithm is not available the digest\ninitialization will fail. There is a missing check for the return\nvalue from the initialization function which later leads to invalid\nusage of the digest API most likely leading to a crash.\n\nThe unavailability of an algorithm can be caused by using FIPS\nenabled configuration of providers or more commonly by not loading\nthe legacy provider.\n\nPKCS7 data is processed by the SMIME library calls and also by the\ntime stamp (TS) library calls. The TLS implementation in OpenSSL does\nnot call these functions however third party applications would be\naffected if they call these functions to verify signatures on untrusted\ndata.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0025",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-1473",
        "GHSA-g323-fr93-4j3c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2022-05-03",
      "url": "https://www.openssl.org/news/secadv/20220503.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.6"
      ],
      "unaffected": [
        "< 300.0"
      ]
    },
    "text": "\n\n# Resource leakage when decoding certificates and keys\n\nThe `OPENSSL_LH_flush()` function, which empties a hash table, contains\na bug that breaks reuse of the memory occupied by the removed hash\ntable entries.\n\nThis function is used when decoding certificates or keys. If a long lived\nprocess periodically decodes certificates or keys its memory usage will\nexpand without bounds and the process might be terminated by the operating\nsystem causing a denial of service. Also traversing the empty hash table\nentries will take increasingly more time.\n\nTypically such long lived processes might be TLS clients or TLS servers\nconfigured to accept client certificate authentication.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0065",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-3786",
        "GHSA-h8jm-2x53-xhp5"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2022-11-01",
      "url": "https://www.openssl.org/news/secadv/20221101.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.11"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# X.509 Email Address Variable Length Buffer Overflow\n\nA buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs after\ncertificate chain signature verification and requires either a CA to\nhave signed a malicious certificate or for an application to continue\ncertificate verification despite failure to construct a path to a trusted\nissuer. An attacker can craft a malicious email address in a certificate\nto overflow an arbitrary number of bytes containing the `.` character\n(decimal 46) on the stack. This buffer overflow could result in a crash\n(causing a denial of service).\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0129",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-4044",
        "GHSA-mmjf-f5jw-w72q"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2021-12-14",
      "url": "https://www.openssl.org/news/secadv/20211214.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.4"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# Invalid handling of `X509_verify_cert()` internal errors in libssl\n\nInternally libssl in OpenSSL calls `X509_verify_cert()` on the client side to\nverify a certificate supplied by a server. That function may return a negative\nreturn value to indicate an internal error (for example out of memory). Such a\nnegative return value is mishandled by OpenSSL and will cause an IO function\n(such as `SSL_connect()` or `SSL_do_handshake()`) to not indicate success and a\nsubsequent call to `SSL_get_error()` to return the value\n`SSL_ERROR_WANT_RETRY_VERIFY`. This return value is only supposed to be returned\nby OpenSSL if the application has previously called\n`SSL_CTX_set_cert_verify_callback()`. Since most applications do not do this the\n`SSL_ERROR_WANT_RETRY_VERIFY` return value from `SSL_get_error()` will be totally\nunexpected and applications may not behave correctly as a result. The exact\nbehaviour will depend on the application but it could result in crashes,\ninfinite loops or other similar incorrect responses.\n\nThis issue is made more serious in combination with a separate bug in OpenSSL\n3.0 that will cause `X509_verify_cert()` to indicate an internal error when\nprocessing a certificate chain. This will occur where a certificate does not\ninclude the Subject Alternative Name extension but where a Certificate Authority\nhas enforced name constraints. This issue can occur even with valid chains.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0058",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-23841",
        "GHSA-84rm-qf37-fgc2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2021-05-01",
      "url": "https://www.openssl.org/news/secadv/20210216.txt"
    },
    "versions": {
      "patched": [
        ">= 111.14"
      ]
    },
    "text": "\n\n# Null pointer deref in `X509_issuer_and_serial_hash()`\n\nThe OpenSSL public API function `X509_issuer_and_serial_hash()` attempts to\ncreate a unique hash value based on the issuer and serial number data contained\nwithin an X509 certificate. However it fails to correctly handle any errors\nthat may occur while parsing the issuer field (which might occur if the issuer\nfield is maliciously constructed). This may subsequently result in a NULL\npointer deref and a crash leading to a potential denial of service attack.\n\nThe function `X509_issuer_and_serial_hash()` is never directly called by OpenSSL\nitself so applications are only vulnerable if they use this function directly\nand they use it on certificates that may have been obtained from untrusted\nsources.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0059",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-3358",
        "GHSA-4f63-89w9-3jjv"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-10-11",
      "url": "https://www.openssl.org/news/secadv/20221011.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.10"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# Using a Custom Cipher with `NID_undef` may lead to NULL encryption\n\nOpenSSL supports creating a custom cipher via the legacy `EVP_CIPHER_meth_new()`\nfunction and associated function calls. This function was deprecated in OpenSSL\n3.0 and application authors are instead encouraged to use the new provider\nmechanism in order to implement custom ciphers.\n\nOpenSSL versions 3.0.0 to 3.0.5 incorrectly handle legacy custom ciphers passed\nto the `EVP_EncryptInit_ex2()`, `EVP_DecryptInit_ex2()` and `EVP_CipherInit_ex2()`\nfunctions (as well as other similarly named encryption and decryption\ninitialisation functions). Instead of using the custom cipher directly it\nincorrectly tries to fetch an equivalent cipher from the available providers.\nAn equivalent cipher is found based on the NID passed to `EVP_CIPHER_meth_new()`.\nThis NID is supposed to represent the unique NID for a given cipher. However it\nis possible for an application to incorrectly pass `NID_undef` as this value in\nthe call to `EVP_CIPHER_meth_new()`. When `NID_undef` is used in this way the\nOpenSSL encryption/decryption initialisation function will match the NULL cipher\nas being equivalent and will fetch this from the available providers. This will\nsucceed if the default provider has been loaded (or if a third party provider\nhas been loaded that offers this cipher). Using the NULL cipher means that the\nplaintext is emitted as the ciphertext.\n\nApplications are only affected by this issue if they call `EVP_CIPHER_meth_new()`\nusing `NID_undef` and subsequently use it in a call to an encryption/decryption\ninitialisation function. Applications that only use SSL/TLS are not impacted by\nthis issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0012",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0217",
        "GHSA-vxrh-cpg7-8vjr"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.12"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# `NULL` dereference validating DSA public key\n\nAn invalid pointer dereference on read can be triggered when an\napplication tries to check a malformed DSA public key by the\n`EVP_PKEY_public_check()` function. This will most likely lead\nto an application crash. This function can be called on public\nkeys supplied from untrusted sources which could allow an attacker\nto cause a denial of service attack.\n\nThe TLS implementation in OpenSSL does not call this function\nbut applications might call the function if there are additional\nsecurity requirements imposed by standards such as FIPS 140-3.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0011",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0216",
        "GHSA-29xx-hcv2-c4cp"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.12"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# Invalid pointer dereference in `d2i_PKCS7` functions\n\nAn invalid pointer dereference on read can be triggered when an\napplication tries to load malformed PKCS7 data with the\n`d2i_PKCS7()`, `d2i_PKCS7_bio()` or `d2i_PKCS7_fp()` functions.\n\nThe result of the dereference is an application crash which could\nlead to a denial of service attack. The TLS implementation in OpenSSL\ndoes not call this function however third party applications might\ncall these functions on untrusted data.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0064",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-3602",
        "GHSA-8rwr-x37p-mx23"
      ],
      "categories": [
        "denial-of-service",
        "code-execution"
      ],
      "date": "2022-11-01",
      "url": "https://www.openssl.org/news/secadv/20221101.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.11"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# X.509 Email Address 4-byte Buffer Overflow\n\nA buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer. An attacker can craft a malicious email address\nto overflow four attacker-controlled bytes on the stack. This buffer\noverflow could result in a crash (causing a denial of service) or\npotentially remote code execution.\n\nMany platforms implement stack overflow protections which would mitigate\nagainst the risk of remote code execution. The risk may be further\nmitigated based on stack layout for any given platform/compiler.\n\nPre-announcements of CVE-2022-3602 described this issue as CRITICAL.\nFurther analysis based on some of the mitigating factors described above\nhave led this to be downgraded to HIGH. Users are still encouraged to\nupgrade to a new version as soon as possible.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0057",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-23840",
        "GHSA-qgm6-9472-pwq7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2021-05-01",
      "url": "https://www.openssl.org/news/secadv/20210216.txt"
    },
    "versions": {
      "patched": [
        ">= 111.14"
      ]
    },
    "text": "\n\n# Integer overflow in CipherUpdate\n\nCalls to `EVP_CipherUpdate`, `EVP_EncryptUpdate` and `EVP_DecryptUpdate` may overflow\nthe output length argument in some cases where the input length is close to the\nmaximum permissable length for an integer on the platform. In such cases the\nreturn value from the function call will be 1 (indicating success), but the\noutput length value will be negative. This could cause applications to behave\nincorrectly or crash.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0009",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0215",
        "GHSA-r7jw-wp68-3xch"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 111.25, < 300.0",
        ">= 300.0.12"
      ]
    },
    "text": "\n\n# Use-after-free following `BIO_new_NDEF`\n\nThe public API function `BIO_new_NDEF` is a helper function used for streaming\nASN.1 data via a `BIO`. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a `BIO` from the caller, prepends a new `BIO_f_asn1` filter\n`BIO` onto the front of it to form a `BIO` chain, and then returns the new head of\nthe `BIO` chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter `BIO` is freed and the function\nreturns a `NULL` result indicating a failure. However, in this case, the `BIO` chain\nis not properly cleaned up and the `BIO` passed by the caller still retains\ninternal pointers to the previously freed filter `BIO`. If the caller then goes on\nto call `BIO_pop()` on the `BIO` then a use-after-free will occur. This will most\nlikely result in a crash.\n\nThis scenario occurs directly in the internal function `B64_write_ASN1()` which\nmay cause `BIO_new_NDEF()` to be called and will subsequently call `BIO_pop()` on\nthe `BIO`. This internal function is in turn called by the public API functions\n`PEM_write_bio_ASN1_stream`, `PEM_write_bio_CMS_stream`, `PEM_write_bio_PKCS7_stream`,\n`SMIME_write_ASN1`, `SMIME_write_CMS` and `SMIME_write_PKCS7`.\n\nOther public API functions that may be impacted by this include\n`i2d_ASN1_bio_stream`, `BIO_new_CMS`, `BIO_new_PKCS7`, `i2d_CMS_bio_stream` and\n`i2d_PKCS7_bio_stream`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0006",
      "package": "openssl-src",
      "aliases": [
        "CVE-2023-0286",
        "GHSA-x4qr-2fvf-3mr5"
      ],
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 111.25, < 300.0",
        ">= 300.0.12"
      ]
    },
    "text": "\n\n# X.400 address type confusion in X.509 `GeneralName`\n\nThere is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 `GeneralName`. X.400 addresses were parsed as an `ASN1_STRING` but\nthe public structure definition for `GENERAL_NAME` incorrectly specified the type\nof the `x400Address` field as `ASN1_TYPE`. This field is subsequently interpreted by\nthe OpenSSL function `GENERAL_NAME_cmp` as an `ASN1_TYPE` rather than an\n`ASN1_STRING`.\n\nWhen CRL checking is enabled (i.e. the application sets the\n`X509_V_FLAG_CRL_CHECK` flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a `memcmp` call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0015",
      "package": "openssl-src",
      "aliases": [
        "CVE-2020-1967",
        "GHSA-jq65-29v4-4x35"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-04-25",
      "url": "https://www.openssl.org/news/secadv/20200421.txt"
    },
    "versions": {
      "patched": [
        ">= 111.9"
      ],
      "unaffected": [
        "< 111.6"
      ]
    },
    "text": "\n\n# Crash causing Denial of Service attack\n\nServer or client applications that call the SSL_check_chain() function during or after a TLS 1.3 \nhandshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \n\"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature \nalgorithm is received from the peer. This could be exploited by a malicious peer in a Denial of \nService attack.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0033",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-2274",
        "GHSA-735f-pg76-fxc4"
      ],
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-07-05",
      "url": "https://www.openssl.org/news/secadv/20220705.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.9"
      ],
      "unaffected": [
        "< 300.0.8"
      ]
    },
    "text": "\n\n# Heap memory corruption with RSA private key operation\n\nThe OpenSSL 3.0.4 release introduced a serious bug in the RSA\nimplementation for X86_64 CPUs supporting the AVX512IFMA instructions.\nThis issue makes the RSA implementation with 2048 bit private keys\nincorrect on such machines and memory corruption will happen during\nthe computation. As a consequence of the memory corruption an attacker\nmay be able to trigger a remote code execution on the machine performing\nthe computation.\n\nSSL/TLS servers or other servers using 2048 bit RSA private keys running\non machines supporting AVX512IFMA instructions of the X86_64 architecture\nare affected by this issue.\n\nNote that on a vulnerable machine, proper testing of OpenSSL would fail and\nshould be noticed before deployment.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0097",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-3711",
        "GHSA-5ww6-px42-wc85"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "crypto-failure"
      ],
      "date": "2021-08-24",
      "url": "https://www.openssl.org/news/secadv/20210824.txt"
    },
    "versions": {
      "patched": [
        ">= 111.16"
      ]
    },
    "text": "\n\n# SM2 Decryption Buffer Overflow\n\nIn order to decrypt SM2 encrypted data an application is expected to call the\nAPI function `EVP_PKEY_decrypt()`. Typically an application will call this\nfunction twice. The first time, on entry, the \"out\" parameter can be NULL and,\non exit, the \"outlen\" parameter is populated with the buffer size required to\nhold the decrypted plaintext. The application can then allocate a sufficiently\nsized buffer and call `EVP_PKEY_decrypt()` again, but this time passing a non-NULL\nvalue for the \"out\" parameter.\n\nA bug in the implementation of the SM2 decryption code means that the\ncalculation of the buffer size required to hold the plaintext returned by the\nfirst call to `EVP_PKEY_decrypt()` can be smaller than the actual size required by\nthe second call. This can lead to a buffer overflow when `EVP_PKEY_decrypt()` is\ncalled by the application a second time with a buffer that is too small.\n\nA malicious attacker who is able present SM2 content for decryption to an\napplication could cause attacker chosen data to overflow the buffer by up to a\nmaximum of 62 bytes altering the contents of other data held after the\nbuffer, possibly changing application behaviour or causing the application to\ncrash. The location of the buffer is application dependent but is typically\nheap allocated.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0010",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-4450",
        "GHSA-v5w6-wcm8-jm4q"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 111.25, < 300.0",
        ">= 300.0.12"
      ]
    },
    "text": "\n\n# Double free after calling `PEM_read_bio_ex`\n\nThe function `PEM_read_bio_ex()` reads a PEM file from a BIO and parses and\ndecodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data.\nIf the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case `PEM_read_bio_ex()`\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions `PEM_read_bio()` and `PEM_read()` are simple wrappers around\n`PEM_read_bio_ex()` and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including `PEM_X509_INFO_read_bio_ex()` and\n`SSL_CTX_use_serverinfo_file()` which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if `PEM_read_bio_ex()` returns a failure code. These locations\ninclude the `PEM_read_bio_TYPE()` functions as well as the decoders introduced in\nOpenSSL 3.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0014",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-0778",
        "GHSA-x3mh-jvjw-3xwx"
      ],
      "categories": [
        "denial-of-service"
      ],
      "date": "2022-03-15",
      "url": "https://www.openssl.org/news/secadv/20220315.txt"
    },
    "versions": {
      "patched": [
        ">= 111.18, < 300.0",
        ">= 300.0.5"
      ]
    },
    "text": "\n\n# Infinite loop in `BN_mod_sqrt()` reachable when parsing certificates\n\nThe `BN_mod_sqrt()` function, which computes a modular square root, contains\na bug that can cause it to loop forever for non-prime moduli.\n\nInternally this function is used when parsing certificates that contain\nelliptic curve public keys in compressed form or explicit elliptic curve\nparameters with a base point encoded in compressed form.\n\nIt is possible to trigger the infinite loop by crafting a certificate that\nhas invalid explicit curve parameters.\n\nSince certificate parsing happens prior to verification of the certificate\nsignature, any process that parses an externally supplied certificate may thus\nbe subject to a denial of service attack. The infinite loop can also be\nreached when parsing crafted private keys as they can contain explicit\nelliptic curve parameters.\n\nThus vulnerable situations include:\n\n - TLS clients consuming server certificates\n - TLS servers consuming client certificates\n - Hosting providers taking certificates or private keys from customers\n - Certificate authorities parsing certification requests from subscribers\n - Anything else which parses ASN.1 elliptic curve parameters\n\nAlso any other applications that use the `BN_mod_sqrt()` where the attacker\ncan control the parameter values are vulnerable to this DoS issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0026",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-1434",
        "GHSA-638m-m8mh-7gw2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "categories": [
        "crypto-failure"
      ],
      "date": "2022-05-03",
      "url": "https://www.openssl.org/news/secadv/20220503.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.6"
      ],
      "unaffected": [
        "< 300.0"
      ]
    },
    "text": "\n\n# Incorrect MAC key used in the RC4-MD5 ciphersuite\n\nThe OpenSSL 3.0 implementation of the RC4-MD5 ciphersuite incorrectly uses the\nAAD data as the MAC key. This makes the MAC key trivially predictable.\n\nAn attacker could exploit this issue by performing a man-in-the-middle attack to\nmodify data being sent from one endpoint to an OpenSSL 3.0 recipient such that\nthe modified data would still pass the MAC integrity check.\n\nNote that data sent from an OpenSSL 3.0 endpoint to a non-OpenSSL 3.0 endpoint\nwill always be rejected by the recipient and the connection will fail at that\npoint. Many application protocols require data to be sent from the client to the\nserver first. Therefore, in such a case, only an OpenSSL 3.0 server would be\nimpacted when talking to a non-OpenSSL 3.0 client.\n\nIf both endpoints are OpenSSL 3.0 then the attacker could modify data being\nsent in both directions. In this case both clients and servers could be\naffected, regardless of the application protocol.\n\nNote that in the absence of an attacker this bug means that an OpenSSL 3.0\nendpoint communicating with a non-OpenSSL 3.0 endpoint will fail to complete the\nhandshake when using this ciphersuite.\n\nThe confidentiality of data is not impacted by this issue, i.e. an attacker\ncannot decrypt data that has been encrypted using this ciphersuite - they can\nonly modify it.\n\nIn order for this attack to work both endpoints must legitimately negotiate the\nRC4-MD5 ciphersuite. This ciphersuite is not compiled by default in OpenSSL 3.0,\nand is not available within the default provider or the default ciphersuite\nlist. This ciphersuite will never be used if TLSv1.3 has been negotiated. In\norder for an OpenSSL 3.0 endpoint to use this ciphersuite the following must\nhave occurred:\n\n1. OpenSSL must have been compiled with the (non-default) compile time option\n   enable-weak-ssl-ciphers\n2. OpenSSL must have had the legacy provider explicitly loaded (either through\n   application code or via configuration)\n3. The ciphersuite must have been explicitly added to the ciphersuite list\n4. The libssl security level must have been set to 0 (default is 1)\n5. A version of SSL/TLS below TLSv1.3 must have been negotiated\n6. Both endpoints must negotiate the RC4-MD5 ciphersuite in preference to any\n   others that both endpoints have in common\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0055",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-3449",
        "GHSA-83mx-573x-5rw9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2021-05-01",
      "url": "https://www.openssl.org/news/secadv/20210325.txt"
    },
    "versions": {
      "patched": [
        ">= 111.15"
      ]
    },
    "text": "\n\n# NULL pointer deref in signature_algorithms processing\n\nAn OpenSSL TLS server may crash if sent a maliciously crafted renegotiation\nClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits\nthe signature_algorithms extension (where it was present in the initial\nClientHello), but includes a signature_algorithms_cert extension then a NULL\npointer dereference will result, leading to a crash and a denial of service\nattack.\n\nA server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which\nis the default configuration). OpenSSL TLS clients are not impacted by this\nissue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0098",
      "package": "openssl-src",
      "aliases": [
        "CVE-2021-3712",
        "GHSA-q9wj-f4qw-6vfj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "categories": [
        "denial-of-service",
        "crypto-failure"
      ],
      "date": "2021-08-24",
      "url": "https://www.openssl.org/news/secadv/20210824.txt"
    },
    "versions": {
      "patched": [
        ">= 111.16"
      ]
    },
    "text": "\n\n# Read buffer overruns processing ASN.1 strings\n\nASN.1 strings are represented internally within OpenSSL as an ASN1_STRING\nstructure which contains a buffer holding the string data and a field holding\nthe buffer length. This contrasts with normal C strings which are represented as\na buffer for the string data which is terminated with a NUL (0) byte.\n\nAlthough not a strict requirement, ASN.1 strings that are parsed using OpenSSL's\nown \"d2i\" functions (and other similar parsing functions) as well as any string\nwhose value has been set with the ASN1_STRING_set() function will additionally\nNUL terminate the byte array in the ASN1_STRING structure.\n\nHowever, it is possible for applications to directly construct valid ASN1_STRING\nstructures which do not NUL terminate the byte array by directly setting the\n\"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by\nusing the `ASN1_STRING_set0()` function.\n\nNumerous OpenSSL functions that print ASN.1 data have been found to assume that\nthe ASN1_STRING byte array will be NUL terminated, even though this is not\nguaranteed for strings that have been directly constructed. Where an application\nrequests an ASN.1 structure to be printed, and where that ASN.1 structure\ncontains ASN1_STRINGs that have been directly constructed by the application\nwithout NUL terminating the \"data\" field, then a read buffer overrun can occur.\n\nThe same thing can also occur during name constraints processing of certificates\n(for example if a certificate has been directly constructed by the application\ninstead of loading it via the OpenSSL parsing functions, and the certificate\ncontains non NUL terminated ASN1_STRING structures). It can also occur in the\n`X509_get1_email()`, `X509_REQ_get1_email()` and `X509_get1_ocsp()` functions.\n\nIf a malicious actor can cause an application to directly construct an\nASN1_STRING and then process it through one of the affected OpenSSL functions\nthen this issue could be hit. This might result in a crash (causing a Denial of\nService attack). It could also result in the disclosure of private memory\ncontents (such as private keys, or sensitive plaintext).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0008",
      "package": "openssl-src",
      "aliases": [
        "CVE-2022-4203",
        "GHSA-w67w-mw4j-8qrv"
      ],
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "date": "2023-02-07",
      "url": "https://www.openssl.org/news/secadv/20230207.txt"
    },
    "versions": {
      "patched": [
        ">= 300.0.12"
      ],
      "unaffected": [
        "< 300.0.0"
      ]
    },
    "text": "\n\n# X.509 Name Constraints Read Buffer Overflow\n\nA read buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer.\n\nThe read buffer overrun might result in a crash which could lead to\na denial of service attack. In theory it could also result in the disclosure\nof private memory contents (such as private keys, or sensitive plaintext)\nalthough we are not aware of any working exploit leading to memory\ncontents disclosure as of the time of release of this advisory.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0062",
      "package": "futures-util",
      "aliases": [
        "CVE-2020-35908",
        "GHSA-5r9g-j7jj-hw6c"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-01-24",
      "url": "https://github.com/rust-lang/futures-rs/issues/2050",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency",
        "memory-corruption",
        "memory-management"
      ]
    },
    "affected": {
      "functions": {
        "futures_util::stream::FuturesUnordered": [
          ">= 0.3.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Improper `Sync` implementation on `FuturesUnordered` in futures-utils can cause data corruption\nAffected versions of the crate had an unsound `Sync` implementation on the `FuturesUnordered` structure, which used a `Cell` for\ninterior mutability without any code to handle synchronized access to the underlying task list's length and head safely.\n\nThis could of lead to data corruption since two threads modifying the list at once could see incorrect values due to the lack\nof access synchronization.\n\nThe issue was fixed by adding access synchronization code around insertion of tasks into the list.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0059",
      "package": "futures-util",
      "aliases": [
        "CVE-2020-35905",
        "GHSA-rh4w-94hh-9943"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-22",
      "url": "https://github.com/rust-lang/futures-rs/issues/2239",
      "categories": [
        "thread-safety"
      ],
      "keywords": [
        "concurrency",
        "memory-corruption",
        "memory-management"
      ]
    },
    "affected": {
      "functions": {
        "futures_util::lock::MutexGuard::map": [
          ">= 0.3.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.3.7"
      ],
      "unaffected": [
        "< 0.3.2"
      ]
    },
    "text": "\n\n# MutexGuard::map can cause a data race in safe code\nAffected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.\n\nThis could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.\n\nThe issue was fixed by fixing `Send` and `Sync` implementations, and by adding a `PhantomData<&'a mut U>` marker to the `MappedMutexGuard` type to tell the compiler that the guard is over\nU too.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0116",
      "package": "unicycle",
      "date": "2020-11-15",
      "url": "https://github.com/udoprog/unicycle/issues/8",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36436",
        "GHSA-686f-ch3r-xwmh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# PinSlab<T> and Unordered<T, S> need bounds on their Send/Sync traits\n\nAffected versions of this crate unconditionally implemented `Send` & `Sync` for types `PinSlab<T>` & `Unordered<T, S>`. This allows sending non-Send types to other threads and concurrently accessing non-Sync types from multiple threads.\n\nThis can result in a data race & memory corruption when types that provide internal mutability without synchronization are contained within `PinSlab<T>` or `Unordered<T, S>` and accessed concurrently from multiple threads.\n\nThe flaw was corrected in commits 92f40b4 & 6a6c367 by adding trait bound `T: Send` to `Send` impls for `PinSlab<T>` & `Unordered<T, S>` and adding `T: Sync` to `Sync` impls for `PinSlab<T>` & `Unordered<T, S>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0007",
      "package": "rust-i18n-support",
      "date": "2024-01-19",
      "url": "https://github.com/longbridgeapp/rust-i18n/issues/71",
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "references": [
        "https://github.com/longbridgeapp/rust-i18n/pull/72",
        "https://github.com/longbridgeapp/rust-i18n/releases/tag/v3.0.1"
      ],
      "aliases": [
        "GHSA-c8v3-jhv9-4ppc"
      ]
    },
    "affected": {
      "functions": {
        "rust_i18n_support::AtomicStr::as_str": [
          "< 3.0.1, >= 3.0.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 3.0.1"
      ],
      "unaffected": [
        "< 3.0.0"
      ]
    },
    "text": "\n\n# Use-after-free when setting the locale\n\nVersion 3.0.0 introduced an `AtomicStr` type, that is used to store the current locale.\nIt stores the locale as a raw pointer to an `Arc<String>`.\nThe locale can be read with `AtomicStr::as_str()`.\n`AtomicStr::as_str()` does not increment the usage counter of the `Arc`.\n\nIf the locale is changed in one thread, another thread can have a stale -- possibly already freed --\nreference to the stored string.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0014",
      "package": "cortex-m-rt",
      "date": "2023-02-13",
      "informational": "unsound",
      "url": "https://github.com/rust-embedded/cortex-m/discussions/469",
      "aliases": [
        "GHSA-xw5j-gv2g-mjm2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.3"
      ],
      "unaffected": [
        "<= 0.7.0"
      ]
    },
    "text": "\n\n# Miscompilation in cortex-m-rt 0.7.1 and 0.7.2\n\nVersion 0.7.1 of the `cortex-m-rt` crate introduced a regression causing the stack to NOT be eight-byte aligned prior to calling `main` (or any other specified entrypoint), violating the [stack ABI of AAPCS32], the default ABI used by all Cortex-M targets. This regression is also present in version 0.7.2 of the `cortex-m-rt` crate.\n\nThis regression can cause certain compiler optimizations (which assume the eight-byte alignment) to produce incorrect behavior at runtime. This incorrect behavior has been [observed in real-world applications].\n\n**It is advised that ALL users of `v0.7.1` and `v0.7.2` of the `cortex-m-rt` crate update to the latest version (`v0.7.3`), AS SOON AS POSSIBLE.** Users of `v0.7.0` and prior versions of `cortex-m-rt` are not affected by this regression.\n\nIt will be necessary to rebuild all affected firmware binaries, and flash or deploy the new firmware binaries to affected devices.\n\n[stack ABI of AAPCS32]: https://github.com/ARM-software/abi-aa/blob/edd7460d87493fff124b8b5713acf71ffc06ee91/aapcs32/aapcs32.rst#6212stack-constraints-at-a-public-interface\n[observed in real-world applications]: https://github.com/peter9477/test2\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0029",
      "package": "truetype",
      "aliases": [
        "CVE-2021-28030",
        "GHSA-v7q4-97x4-4qw2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-02-17",
      "url": "https://github.com/bodoni/truetype/issues/11",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.30.1"
      ]
    },
    "text": "\n\n# Tape::take_bytes exposes uninitialized memory to a user-provided Read\n\nAffected versions of this crate passed an unininitialized buffer to a\nuser-provided `Read` instance in `Tape::take_bytes`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was corrected in commit `1f2dc7f37dd` by removing the unsafe block\nand zero-initializing the buffer.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0041",
      "aliases": [
        "CAN-2021-1000007",
        "CVE-2021-29932",
        "GHSA-qpgv-g792-wh6x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "package": "parse_duration",
      "date": "2021-03-18",
      "url": "https://github.com/zeta12ti/parse_duration/issues/21",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "parsing",
        "untrusted data"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "parse_duration::parse": [
          "*"
        ]
      }
    },
    "text": "\n\n# Denial of service through parsing payloads with too big exponent\n\nThe `parse_duration::parse` function allows for parsing duration strings with exponents like `5e5s` where under the hood, the [`BigInt` type along with the `pow` function are used for such payloads](https://github.com/zeta12ti/parse_duration/blob/26940ab5cd4e3a9d6bd97aa101f8d4bbfd18ee8c/src/parse.rs#L335). Passing an arbitrarily big exponent makes the `parse_duration::parse` function to process the payload for a very long time taking up CPU and memory.\n\nThis allows an attacker to cause a DoS if the `parse_duration::parse` function is used to process untrusted input.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0016",
      "package": "libdav1d-sys",
      "date": "2024-02-19",
      "url": "https://www.cvedetails.com/cve/CVE-2024-1580/",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "integer-overflow"
      ],
      "aliases": [
        "GHSA-mc39-h54g-pvw6"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# dav1d AV1 decoder integer overflow\n\nAn integer overflow in dav1d AV1 decoder that can occur when decoding videos with large frame size. This can lead to memory corruption within the AV1 decoder. We recommend upgrading to version 0.7.0 of libdav1d-sys, which includes dav1d 1.4.0\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0084",
      "package": "safe_authenticator",
      "date": "2020-12-07",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been superseded by `sn_client`\n\nThis crate has been superseded by `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0160",
      "package": "shamir",
      "date": "2020-01-21",
      "url": "https://github.com/Nebulosus/shamir/issues/3",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "GHSA-978j-88f3-p5j3"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# Threshold value is ignored (all shares are n=3)\n\nAffected versions of this crate did not properly calculate secret shares requirements.\n\nThis reduces the security of the algorithm by restricting the crate to always\nusing a threshold value of three, rather than a configurable limit.\n\nThe flaw was corrected by correctly configuring the threshold.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0085",
      "package": "hpack",
      "date": "2023-09-15",
      "url": "https://github.com/mlalic/hpack-rs/issues/11",
      "categories": [
        "denial-of-service"
      ],
      "references": [
        "https://github.com/sno2/hpack-rs-patched/commit/d669282924a95311599e9e7dd53869ee96b3a2f5"
      ],
      "aliases": [
        "GHSA-w7hm-hmxv-pvhf"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# HPACK decoder panics on invalid input\n\nDue to insufficient checking of input data, decoding certain data sequences can\nlead to _Decoder::decode_ panicking rather than returning an error.\n\nExample code that triggers this vulnerability looks like this:\n\n```rust\nuse hpack::Decoder;\n\npub fn main() {\n  let input = &[0x3f];\n  let mut decoder = Decoder::new();\n  let _ = decoder.decode(input);\n}\n```\n\nhpack is unmaintained. A crate with the panics fixed has been published as\n[hpack-patched](https://crates.io/crates/hpack-patched).\n\nAlso consider using [fluke-hpack](https://crates.io/crates/fluke-hpack) or\n[httlib-huffman](https://crates.io/crates/httlib-huffman) as an alternative.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0084",
      "package": "hpack",
      "date": "2023-09-15",
      "url": "https://github.com/mlalic/hpack-rs/issues/8",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `hpack` is unmaintained\n\nThe `hpack` crate is no longer maintained.\n\nConsider using [fluke-hpack](https://crates.io/crates/fluke-hpack) or\n[httlib-huffman](https://crates.io/crates/httlib-huffman).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0080",
      "package": "parity-util-mem",
      "date": "2022-11-30",
      "url": "https://github.com/paritytech/parity-common/pull/696",
      "references": [
        "https://github.com/paritytech/parity-common/issues/607",
        "https://github.com/paritytech/parity-common/pull/697"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# parity-util-mem Unmaintained\n\nThe crate has been deprecated and will receive no updates with no repository source.\n\nThe crate has [a warning](https://crates.io/crates/parity-util-mem) surrounding it's use related to global allocator use that may lead to UB.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0061",
      "package": "futures-task",
      "aliases": [
        "CVE-2020-35907",
        "GHSA-p9m5-3hj7-cp5r"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-05-03",
      "url": "https://github.com/rust-lang/futures-rs/issues/2091",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "NULL pointer dereference",
        "memory-management"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.5"
      ]
    },
    "affected": {
      "functions": {
        "futures_task::noop_waker_ref": [
          ">= 0.3.0"
        ]
      }
    },
    "text": "\n\n# futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer\n\nAffected versions of the crate used a `UnsafeCell` in thread-local storage to return a noop waker reference,\nassuming that the reference would never be returned from another thread.\n\nThis resulted in a segmentation fault crash if `Waker::wake_by_ref()` was called on a waker returned from another thread due to \nit attempting to dereference a pointer that wasn't accessible from the main thread.\n\nReproduction Example (from issue):\n```rust\nuse futures_task::noop_waker_ref;\nfn main() {\n    let waker = std::thread::spawn(|| noop_waker_ref()).join().unwrap();\n    waker.wake_by_ref();\n}\n```\n\nThe flaw was corrected by using a `OnceCell::Lazy<>` wrapper around the noop waker instead of thread-local storage.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0060",
      "package": "futures-task",
      "aliases": [
        "CVE-2020-35906",
        "GHSA-r93v-9p5q-vhpf"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-09-04",
      "url": "https://github.com/rust-lang/futures-rs/pull/2206",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "arbitrary code execution",
        "memory-corruption",
        "memory-management"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.6"
      ],
      "unaffected": [
        "<= 0.2.1"
      ]
    },
    "affected": {
      "functions": {
        "futures_task::waker": [
          ">= 0.3.0"
        ]
      }
    },
    "text": "\n\n# futures_task::waker may cause a use-after-free if used on a type that isn't 'static\n\nAffected versions of the crate did not properly implement a `'static` lifetime bound on the `waker` function.\nThis resulted in a use-after-free if `Waker::wake()` is called after original data had been dropped.\n\nThe flaw was corrected by adding `'static` lifetime bound to the data `waker` takes.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0096",
      "package": "im",
      "aliases": [
        "CVE-2020-36204",
        "GHSA-q9h2-4xhf-23xx"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-09",
      "url": "https://github.com/bodil/im-rs/issues/157",
      "categories": [
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 15.1.0"
      ],
      "unaffected": [
        "< 12.0.0"
      ]
    },
    "text": "\n\n# TreeFocus lacks bounds on its Send and Sync traits\n\nAffected versions of `im` contains `TreeFocus` that unconditionally implements `Send` and `Sync`.\n\nThis allows a data race in safe Rust code if `TreeFocus` is extracted from `Focus` type.\nTypical users that only use `Focus` type are not affected.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0100",
      "package": "sha2",
      "date": "2021-09-08",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "cryptography"
      ],
      "url": "https://github.com/RustCrypto/hashes/pull/314",
      "aliases": [
        "CVE-2021-45696",
        "GHSA-fc7x-2cmc-8j2g",
        "GHSA-xpww-g9jx-hp8r"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.8"
      ],
      "unaffected": [
        "< 0.9.7"
      ]
    },
    "text": "\n\n# Miscomputed results when using AVX2 backend\n\nThe v0.9.7 release of the `sha2` crate introduced a new AVX2-accelerated\nbackend which was automatically enabled for all x86/x86_64 CPUs where AVX2\nsupport was autodetected at runtime.\n\nThis backend was buggy and would miscompute results for long messages\n(i.e. messages spanning multiple SHA blocks).\n\nThe crate has since been yanked, but any users who upgraded to v0.9.7 should\nimmediately upgrade to v0.9.8 and recompute any hashes which were previously\ncomputed by v0.9.7.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0112",
      "package": "buttplug",
      "aliases": [
        "CVE-2020-36218",
        "GHSA-r7rv-2rph-hvhj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-18",
      "url": "https://github.com/buttplugio/buttplug-rs/issues/225",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.4"
      ]
    },
    "text": "\n\n# ButtplugFutureStateShared allows data race to (!Send|!Sync) objects\n\n`ButtplugFutureStateShared<T>` implements `Send` & `Sync` regardless of `T`.\n\nIf `T: !Send` for `ButtplugFutureStateShared<T>`, it is possible to move non-Send types across thread boundaries (e.g. `T`=`Rc<T>`) and lead to undefined behavior.\nIf `T: !Sync` for `ButtplugFutureStateShared<T>`, it is possible to cause data race to `T` (e.g. `T`=`Arc<Cell<_>>`) and lead to undefined behavior.\n\nThe flaw was corrected in version 1.0.4 by removing manual implementations of `Send`/`Sync` for `ButtplugFutureStateShared<T>` to let rustc generate auto trait implementations with correct trait bounds on `T`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0012",
      "package": "serde-json-wasm",
      "date": "2024-01-24",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "stack-overflow",
        "json"
      ],
      "aliases": [
        "GHSA-rr69-rxr6-8qwf"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.1",
        ">= 0.5.2, < 1.0.0"
      ]
    },
    "text": "\n\n# Stack overflow during recursive JSON parsing\n\nWhen parsing untrusted, deeply nested JSON, the stack may overflow,\npossibly enabling a Denial of Service attack.\nThis was fixed by adding a check for recursion depth.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0033",
      "package": "stack_dst",
      "aliases": [
        "CVE-2021-28034",
        "CVE-2021-28035",
        "GHSA-45w7-7g63-2m5w",
        "GHSA-8mjx-h23h-w2pg"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-22",
      "url": "https://github.com/thepowersgang/stack_dst-rs/issues/5",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "affected": {
      "functions": {
        "stack_dst::StackA::push_cloned": [
          "< 0.6.1"
        ]
      }
    },
    "text": "\n\n# push_cloned can drop uninitialized memory or double free on panic\n\nAffected versions of `stack_dst` used a `push_inner` function that increased\nthe internal length of the array and then called `val.clone()`.\n\nIf the `val.clone()` call panics, the stack could drop an already dropped\nelement or drop uninitialized memory.\n\nThis issue was fixed in `2a4d538` by increasing the length of the array after\nelements are cloned.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0167",
      "package": "pnet_packet",
      "date": "2020-06-19",
      "url": "https://github.com/libpnet/libpnet/issues/449",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
      "aliases": [
        "GHSA-cf4g-fcf8-3cr9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.27.2"
      ]
    },
    "text": "\n\n# `pnet_packet` buffer overrun in `set_payload` setters\n\nAs indicated by this [issue](https://github.com/libpnet/libpnet/issues/449#issuecomment-663355987), a buffer overrun is possible in the `set_payload` setter of the various mutable \"Packet\" struct setters. The offending `set_payload` functions were defined within the struct `impl` blocks in earlier versions of the package, and later by the `packet` macro.\n\nFixed in the `packet` macro by [this](https://github.com/libpnet/libpnet/pull/455) PR.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0345",
      "package": "sequoia-openpgp",
      "date": "2024-06-26",
      "url": "https://gitlab.com/sequoia-pgp/sequoia/-/issues/1106",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "infinite-loop"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.21.0"
      ],
      "unaffected": [
        "< 1.13.0"
      ]
    },
    "affected": {
      "functions": {
        "sequoia_openpgp::cert::raw::RawCertParser": [
          ">= 1.13.0, < 1.21.0"
        ]
      }
    },
    "text": "\n\n# Low severity (DoS) vulnerability in sequoia-openpgp\n\nThere is a denial-of-service vulnerability in sequoia-openpgp, our\ncrate providing a low-level interface to our OpenPGP implementation.\nWhen triggered, the process will enter an infinite loop.\n\nMany thanks to Andrew Gallagher for disclosing the issue to us.\n\n## Impact\n\nAny software directly or indirectly using the interface\n`sequoia_openpgp::cert::raw::RawCertParser`.  Notably, this includes all\nsoftware using the `sequoia_cert_store` crate.\n\n## Details\n\nThe `RawCertParser` does not advance the input stream when\nencountering unsupported cert (primary key) versions, resulting in an\ninfinite loop.\n\nThe fix introduces a new raw-cert-specific\n`cert::raw::Error::UnuspportedCert`.\n\n## Affected software\n\n- sequoia-openpgp 1.13.0\n- sequoia-openpgp 1.14.0\n- sequoia-openpgp 1.15.0\n- sequoia-openpgp 1.16.0\n- sequoia-openpgp 1.17.0\n- sequoia-openpgp 1.18.0\n- sequoia-openpgp 1.19.0\n- sequoia-openpgp 1.20.0\n- Any software built against a vulnerable version of sequoia-openpgp\n  which is directly or indirectly using the interface\n  `sequoia_openpgp::cert::raw::RawCertParser`.  Notably, this includes\n  all software using the `sequoia_cert_store` crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0038",
      "package": "sequoia-openpgp",
      "date": "2023-05-16",
      "url": "https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/",
      "references": [
        "https://gitlab.com/sequoia-pgp/sequoia/-/tags/openpgp%2Fv1.16.0"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "panic"
      ],
      "aliases": [
        "GHSA-25mx-8f3v-8wh7"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.1, < 1.2.0",
        ">= 1.8.1, < 1.9.0",
        ">= 1.16.0"
      ]
    },
    "text": "\n\n# Out-of-bounds array access leads to panic\n\nAffected versions of the crate have several bugs where\nattacker-controlled input can result in the use of an out-of-bound\narray index.  Rust detects the use of the out-of-bound index and\ncauses the application to panic.  An attacker may be able to use this\nto cause a denial-of-service.  However, it is not possible for an\nattacker to read from or write to the application's address space.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0126",
      "package": "rust-embed",
      "date": "2021-11-29",
      "url": "https://github.com/pyros2097/rust-embed/issues/159",
      "categories": [
        "file-disclosure"
      ],
      "aliases": [
        "CVE-2021-45712",
        "GHSA-cgw6-f3mj-h742",
        "GHSA-xrg3-hmf3-rvgw"
      ]
    },
    "versions": {
      "patched": [
        ">= 6.3.0"
      ]
    },
    "text": "\n\n# RustEmbed generated `get` method allows for directory traversal when reading files from disk\n\nWhen running in debug mode and the `debug-embed` (off by default) feature is\nnot enabled, the generated `get` method does not check that the input path is\na child of the folder given. \n\nThis allows attackers to read arbitrary files in the file system if they have\ncontrol over the filename given. The following code will print the contents of\nyour `/etc/passwd` if adjusted with a correct number of `../`s depending on\nwhere it is run from.\n\n```rust\n#[derive(rust_embed::RustEmbed)]\n#[folder = \"src/\"]\npub struct Asset;\n\nfn main() {\n    let d = Asset::get(\"../../../etc/passwd\").unwrap().data;\n    println!(\"{}\", String::from_utf8_lossy(&d));\n}\n```\n\nThe flaw was corrected by canonicalizing the input filename and ensuring that\nit starts with the canonicalized folder path.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0006",
      "package": "thread_local",
      "categories": [
        "memory-corruption"
      ],
      "date": "2022-01-23",
      "url": "https://github.com/Amanieu/thread_local-rs/issues/33",
      "aliases": [
        "GHSA-9hpw-r23r-xgm5"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.4"
      ]
    },
    "text": "\n\n# Data race in `Iter` and `IterMut`\n\nIn the affected version of this crate, `{Iter, IterMut}::next` used a weaker memory ordering when loading values than what was required, exposing a potential data race\nwhen iterating over a `ThreadLocal`'s values.\n\nCrates using `Iter::next`, or `IterMut::next` are affected by this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0049",
      "package": "tui",
      "date": "2023-08-07",
      "informational": "unmaintained",
      "url": "https://github.com/fdehau/tui-rs/issues/654"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `tui` is unmaintained; use `ratatui` instead\n\nThe [`tui`](https://crates.io/crates/tui) crate is no longer maintained.\n\nConsider using the [`ratatui`](https://crates.io/crates/ratatui) crate instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0040",
      "package": "boxfnonce",
      "date": "2019-06-20",
      "url": "https://github.com/stbuehler/rust-boxfnonce/commit/058ac7e1a7d732076da9d8a37baa66bcb67758d8",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `boxfnonce` obsolete with release of Rust 1.35.0\n\n[This](https://github.com/stbuehler/rust-boxfnonce/commit/058ac7e1a7d732076da9d8a37baa66bcb67758d8) commit marks the `boxfnonce` crate as obsolete and the GitHub repo has since been archived.\n\nThe functionality of `boxfnonce` has been added to Rust since 1.35.0. Use `Box<dyn FnOnce(...) -> ...>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0057",
      "package": "block-cipher",
      "date": "2020-10-15",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/traits/pull/337"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `cipher`\n\nThis crate has been renamed from `block-cipher` to `cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/cipher>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0062",
      "package": "bcder",
      "date": "2023-09-13",
      "url": "https://nlnetlabs.nl/downloads/bcder/CVE-2023-39914.txt",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "example",
        "freeform",
        "keywords"
      ],
      "aliases": [
        "CVE-2023-39914",
        "GHSA-6jmw-6mxw-w4jc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "references": [
        "https://github.com/NLnetLabs/bcder/pull/74"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.3"
      ]
    },
    "text": "\n\n# BER/CER/DER decoder panics on invalid input\n\nDue to insufficient checking of input data, decoding certain data sequences\ncan lead to _bcder_ panicking rather than returning an error. This can affect\nboth the actual decoding stage as well as accessing content of types that\nutilized delayed decoding.\n\nbcder 0.7.3 fixes these issues by more thoroughly checking inputs and\nreturning errors as expected.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0143",
      "package": "kamadak-exif",
      "date": "2021-01-04",
      "url": "https://github.com/kamadak/exif-rs/commit/1b05eab57e484cd7d576d4357b9cda7fdc57df8c",
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
      "keywords": [
        "untrusted-data",
        "dos"
      ],
      "aliases": [
        "CVE-2021-21235",
        "GHSA-px9g-8hgv-jvg2"
      ]
    },
    "affected": {
      "functions": {
        "kamadak_exif::Reader::read_from_container": [
          ">= 0.5.2, < 0.5.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.5.3"
      ],
      "unaffected": [
        "< 0.5.2"
      ]
    },
    "text": "\n# kamadak-exif DoS with untrusted PNG data\n\nAttacker crafted data can cause a infinite loop leading to DoS if used with untrusted data.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0056",
      "package": "stdweb",
      "date": "2020-05-04",
      "url": "https://github.com/koute/stdweb/issues/403",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.4.20"
      ]
    },
    "text": "\n\n# stdweb is unmaintained\n\nThe author of the `stdweb` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)\n- [`js-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys)\n- [`web-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0040",
      "package": "owning_ref",
      "date": "2022-01-26",
      "url": "https://github.com/noamtashma/owning-ref-unsoundness",
      "references": [
        "https://github.com/Kimundi/owning-ref-rs/issues/49",
        "https://github.com/Kimundi/owning-ref-rs/issues/61",
        "https://github.com/Kimundi/owning-ref-rs/issues/71",
        "https://github.com/Kimundi/owning-ref-rs/issues/77"
      ],
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-9qxh-258v-666c"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple soundness issues in `owning_ref`\n\n- `OwningRef::map_with_owner` is [unsound](https://github.com/Kimundi/owning-ref-rs/issues/77) and may result in a use-after-free.\n- `OwningRef::map` is [unsound](https://github.com/Kimundi/owning-ref-rs/issues/71) and may result in a use-after-free.\n- `OwningRefMut::as_owner` and `OwningRefMut::as_owner_mut` are [unsound](https://github.com/Kimundi/owning-ref-rs/issues/61) and may result in a use-after-free.\n- The crate [violates Rust's aliasing rules](https://github.com/Kimundi/owning-ref-rs/issues/49), which may cause miscompilations on recent compilers that emit the LLVM `noalias` attribute.\n\n`safer_owning_ref` is a replacement crate which fixes these issues.\nNo patched versions of the original crate are available, and the maintainer is unresponsive.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0117",
      "package": "conqueue",
      "date": "2020-11-24",
      "url": "https://github.com/longshorej/conqueue/issues/9",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36437",
        "GHSA-368f-29c3-4f2r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# QueueSender<T>/QueueReceiver<T>: Send/Sync impls need `T: Send`\n\nAffected versions of this crate unconditionally implemented `Send`/`Sync` for `QueueSender<T>`,\nallowing to send non-Send `T` to other threads by invoking `(&QueueSender<T>).send()`.\n\nThis fails to prevent users from creating data races by sending types like `Rc<T>` or `Arc<Cell<T>>` to other threads, which can lead to memory corruption.\n\nThe flaw was corrected in commit 1e462c3 by imposing `T: Send` to both `Send`/`Sync` impls for `QueueSender<T>`/`QueueReceiver<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0051",
      "package": "rustsec",
      "date": "2020-10-01",
      "url": "https://github.com/RustSec/advisory-db/issues/414"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        ">= 0.19.0"
      ]
    },
    "text": "\n\n# Obsolete versions of the `rustsec` crate do not support the new V3 advisory format\n\nIf you are seeing this message, you are running an obsolete version of\n`cargo-audit` which does not support the new V3 advisory format.\nThese versions are end-of-life.\n\nThis advisory is a notice that that it will soon be unable to parse the\nadvisory database.\n\nPlease upgrade `cargo-audit` to a newer release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0098",
      "package": "rusb",
      "aliases": [
        "CVE-2020-36206",
        "GHSA-9mxw-4856-9cm5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-18",
      "url": "https://github.com/a1ien/rusb/issues/44",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ],
      "unaffected": []
    },
    "text": "\n\n# UsbContext trait did not require implementers to be Send and Sync.\n\nAffected versions of `rusb` did not require `UsbContext` to implement `Send`\nand `Sync`. However, through `Device` and `DeviceHandle` it is possible to use\n`UsbContext`s across threads.\n\nThis issue allows non-thread safe `UsbContext` types to be used concurrently\nleading to data races and memory corruption.\n\nThe issue was fixed by adding `Send` and `Sync` bounds to `UsbContext`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0019",
      "package": "blake2",
      "aliases": [
        "CVE-2019-16143",
        "GHSA-4x25-pvhw-5224"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "crypto-failure"
      ],
      "date": "2019-08-25",
      "url": "https://github.com/RustCrypto/MACs/issues/19"
    },
    "versions": {
      "patched": [
        ">= 0.8.1"
      ]
    },
    "text": "\n\n# HMAC-BLAKE2 algorithms compute incorrect results\n\nWhen used in conjunction with the Hash-based Message Authentication Code (HMAC),\nthe BLAKE2b and BLAKE2s implementations in `blake2` crate versions prior to\nv0.8.1 used an incorrect block size (32-bytes instead of 64-bytes for BLAKE2s,\nand 64-bytes instead of 128-bytes for BLAKE2b), causing them to miscompute the\n`MacResult`.\n\nThe v0.8.1 release of the `blake2` crate uses the correct block sizes.\n\nNote that this advisory only impacts usage of BLAKE2 with HMAC, and does not\nimpact `Digest` functionality.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0075",
      "package": "unsafe-libyaml",
      "date": "2023-12-20",
      "url": "https://github.com/dtolnay/unsafe-libyaml/issues/21",
      "informational": "unsound",
      "keywords": [
        "unaligned-write"
      ],
      "aliases": [
        "GHSA-r24f-hg58-vfrw"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.10"
      ]
    },
    "text": "\n\n# Unaligned write of u64 on 32-bit and 16-bit platforms\n\nAffected versions allocate memory using the alignment of `usize` and write data\nto it of type `u64`, without using `core::ptr::write_unaligned`. In platforms\nwith sub-64bit alignment for `usize` (including wasm32 and x86) these writes\nare insufficiently aligned some of the time.\n\nIf using an ordinary optimized standard library, the bug exhibits Undefined\nBehavior so may or may not behave in any sensible way, depending on\noptimization settings and hardware and other things. If using a Rust standard\nlibrary built with debug assertions enabled, the bug manifests deterministically\nin a crash (non-unwinding panic) saying _\"ptr::write requires that the pointer\nargument is aligned and non-null\"_.\n\nNo 64-bit platform is impacted by the bug.\n\nThe flaw was corrected by allocating with adequately high alignment on all\nplatforms.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0003",
      "package": "protobuf",
      "aliases": [
        "CVE-2019-15544",
        "GHSA-mh6h-f25p-98f8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2019-06-08",
      "keywords": [
        "oom",
        "panic"
      ],
      "url": "https://github.com/stepancheg/rust-protobuf/issues/411"
    },
    "affected": {
      "functions": {
        "protobuf::stream::read_raw_bytes_into": [
          "< 2.6.0"
        ]
      }
    },
    "versions": {
      "patched": [
        "^1.7.5",
        ">= 2.6.0"
      ]
    },
    "text": "\n\n# Out of Memory in stream::read_raw_bytes_into()\n\nAffected versions of this crate called Vec::reserve() on user-supplied input.\n\nThis allows an attacker to cause an Out of Memory condition while calling the\nvulnerable method on untrusted data.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0020",
      "package": "stb_truetype",
      "date": "2020-04-18",
      "informational": "unmaintained",
      "url": "https://gitlab.redox-os.org/redox-os/stb_truetype-rs/-/commit/f1f5be4794e87bfc80a4255bc3f23ed75dd77645"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `stb_truetype` crate has been deprecated; use `ttf-parser` instead\n\nThis crate was maintained for use in rusttype which has switched to use [ttf-parser](https://crates.io/crates/ttf-parser)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0039",
      "package": "odbc",
      "date": "2022-01-17",
      "informational": "unmaintained",
      "url": "https://github.com/Koka/odbc-rs/commit/f9e5f77fac0a6328f9759e6e0f9e10c16509aebb"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# project abandoned\n\nAlternatives:\n- `odbc-api`\n- `rs-odbc`\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0069",
      "package": "sudo-rs",
      "date": "2023-11-01",
      "url": "https://github.com/advisories/GHSA-2r3c-m6v7-9354",
      "references": [
        "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-42456"
      ],
      "categories": [
        "file-disclosure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:U/C:N/I:L/A:L",
      "keywords": [
        "directory traversal",
        "http"
      ],
      "aliases": [
        "CVE-2023-42456",
        "GHSA-2r3c-m6v7-9354"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# sudo-rs: Path Traversal vulnerability\n\n## Impact\nAn issue was discovered where usernames containing the . and / characters could result in the corruption of specific files on the filesystem. As usernames are generally not limited by the characters they can contain, a username appearing to be a relative path can be constructed. For example we could add a user to the system containing the username ../../../../bin/cp. When logged in as a user with that name, that user could run sudo -K to clear their session record file. The session code then constructs the path to the session file by concatenating the username to the session file storage directory, resulting in a resolved path of /bin/cp. The code then clears that file, resulting in the cp binary effectively being removed from the system.\n\nAn attacker needs to be able to login as a user with a constructed username. Given that such a username is unlikely to exist on an existing system, they will also need to be able to create the users with the constructed usernames.\n\n## Patches\nThe bug is fixed in version 0.2.1 of sudo-rs. Sudo-rs now uses the uid for the user instead of their username for determining the filename. Note that an upgrade to this version will result in existing session files being ignored and users will be forced to re-authenticate. It also fully eliminates any possibility of path traversal, given that uids are always integer values.\n\nThe issue was corrected in commit `bfdbda22968e3de43fa8246cab1681cfd5d5493d`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0018",
      "package": "renderdoc",
      "aliases": [
        "CVE-2019-16142",
        "GHSA-vhfr-v4w9-45v8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-09-02",
      "keywords": [
        "undefined_behavior"
      ],
      "url": "https://github.com/ebkalderon/renderdoc-rs/pull/32"
    },
    "affected": {
      "functions": {
        "renderdoc::api::RenderDocV110::trigger_multi_frame_capture": [
          "< 0.5.0"
        ],
        "renderdoc::api::RenderDocV120::set_capture_file_comments": [
          "< 0.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.5.0"
      ]
    },
    "text": "\n\n# Internally mutating methods take immutable ref self\n\nAffected versions of this crate exposed several methods which took `self` by\nimmutable reference, despite the requesting the RenderDoc API to set a mutable\nvalue internally.\n\nThis is technically unsound and calling these methods from multiple threads\nwithout synchronization could lead to unexpected and unpredictable behavior.\n\nThe flaw was corrected in release 0.5.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0076",
      "package": "wasmtime",
      "date": "2022-11-10",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory",
        "allocator",
        "Wasm",
        "bounds",
        "sandbox",
        "paging"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "aliases": [
        "CVE-2022-39392",
        "GHSA-44mr-8vmm-wjhg"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.2, < 2.0.0",
        ">= 2.0.2"
      ]
    },
    "affected": {
      "functions": {
        "wasmtime::PoolingAllocationConfig::instance_memory_pages": [
          ">= 2.0.0, < 2.0.2"
        ],
        "wasmtime::Config::allocation_strategy": [
          "< 1.0.2"
        ]
      }
    },
    "text": "\n\n# Bug in Wasmtime implementation of pooling instance allocator\n\nBug in Wasmtime's implementation of its pooling instance allocator when the allocator is configured to give WebAssembly instances a maximum of zero pages of memory.\n\nIn this configuration, the virtual memory mapping for WebAssembly memories did not meet the compiler-required configuration requirements for safely executing WebAssembly modules. Wasmtime's default settings require virtual memory page faults to indicate that wasm reads/writes are out-of-bounds, but the pooling allocator's configuration would not create an appropriate virtual memory mapping for this meaning out of bounds reads/writes can successfully read/write memory unrelated to the wasm sandbox within range of the base address of the memory mapping created by the pooling allocator.\n\nThis bug is not applicable with the default settings of the `wasmtime` crate.\n\nThis bug can only be triggered by setting `InstanceLimits::memory_pages` to zero.\n\nThis is expected to be a very rare configuration since this means that wasm modules cannot allocate any pages of linear memory.\n\nAll wasm modules produced by all current toolchains are highly likely to use linear memory, so it's expected to be unlikely that this configuration is set to zero by any production embedding of Wasmtime.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0110",
      "package": "wasmtime",
      "date": "2021-09-17",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf",
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49",
        "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "out-of-bounds read",
        "out-of-bounds write",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2021-39216",
        "CVE-2021-39218",
        "CVE-2021-39219",
        "GHSA-4873-36h9-wv49",
        "GHSA-q879-9g95-56mx",
        "GHSA-v4cp-h94r-m7xf"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.30.0"
      ],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "wasmtime::Store::gc": [
          "< 0.30.0"
        ],
        "wasmtime::Linker::func_wrap": [
          "< 0.30.0"
        ],
        "wasmtime::Linker::func_new": [
          "< 0.30.0"
        ]
      }
    },
    "text": "\n\n# Multiple Vulnerabilities in Wasmtime\n\n* [Use after free passing `externref`s to Wasm in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf)\n\n* [Out-of-bounds read/write and invalid free with `externref`s and GC safepoints\n  in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49)\n\n* [Wrong type for `Linker`-define functions when used across two\n  `Engine`s](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0016",
      "package": "wasmtime",
      "date": "2022-03-31",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2022-24791",
        "GHSA-gwc9-348x-qwv2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.35.2",
        ">= 0.34.2, < 0.35.0"
      ],
      "unaffected": [
        "< 0.34.0"
      ]
    },
    "affected": {
      "functions": {
        "wasmtime::Config::epoch_interruption": [
          "0.34.0",
          "0.34.1",
          "0.35.0",
          "0.35.1"
        ]
      }
    },
    "text": "\n\n# Use after free with `externref`s and epoch interruption in Wasmtime\n\n[Use after free with `externref`s and epoch interruption in Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0075",
      "package": "wasmtime",
      "date": "2022-11-10",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf",
      "references": [
        "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
        "https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6"
      ],
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free",
        "Wasm",
        "garbage collection"
      ],
      "aliases": [
        "CVE-2022-39393",
        "GHSA-wh6w-3828-g9qf"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.2, < 2.0.0",
        ">= 2.0.2"
      ]
    },
    "text": "\n\n# Bug in pooling instance allocator\n\nbug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance.\n\nMitigations are described [here](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0015",
      "package": "ascii",
      "date": "2023-02-25",
      "url": "https://github.com/tomprogrammer/rust-ascii/issues/64",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "ascii"
      ],
      "aliases": [
        "GHSA-mrrw-grhq-86gf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.3"
      ],
      "unaffected": [
        "<= 0.6.0"
      ]
    },
    "text": "\n\n# Ascii allows out-of-bounds array indexing in safe code\n\nAffected version of this crate had implementation of `From<&mut AsciiStr>` for `&mut [u8]` and `&mut str`. This can result in out-of-bounds array indexing in safe code.\n\nThe flaw was corrected in commit [8a6c779](https://github.com/tomprogrammer/rust-ascii/pull/63/commits/8a6c7798c202766bd57d70fb8d12739dd68fb9dc) by removing those impls.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0042",
      "package": "stack",
      "aliases": [
        "CVE-2020-35895",
        "GHSA-h45v-vgvp-3h5v"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-09-24",
      "url": "https://github.com/arcnmx/stack-rs/issues/4"
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "text": "\n\n# Missing check in ArrayVec leads to out-of-bounds write.\n\nArrayVec::insert allows insertion of an element into the array object into the\nspecified index. Due to a missing check on the upperbound of this index, it is\npossible to write out of bounds.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0104",
      "package": "gfwx",
      "aliases": [
        "CVE-2020-36211",
        "GHSA-xp6v-qx65-4pp7"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-08",
      "url": "https://github.com/Devolutions/gfwx-rs/issues/7",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# ImageChunkMut needs bounds on its Send and Sync traits\n\nIn the affected versions of this crate, `ImageChunkMut<'_, T>` unconditionally implements `Send` and `Sync`, allowing to create data races.\n\nThis can result in a memory corruption or undefined behavior when non thread-safe types are moved and referenced across thread boundaries.\n\nThe flaw was corrected in commit e7fb2f5 by adding `T: Send` bound to the `Send` impl and adding `T: Sync` bound to the `Sync` impl.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0047",
      "package": "array-queue",
      "aliases": [
        "CVE-2020-35900",
        "GHSA-75cq-g75g-rxff"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
      "date": "2020-09-26",
      "keywords": [
        "memory-corruption",
        "uninitialized-memory",
        "use-after-free"
      ],
      "url": "https://github.com/raviqqe/array-queue/issues/2"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# array_queue pop_back() may cause a use-after-free\n\narray_queue implements a circular queue that wraps around an array. However, it\nfails to properly index into the array in the `pop_back` function allowing the\nreading of previously dropped or uninitialized memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0144",
      "package": "traitobject",
      "date": "2021-10-04",
      "informational": "unmaintained",
      "url": "https://github.com/reem/rust-traitobject/issues/7",
      "references": [
        "https://rustsec.org/advisories/RUSTSEC-2020-0027"
      ],
      "aliases": [
        "GHSA-pp8r-vv2j-9j5v"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# traitobject is Unmaintained\n\nCrate `traitobject` has not had a release for over five years.\n\nIn addition there is an existing security advisory that has not been addressed:\n\n - [RUSTSEC-2020-0027](https://rustsec.org/advisories/RUSTSEC-2020-0027)\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [destructure_traitobject]\n\n[destructure_traitobject]: https://crates.io/crates/destructure_traitobject\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0027",
      "package": "traitobject",
      "aliases": [
        "CVE-2020-35881",
        "GHSA-j79j-cx3h-g27h"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-06-01",
      "informational": "unsound",
      "url": "https://github.com/reem/rust-traitobject/issues/7"
    },
    "affected": {
      "functions": {
        "traitobject::data": [],
        "traitobject::data_mut": []
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# traitobject assumes the layout of fat pointers\n\nThis crate gets the data pointer from fat pointers assuming that the first\nelement in a fat pointer is the data pointer. This is currently true, but\nit may change in a future Rust version, leading to memory corruption.\n\nThis has been fixed in the master branch of the crate, but is has not\nbeen released into crates.io.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0033",
      "package": "alg_ds",
      "date": "2020-08-25",
      "url": "https://gitlab.com/dvshapkin/alg-ds/-/issues/1",
      "aliases": [
        "CVE-2020-36432",
        "GHSA-3vv3-frrq-6486"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Matrix::new() drops uninitialized memory\n\n`Matrix::new()` internally calls `Matrix::fill_with()` which uses `*ptr = value` pattern to initialize the buffer.\nThis pattern assumes that there is an initialized struct at the address and drops it, which results in dropping of uninitialized struct.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0338",
      "package": "cosmwasm-std",
      "date": "2024-04-24",
      "url": "https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2024-002.md",
      "keywords": [
        "overflow",
        "integer",
        "arithmetic"
      ],
      "aliases": [
        "GHSA-8724-5xmm-w5xq"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.4.4, < 1.5.0",
        ">= 1.5.4, < 2.0.0",
        ">= 2.0.2"
      ],
      "unaffected": [
        "< 1.3.0"
      ]
    },
    "text": "\n\n# Arithmetic overflows in cosmwasm-std\n\nSome mathematical operations in `cosmwasm-std` use wrapping math instead of\npanicking on overflow for very big numbers. This can lead to wrong calculations in contracts\nthat use these operations.\n\nAffected functions:\n\n- `Uint{256,512}::pow` / `Int{256,512}::pow`\n- `Int{256,512}::neg`\n\nAffected if `overflow-checks = true` is not set:\n\n- `Uint{64,128}::pow` / `Int{64,128}::pow`\n- `Int{64,128}::neg`\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0164",
      "package": "cell-project",
      "date": "2020-08-27",
      "url": "https://github.com/RustyYato/cell-project/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "cell",
        "subtype",
        "variance"
      ],
      "informational": "unsound",
      "references": [
        "https://github.com/RustyYato/cell-project/issues/3",
        "https://github.com/RustyYato/cell-project/issues/4"
      ],
      "aliases": [
        "GHSA-p75v-367r-2v23"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.4"
      ]
    },
    "affected": {
      "functions": {
        "cell_project::cell_project": [
          "< 0.1.4"
        ],
        "cell_project::nightly_cell_project": [
          "< 0.1.4"
        ]
      }
    },
    "text": "\n\n# `cell-project` used incorrect variance when projecting through `&Cell<T>`\n\n## Overview\n\nThe issue lies in the implementation of the `cell_project` macro which used `field as *const _` instead of `field as *mut _`.\nThe problem being that `*const T` is covariant in `T` while `*mut T` is invariant in `T`. Keep in mind that `&Cell<T>` is invariant in `T`,\nso casting to `*const T` relaxed the variance, and lead to unsoundness, as shown in the example below.\n\n```rs\nuse std::cell::Cell;\nuse cell_project::cell_project as cp;\n\nstruct Foo<'a> {\n    x: Option<&'a Cell<Foo<'a>>>,\n}\n\nimpl<'a> Drop for Foo<'a> {\n    fn drop(&mut self) {\n        // `ourselves` is an &Cell<Self>.\n        // NB: `Drop` is unsound.\n        if let Some(ourselves) = self.x.as_ref() {\n            // replace `self` (but this doesn't actually replace `self`)\n            let is_x_none = ourselves.replace(Foo {\n                x: None,\n            }).x.as_ref().is_none();\n            // if we just moved out of `self`, and we had a `Some` originally,\n            // how come this is a `None`?\n            if is_x_none {\n                println!(\"how did we get a None?\");\n            }\n        }\n    }\n}\n\nfn main() {\n    let foo = Cell::new(Foo {\n        x: None,\n    });\n    let x = cp!(Foo<'_>, foo.x);\n    x.set(Some(&foo));\n}\n```\n\n### MIRI error\n\n```rs\n$ cargo +nightly miri run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `<snip>`\nerror: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <2472> (call 796)]\n   --> $RUST_STD_PATH/src/rust/library/core/src/cell.rs:404:31\n    |\n404 |         mem::replace(unsafe { &mut *self.value.get() }, val)\n    |                               ^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <2472> (call 796)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n\n    = note: inside `std::cell::Cell::<Foo>::replace` at $RUST_STD_PATH/src/rust/library/core/src/cell.rs:404:31\nnote: inside `<Foo as std::ops::Drop>::drop` at src/main.rs:14:29\n   --> src/main.rs:14:29\n    |\n14  |               let is_x_none = ourselves.replace(Foo {\n    |  _____________________________^\n15  | |                 x: None,\n16  | |             }).x.as_ref().is_none();\n    | |______________^\n    = note: inside `std::ptr::drop_in_place::<Foo> - shim(Some(Foo))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\n    = note: inside `std::ptr::drop_in_place::<std::cell::UnsafeCell<Foo>> - shim(Some(std::cell::UnsafeCell<Foo>))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\n    = note: inside `std::ptr::drop_in_place::<std::cell::Cell<Foo>> - shim(Some(std::cell::Cell<Foo>))` at $RUST_STD_PATH/src/rust/library/core/src/ptr/mod.rs:486:1\nnote: inside `main` at src/main.rs:32:1\n   --> src/main.rs:32:1\n    |\n32  | }\n    | ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to previous error\n```\n\n## Affected Versions\n\nAll versions of the cell-project crate before `0.1.4` are affected.\n\n## Mitigation\n\nThis was fixed in [Issues/4], and released as version `0.1.4`.\nSo just updating to the latest version will include the fix (which may result in a compile error on unsound usage).\n\n## Acknowledgements\n\nThis was discovered and fixed by @SoniEx2 in cell-project: [Issues/3] and [Issues/4]\n\n[issues/3]: https://github.com/RustyYato/cell-project/issues/3\n[issues/4]: https://github.com/RustyYato/cell-project/issues/4\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0070",
      "package": "secp256k1",
      "date": "2022-11-30",
      "url": "https://github.com/rust-bitcoin/rust-secp256k1/issues/543",
      "references": [
        "https://github.com/rust-bitcoin/rust-secp256k1/pull/548"
      ],
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "unsound-api",
        "invalid-free"
      ],
      "aliases": [
        "GHSA-969w-q74q-9j8v"
      ]
    },
    "affected": {
      "functions": {
        "secp256k1::Secp256k1::preallocated_gen_new": [
          "< 0.22.2",
          ">= 0.23.0, < 0.23.5",
          ">= 0.24.0, < 0.24.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.22.2, < 0.23.0",
        ">= 0.23.5, < 0.24.0",
        ">= 0.24.2"
      ],
      "unaffected": [
        "< 0.14.0"
      ]
    },
    "text": "\n\n# Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code\n\nBecause of incorrect bounds on method `Secp256k1::preallocated_gen_new` it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.\n\nThe method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses `unsafe` and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. `'static`). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.\n\nYou are unaffected if you either\n\n* don't call `Secp256k1::preallocated_gen_new`\n* manually checked that your usage of the method is sound\n* upgraded to the patched version of `secp256k1` (recommended)\n\nThe patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straightforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.\n\nSee the [GitHub issue](https://github.com/rust-bitcoin/rust-secp256k1/issues/543) for example \"exploit\" code and further discussion.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0018",
      "package": "remove_dir_all",
      "date": "2023-02-24",
      "url": "https://github.com/XAMPPRocky/remove_dir_all/commit/7247a8b6ee59fc99bbb69ca6b3ca4bfd8c809ead",
      "references": [
        "https://github.com/advisories/GHSA-mc8h-8q98-g5hr"
      ],
      "keywords": [
        "TOCTOU"
      ],
      "aliases": [
        "GHSA-mc8h-8q98-g5hr"
      ]
    },
    "affected": {
      "functions": {
        "remove_dir_all::remove_dir_all": [
          "< 0.8.0"
        ],
        "remove_dir_all::remove_dir_contents": [
          "< 0.8.0"
        ],
        "remove_dir_all::ensure_empty_dir": [
          "< 0.8.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ]
    },
    "text": "\n\n# Race Condition Enabling Link Following and Time-of-check Time-of-use (TOCTOU)\n\nThe remove_dir_all crate is a Rust library that offers additional features over the Rust\nstandard library fs::remove_dir_all function.\n\nIt was possible to trick a privileged process doing a recursive delete in an\nattacker controlled directory into deleting privileged files, on all operating systems.\n\nFor instance, consider deleting a tree called 'etc' in a parent directory\ncalled 'p'. Between calling `remove_dir_all(\"a\")` and remove_dir_all(\"a\")\nactually starting its work, the attacker can move 'p' to 'p-prime', and\nreplace 'p' with a symlink to '/'. Then the privileged process deletes 'p/etc'\nwhich is actually /etc, and now your system is broken. There are some\nmitigations for this exact scenario, such as CWD relative file lookup, but\nthey are not guaranteed - any code using absolute paths will not have that\nprotection in place.\n\nThe same attack could be performed at any point in the directory tree being\ndeleted: if 'a' contains a child directory called 'etc', attacking the\ndeletion by replacing 'a' with a link is possible.\n\nThe new code in this release mitigates the attack within the directory tree\nbeing deleted by using file-handle relative operations: to open 'a/etc', the\npath 'etc' relative to 'a' is opened, where 'a' is represented by a file\ndescriptor (Unix) or handle (Windows). With the exception of the entry points\ninto the directory deletion logic, this is robust against manipulation of the\ndirectory hierarchy, and remove_dir_all will only delete files and directories\ncontained in the tree it is deleting.\n\nThe entry path however is a challenge - as described above, there are some\npotential mitigations, but since using them must be done by the calling code,\nit is hard to be confident about the security properties of the path based\ninterface.\n\nThe new extension trait `RemoveDir` provides an interface where it is much\nharder to get it wrong.\n\n`somedir.remove_dir_contents(\"name-of-child\")`.\n\nCallers can then make their own security evaluation about how to securely get\na directory handle. That is still not particularly obvious, and we're going to\nfollow up with a helper of some sort (probably in the `fs_at` crate). Once\nthat is available, the path based entry points will get deprecated.\n\nIn the interim, processes that might run with elevated privileges should\nfigure out how to securely identify the directory they are going to delete, to\navoid the initial race. Pragmatically, other processes should be fine with the\npath based entry points : this is the same interface `std::fs::remove_dir_all`\noffers, and an unprivileged process running in an attacker controlled\ndirectory can't do anything that the attacker can't already do.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0358",
      "package": "object_store",
      "date": "2024-07-23",
      "url": "https://github.com/apache/arrow-rs/pull/6074",
      "references": [
        "https://www.openwall.com/lists/oss-security/2024/07/23/3"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N",
      "keywords": [
        "information",
        "leak",
        "aws",
        "oidc",
        "logs"
      ],
      "aliases": [
        "CVE-2024-41178"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.2"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "text": "\n\n# Apache Arrow Rust Object Store: AWS WebIdentityToken exposure in log files\n\nExposure of temporary credentials in logs in Apache Arrow Rust Object Store,\nversion 0.10.1 and earlier on all platforms using AWS WebIdentityTokens.\n\nOn certain error conditions, the logs may contain the OIDC token passed to\n[AssumeRoleWithWebIdentity](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html).\nThis allows someone with access to the logs to impersonate that identity,\nincluding performing their own calls to AssumeRoleWithWebIdentity, until the\nOIDC token expires. Typically OIDC tokens are valid for up to an hour, although\nthis will vary depending on the issuer.\n\nUsers are recommended to use a different AWS authentication mechanism, disable\nlogging or upgrade to version 0.10.2, which fixes this issue.\n\n## Details\n\nWhen using AWS WebIdentityTokens with the `object_store` crate, in the event of\na failure and automatic retry, the underlying `reqwest` error, including the\nfull URL with the credentials, potentially in the parameters, is written to the\nlogs.\n\nThanks to Paul Hatcherian for reporting this vulnerability\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0092",
      "package": "messagepack-rs",
      "date": "2021-01-26",
      "url": "https://github.com/otake84/messagepack-rs/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "aliases": [
        "CVE-2021-45690",
        "CVE-2021-45691",
        "CVE-2021-45692",
        "CVE-2021-45693",
        "GHSA-hr52-f9vp-582c",
        "GHSA-jqjj-r4qp-x2gh",
        "GHSA-jwfh-j623-m97h",
        "GHSA-m325-rxjv-pwph",
        "GHSA-vw5m-qw2r-m923"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Deserialization functions pass uninitialized memory to user-provided Read\n\nAffected versions of this crate passed an uninitialized buffer to a\nuser-provided `Read` instance in:\n\n* `deserialize_binary`\n* `deserialize_string`\n* `deserialize_extension_others`\n* `deserialize_string_primitive`\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0360",
      "package": "xmp_toolkit",
      "date": "2024-07-26",
      "url": "https://github.com/adobe/xmp-toolkit-rs/issues/233",
      "informational": "unsound",
      "keywords": [
        "xmp"
      ]
    },
    "affected": {
      "functions": {
        "xmp_toolkit::XmpFile::close": [
          "< 1.9.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.9.0"
      ]
    },
    "text": "\n\n# `XmpFile::close` can trigger UB\n\nAffected versions of the crate failed to catch C++ exceptions raised within the `XmpFile::close` function. If such an exception occured, it would trigger undefined behavior, typically a process abort.\n\nThis is best demonstrated in [issue #230](https://github.com/adobe/xmp-toolkit-rs/issues/230), where a race condition causes the `close` call to fail due to file I/O errors.\n\nThis was fixed in [PR #232](https://github.com/adobe/xmp-toolkit-rs/pull/232) (released as crate version 1.9.0), which now safely handles the exception.\n\nFor backward compatibility, the existing API ignores the error. A new API `XmpFile::try_close` was added to allow callers to receive and process the error result.\n\nUsers of all prior versions of `xmp_toolkit` are encouraged to update to version 1.9.0 to avoid undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0153",
      "package": "bite",
      "date": "2020-12-31",
      "url": "https://github.com/hinaria/bite/issues/1",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36511",
        "GHSA-72r2-rg28-47v9",
        "GHSA-v2ch-fc8f-qm33"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `read` on uninitialized buffer may cause UB (bite::read::BiteReadExpandedExt::read_framed_max)\n\nAffected versions of this crate calls a user provided `Read` implementation on an uninitialized buffer.\n\n`Read` on uninitialized buffer is defined as undefined behavior in Rust.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0060",
      "package": "libwebp-sys2",
      "date": "2023-09-12",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "webp"
      ],
      "aliases": [
        "CVE-2023-4863",
        "CVE-2023-5129",
        "GHSA-j7hp-h8jx-5ppr"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.8"
      ]
    },
    "text": "\n\n# libwebp: OOB write in BuildHuffmanTable\n\n[Google](https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html) and [Mozilla](https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/) have released security advisories for RCE due to heap overflow in libwebp. Google warns the vulnerability has been exploited in the wild.\n\nlibwebp needs to be updated to 1.3.2 to include a patch for \"OOB write in BuildHuffmanTable\".\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0063",
      "package": "linked_list_allocator",
      "date": "2022-09-07",
      "url": "https://github.com/advisories/GHSA-xg8p-34w2-j49j",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2022-36086",
        "GHSA-xg8p-34w2-j49j"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.10.2"
      ],
      "unaffected": []
    },
    "text": "\n\n# Multiple vulnerabilities resulting in out-of-bounds writes\n\n* The heap initialization methods were missing a minimum size check for the given heap size argument. This could lead to **out-of-bound writes** when a heap was initialized with a size smaller than `3 * size_of::<usize>` because of metadata write operations.\n* When calling `Heap::extend` with a size smaller than two `usize`s (e.g., 16 on `x86_64`), the size was erroneously rounded up to the minimum size, which could result in an **out-of-bounds write**.\n* Calling `Heap::extend` on an empty heap tried to construct a heap starting at address 0, which is also an **out-of-bounds write**.\n  * One specific way to trigger this accidentally is to call `Heap::new` (or a similar constructor) with a heap size that is smaller than two `usize`s. This was treated as an empty heap as well.\n* Calling `Heap::extend` on a heap whose size is not a multiple of the size of two `usize`s resulted in unaligned writes. It also left the heap in an unexpected state, which might lead to subsequent issues. We did not find a way to exploit this undefined behavior yet (apart from DoS on platforms that fault on unaligned writes).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0017",
      "package": "cassandra-cpp",
      "date": "2024-02-28",
      "url": "https://github.com/Metaswitch/cassandra-rs/security/advisories/GHSA-x9xc-63hg-vcfq",
      "informational": "unsound",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory-safety",
        "use-after-free"
      ],
      "aliases": [
        "CVE-2024-27284",
        "GHSA-x9xc-63hg-vcfq"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.0.0"
      ]
    },
    "text": "\n\n# Non-idiomatic use of iterators leads to use after free\n\nCode that attempts to use an item (e.g., a row) returned by an iterator after the iterator has advanced to the next item will be accessing freed memory and experience undefined behaviour. Code that uses the item and then advances the iterator is unaffected. This problem has always existed.\n\nThis is a use-after-free bug, so it's rated high severity. If your code uses a pre-3.0.0 version of cassandra-rs, and uses an item returned by a cassandra-rs iterator after calling `next()` on that iterator, then it is vulnerable. However, such code will almost always fail immediately - so we believe it is unlikely that any code using this pattern would have reached production. For peace of mind, we recommend you upgrade anyway.\n\n## Patches\n\nThe problem has been fixed in version 3.0.0 (commit 299e6ac50f87eb2823a373baec37b590a74994ee). Users should upgrade to ensure their code cannot use the problematic pattern. There is an upgrade guide in the project README.\n\n## Workarounds\n\nEnsure all usage fits the expected pattern. For example, use `get_first_row()` rather than an iterator, or completely process an item before advancing the iterator with `next()`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0023",
      "package": "string-interner",
      "aliases": [
        "CVE-2019-16882",
        "GHSA-49fq-pw77-6qxj"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2019-08-24",
      "keywords": [
        "use after free"
      ],
      "url": "https://github.com/Robbepop/string-interner/issues/9"
    },
    "versions": {
      "patched": [
        "^0.6.4",
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# Cloned interners may read already dropped strings\n\nAffected versions of this crate did not clone contained strings when an interner is cloned.\nInterners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned.\nIf a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.\n\nThis allows an attacker to read the already freed memory.\nThe dangling pointers are used by the interners to check a string is already interned.\nAn attacker can do brute force attack to get the data pointed by the dangling pointer.\n\nThe flaw was corrected by <https://github.com/Robbepop/string-interner/pull/10>.\nThis patch implements `Clone` manually to the interner type, so that the internal raw pointers always point the strings owned by the same interner.\n\nPR #10 was also backported to the 0.6 release line in\n<https://github.com/Robbepop/string-interner/pull/14> and was released in 0.6.4.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0127",
      "package": "serde_cbor",
      "date": "2021-08-15",
      "url": "https://github.com/pyfisch/cbor",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# serde_cbor is unmaintained\n\nThe `serde_cbor` crate is unmaintained. The author has archived the github repository.\n\nAlternatives proposed by the author:\n\n * [`ciborium`](https://crates.io/crates/ciborium)\n * [`minicbor`](https://crates.io/crates/minicbor)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0025",
      "package": "serde_cbor",
      "aliases": [
        "CVE-2019-25001",
        "GHSA-xr7r-88qv-q7hm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "crypto-failure"
      ],
      "date": "2019-10-03",
      "keywords": [
        "stack-overflow",
        "crash",
        "denial-of-service"
      ],
      "url": "https://github.com/pyfisch/cbor/releases/tag/v0.10.2"
    },
    "versions": {
      "patched": [
        ">= 0.10.2"
      ]
    },
    "text": "\n\n# Flaw in CBOR deserializer allows stack overflow\n\nAffected versions of this crate did not properly check if semantic tags were nested excessively during deserialization.\n\nThis allows an attacker to craft small (< 1 kB) CBOR documents that cause a stack overflow.\n \nThe flaw was corrected by limiting the allowed number of nested tags.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0052",
      "package": "os_socketaddr",
      "date": "2022-08-26",
      "url": "https://github.com/a-ba/os_socketaddr/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-c439-chv8-8g2j"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.2"
      ]
    },
    "text": "\n\n# `os_socketaddr` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`os_socketaddr`](https://crates.io/crates/os_socketaddr) crate has assumed\n`std::net::SocketAddrV4` and `std::net::SocketAddrV6` have the same memory layout as the system C\nrepresentation `sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation.\n\nThese layout were [changed into idiomatic rust types](https://github.com/rust-lang/rust/pull/78802)\nin nightly `std`. Starting from rustc 1.64 the affected versions of this crate will have undefined\nbehaviour.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0033",
      "package": "borsh",
      "date": "2023-04-12",
      "url": "https://github.com/near/borsh-rs/issues/19",
      "references": [
        "https://github.com/near/borsh-rs/pull/136"
      ],
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-fjx5-qpf4-xjf2"
      ]
    },
    "affected": {},
    "versions": {
      "patched": [
        ">= 1.0.0-alpha.1",
        "^0.10.4"
      ]
    },
    "text": "\n\n# Parsing borsh messages with ZST which are not-copy/clone is unsound\n\nAffected versions of borsh cause undefined behavior when zero-sized-types (ZST) \nare parsed and the Copy/Clone traits are not implemented/derived.\nFor instance if 1000 instances of a ZST are deserialized, and the ZST is not copy \n(this can be achieved through a singleton), then accessing/writing to deserialized \ndata will cause a segmentation fault.\n\nThere is currently no way for borsh to read data without also providing a Rust type. \nTherefore, if not ZST are used for serialization, then you are not affected by this issue. \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0339",
      "package": "tor-circmgr",
      "date": "2024-05-15",
      "url": "https://gitlab.torproject.org/tpo/core/arti/-/issues/1409",
      "keywords": [
        "tor",
        "privacy",
        "information-leak"
      ],
      "aliases": [
        "CVE-2024-35312",
        "CVE-2024-35313",
        "GHSA-9328-gcfq-p269",
        "GHSA-c96h-cxx6-rmg9",
        "TROVE-2024-003"
      ],
      "related": [
        "TROVE-2024-004"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.18.1"
      ],
      "unaffected": [
        "< 0.18.0"
      ]
    },
    "text": "\n\n# Tor path lengths too short when \"Vanguards lite\" configured\n\n## Description\n\nWhen building anonymizing circuits to or from an onion service with \n'lite' vanguards (the default) enabled, \nthe circuit manager code would build the circuits with one hop too few.\n\n## Impact\n\nThis makes users of this code more vulnerable to some kinds of traffic analysis\nwhen they run or visit onion services.\n\n## Vulnerable configurations and use cases\n\nArti configured with \"vangaurds lite\" is vulnerable;\nthis is the default.\n\nOnly users who make connections to Onion Services\n(Tor Hidden Services) are affected.\nNote, however, that when used as a browser proxy,\nmalicious web pages can typically make such connections.\n\n## Mitigation\n\nEnable the \"full vanguards\" feature.\nThis has some cost in terms of performance, reliability,\nand impact on the Tor Network.\n\n(Arti configured with \"full vanguards\" has a similar bug,\nTROVE-2024-04,\nso this will not deliver the full incressed security of \"full vanguards\";\nbut the security level of affected versions of Arti\nconfigured with \"full vanguards\" still exceeds\nthe intended security level of the \"vanguards lite\" configuration.)\n\nAlternatively,\npreventing access to Tor Hidden Services will avoid the problem,\nwith corresponding loss of functionality.\nThis can be achieved in the Arti configuration file with:\n\n```\n[address_filter]\nallow_onion_addrs = false\n```\n\n## Resolution\n\nRebuild `arti` (or other affected applications)\nwith a fixed version of `tor-circmgr`:\n0.18.1 or later.\n\nThe fixed `tor-circmgr` is on crates.io and available in\n[the upstream git repository](https://gitlab.torproject.org/tpo/core/arti)\nat signed tag `arti-v1.2.3`.\n\n### Note about older versions\n\nEven though earlier versions are classified as \"not affected\",\nthis is because in those versions the Vanguards feature\nis experimental, or absent.\nDowngrading worsens security, rather than improving it.\n\n## References\n\n * [arti#1409](https://gitlab.torproject.org/tpo/core/arti/-/issues/1409):\n   the ticket in the Arti bugtracker.\n * [TROVE](https://gitlab.torproject.org/tpo/core/team/-/wikis/NetworkTeam/TROVE)\n   Tor Project vulnerability database.\n * [arti#1400](https://gitlab.torproject.org/tpo/core/arti/-/issues/1400):\n   the similar bug with the full vanguards feature.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0340",
      "package": "tor-circmgr",
      "date": "2024-05-15",
      "url": "https://gitlab.torproject.org/tpo/core/arti/-/issues/1409",
      "keywords": [
        "tor",
        "privacy",
        "information-leak"
      ],
      "aliases": [
        "CVE-2024-35313",
        "GHSA-c96h-cxx6-rmg9",
        "TROVE-2024-004"
      ],
      "related": [
        "TROVE-2024-003"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.18.1"
      ],
      "unaffected": [
        "< 0.18.0"
      ]
    },
    "text": "\n\n# Tor path lengths too short when \"full Vanguards\" configured\n\n## Description\n\nWhen building anonymizing circuits to or from an onion service with \nfull vanguards enabled, \nthe circuit manager code would build the circuits with one hop too few.\n\n## Impact\n\nThis makes users of this code more vulnerable to some kinds of traffic analysis\nwhen they run or visit onion services.\n\n## Vulnerable configurations and use cases\n\nArti configured with \"full vangaurds\" is vulnerable.\n\nOnly users who make connections to Onion Services\n(Tor Hidden Services) are affected.\nNote, however, that when used as a browser proxy,\nmalicious web pages can typically make such connections.\n\n## Mitigation\n\nPreventing access to Tor Hidden Services will avoid the problem,\nwith corresponding loss of functionality.\nThis can be achieved in the Arti configuration file with:\n\n```\n[address_filter]\nallow_onion_addrs = false\n```\n\nChanging the configuration (eg to turn off vanguards)\nreclassifies the behaviour as \"as configured\",\nbut reduces security rather than improving it,\nso is not a mitigation.\n\n## Resolution\n\nRebuild `arti` (or other affected applications)\nwith a fixed version of `tor-circmgr`:\n0.18.1 or later.\n\nThe fixed `tor-circmgr` is on crates.io and available in\n[the upstream git repository](https://gitlab.torproject.org/tpo/core/arti)\nat signed tag `arti-v1.2.3`.\n\n### Note about older versions\n\nEven though earlier versions are classified as \"not affected\",\nthis is because in those versions the Vanguards feature\nis experimental, or absent.\nDowngrading worsens security, rather than improving it.\n\n## References\n\n * [arti#1400](https://gitlab.torproject.org/tpo/core/arti/-/issues/1400):\n   the ticket in the Arti bugtracker.\n * [TROVE](https://gitlab.torproject.org/tpo/core/team/-/wikis/NetworkTeam/TROVE)\n   Tor Project vulnerability database.\n * [arti#1409](https://gitlab.torproject.org/tpo/core/arti/-/issues/1409):\n   the similar bug with the vanguards lite feature.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0359",
      "package": "gix-attributes",
      "date": "2024-07-24",
      "url": "https://github.com/Byron/gitoxide/issues/1460",
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.22.3"
      ]
    },
    "text": "\n\n# The kstring integration in gix-attributes is unsound\n\n`gix-attributes` (in [`state::ValueRef`](https://github.com/Byron/gitoxide/blob/gix-attributes-v0.22.2/gix-attributes/src/state.rs#L19-L27)) unsafely creates a `&str` from a `&[u8]` containing non-UTF8 data, with the justification that so long as nothing reads the `&str` and relies on it being UTF-8 in the `&str`, there is no UB:\n\n```rust\n// SAFETY: our API makes accessing that value as `str` impossible, so illformed UTF8 is never exposed as such.\n```\n\nThe problem is that the non-UTF8 `str` **is** exposed to outside code: first to the `kstring` crate itself, which requires UTF-8 in its documentation and may have UB as a consequence of this, but also to `serde`, where it propagates to e.g. `serde_json`, `serde_yaml`, etc., where the same problems occur.\n\nThis is not sound, and it could cause further UB down the line in these places that can view the `&str`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0053",
      "package": "dirs",
      "date": "2020-10-16",
      "informational": "unmaintained",
      "url": "https://github.com/dirs-dev/dirs-rs",
      "withdrawn": "2021-04-19"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# dirs is unmaintained, use dirs-next instead\n\nThe `dirs` crate is not maintained any more;\nuse [`dirs-next`](https://crates.io/crates/dirs-next) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0021",
      "package": "stb_image",
      "date": "2023-03-19",
      "url": "https://github.com/servo/rust-stb-image/pull/102",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "NULL-pointer-dereference"
      ],
      "aliases": [
        "GHSA-ppjr-267j-5p9x"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.5"
      ]
    },
    "text": "\n\n# NULL pointer dereference in `stb_image`\n\nA bug in error handling in the `stb_image` C library could cause a NULL pointer dereference when attempting to load an invalid or unsupported image file.  This is fixed in version 0.2.5 and later of the `stb_image` Rust crate, by patching the C code to correctly handle NULL pointers.\n\nThank you to GitHub user 0xdd96 for finding and fixing this vulnerability.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0026",
      "package": "linked-hash-map",
      "aliases": [
        "CVE-2020-25573",
        "GHSA-r43h-gmrm-h5c9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-06-23",
      "informational": "unsound",
      "url": "https://github.com/contain-rs/linked-hash-map/pull/100"
    },
    "versions": {
      "patched": [
        ">= 0.5.3"
      ]
    },
    "text": "\n\n# linked-hash-map creates uninitialized NonNull pointer\n\nAffected versions of this crate called `mem::uninitialized()` to create a `NonNull<T>`,\nwhich is undefined behavior.\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0025",
      "package": "jsonrpc-quic",
      "date": "2021-02-15",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_api/pull/623"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `qjsonrpc`\n\nThis crate has been renamed from `jsonrpc-quic` to `qjsonrpc`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_api>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0347",
      "package": "zerovec",
      "date": "2024-07-01",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.4",
        ">= 0.9.7, <0.10.0"
      ]
    },
    "text": "\n\n# Incorrect usage of `#[repr(packed)]`\n\nThe affected versions make unsafe memory accesses under the assumption that `#[repr(packed)]` has a guaranteed field order. \n\nThe Rust specification does not guarantee this, and https://github.com/rust-lang/rust/pull/125360 (1.80.0-beta) starts \nreordering fields of `#[repr(packed)]` structs, leading to illegal memory accesses.\n\nThe patched versions `0.9.7` and `0.10.4` use `#[repr(C, packed)]`, which guarantees field order.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0362",
      "package": "alloy-json-abi",
      "date": "2024-07-30",
      "url": "https://github.com/alloy-rs/core/issues/702",
      "keywords": [
        "stack-overflow"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.7"
      ]
    },
    "text": "\n\n# Stack overflow when parsing specially crafted JSON ABI strings\n\nAffected versions of the `alloy-json-abi` crate did not properly handle parsing of malformatted JSON ABI strings. The `JsonAbi::parse` method can be tricked into a stack overflow when processing specially crafted input. \n\nThis stack overflow can lead to a crash of the application using this crate, potentially causing a denial of service.\n\nThe flaw was corrected in commit 4790c47.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0079",
      "package": "elf_rs",
      "date": "2022-10-31",
      "url": "https://github.com/vincenthouyi/elf_rs/issues/11",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "elf",
        "header"
      ],
      "aliases": [
        "GHSA-g6pw-999w-j75m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "affected": {},
    "text": "\n\n# ELF header parsing library doesn't check for valid offset\n\nThe crate has several unsafe sections that don't perform proper pointer validation.\n\nAn example can be found in the following function:\n\n```\nfn section_header_raw(&self) -> &[ET::SectionHeader] {\n    let sh_off = self.elf_header().section_header_offset() as usize;\n    let sh_num = self.elf_header().section_header_entry_num() as usize;\n    unsafe {\n        let sh_ptr = self.content().as_ptr().add(sh_off);\n        from_raw_parts(sh_ptr as *const ET::SectionHeader, sh_num)\n    }\n}\n```\n\nWhile this will work perfectly fine *if* the ELF header is valid, malicious or\nmalformed input can contain a section header offset of an arbitrary size, meaning\nthat the resultant pointer in the unsafe block can point to an artibrary address\nin the address space of the process.\n\nThis can result in unpredictable behaviour, and in our fuzz testing, we discovered\nthat it's trivial to cause SIGABRT (signal 6), or SEGV (signal 11).\n\nThe function should either be marked as unsafe, with a note that the caller is responsible\nfor providing only valid inputs, or it should ideally do the due diligence to ensure that the\noffset doesn't exceed the bounds of the header (and add additional checks as necessary).\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0034",
      "package": "office",
      "date": "2021-02-04",
      "url": "https://github.com/RustSec/advisory-db/issues/742#issuecomment-773313783",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# office is unmaintained, use calamine instead\n\nThe `office` crate is unmaintained. Use [calamine](https://crates.io/crates/calamine)\nfor reading excel files.\n\nContact the `office` author for ownership of the package name.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0067",
      "package": "cranelift-codegen",
      "date": "2021-05-21",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "miscompile",
        "sandbox",
        "wasm"
      ],
      "aliases": [
        "CVE-2021-32629",
        "GHSA-hpqh-2wqx-7qp5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.73.1"
      ]
    },
    "affected": {
      "arch": [
        "x86"
      ]
    },
    "text": "\n\n# Memory access due to code generation flaw in Cranelift module\n\nThere is a bug in 0.73.0 of the Cranelift x64 backend that can create a\nscenario that could result in a potential sandbox escape in a WebAssembly\nmodule. Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1\nor 0.74 to remediate this vulnerability. Users of Cranelift prior to 0.73.0\nshould update to 0.73.1 or 0.74 if they were not using the old default backend.\n\nMore details can be found in the GitHub Security Advisory at:\n\n<https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0004",
      "package": "libp2p-core",
      "aliases": [
        "CVE-2019-15545",
        "GHSA-4q4x-67hx-5mpg"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2019-05-15"
    },
    "versions": {
      "patched": [
        "^0.7.1",
        ">= 0.8.1"
      ],
      "unaffected": [
        "< 0.3"
      ]
    },
    "text": "\n\n# Failure to properly verify ed25519 signatures makes any signature valid\n\nAffected versions of this crate did not properly verify ed25519 signatures.\nAny signature with a correct length was considered valid.\n\nThis allows an attacker to impersonate any node identity.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0009",
      "package": "libp2p-core",
      "date": "2022-02-07",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "GHSA-wc36-xgcc-jwpr"
      ]
    },
    "affected": {
      "functions": {
        "libp2p_core::PeerRecord::from_signed_envelope": [
          ">= 0.30.0-rc.1"
        ]
      }
    },
    "versions": {
      "unaffected": [
        "< 0.30.0-rc.1"
      ],
      "patched": [
        "^ 0.30.2",
        ">= 0.31.1"
      ]
    },
    "text": "\n\n# Failure to verify the public key of a `SignedEnvelope` against the `PeerId` in a `PeerRecord`\n\nAffected versions of this crate did not check that the public key the signature was created with matches the peer ID of the peer record. \nAny combination was considered valid.\n\nThis allows an attacker to republish an existing `PeerRecord` with a different `PeerId`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0073",
      "package": "alloc-cortex-m",
      "date": "2022-12-21",
      "informational": "unmaintained",
      "url": "https://github.com/rust-embedded/embedded-alloc/pull/56"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `embedded-alloc`\n\nThis crate has been renamed from `alloc-cortex-m` to `embedded-alloc`.\n\nThe new repository location is:\n\n<https://github.com/rust-embedded/embedded-alloc>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0080",
      "package": "transpose",
      "date": "2023-12-18",
      "url": "https://github.com/ejmahler/transpose/issues/11",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "GHSA-5gmm-6m36-r7jh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "affected": {
      "functions": {
        "transpose::transpose": [
          ">= 0.1.0"
        ]
      }
    },
    "text": "\n\n# Buffer overflow due to integer overflow in `transpose`\n\nGiven the function `transpose::transpose`:\n```rust\nfn transpose<T: Copy>(input: &[T], output: &mut [T], input_width: usize, input_height: usize)\n```\n\nThe safety check `input_width * input_height == output.len()` can fail due to `input_width * input_height` overflowing in such a way that it equals `output.len()`.\nAs a result of failing the safety check, memory past the end of `output` is written to. This only occurs in release mode since `*` panics on overflow in debug mode.\n\nExploiting this issue requires the caller to pass `input_width` and `input_height` arguments such that multiplying them overflows, and the overflown result equals the lengths of input and output slices.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0024",
      "package": "rustsec-example-crate",
      "date": "2019-10-08",
      "url": "https://github.com/RustSec/advisory-db/issues/158"
    },
    "versions": {
      "patched": [
        ">= 1.0.0"
      ],
      "unaffected": [
        "< 0.0.1"
      ]
    },
    "text": "\n\n# Test advisory with associated example crate\n\nThis is a test advisory useful for verifying RustSec tooling and vulnerability\ndetection pipelines are working correctly. Aside from the fact that it is filed\nagainst an example crate, it is otherwise considered by the Advisory Database\nitself to be a normal security advisory.\n\nIt's filed against `rustsec-example-crate`, an otherwise completely empty crate\nwith no functionality or code, which has three releases:\n\n- [v0.0.0] - *unaffected* by this advisory (but *yanked* from crates.io)\n- [v0.0.1] - *vulnerable* according to this advisory\n- [v1.0.0] - *patched* by this advisory\n\n[v0.0.0]: https://crates.io/crates/rustsec-example-crate/0.0.0\n[v0.0.1]: https://crates.io/crates/rustsec-example-crate/0.0.1\n[v1.0.0]: https://crates.io/crates/rustsec-example-crate/1.0.0\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0047",
      "package": "slice-deque",
      "aliases": [
        "CVE-2021-29938",
        "GHSA-p9gf-gmfv-398m"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-02-19",
      "url": "https://github.com/gnzlbg/slice_deque/issues/90",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# SliceDeque::drain_filter can double drop an element if the predicate panics\n\nAffected versions of the crate incremented the current index of the drain filter\niterator *before* calling the predicate function `self.pred`.\n\nIf the predicate function panics, it is possible for the last element in the\niterator to be dropped twice.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0158",
      "package": "slice-deque",
      "date": "2020-02-10",
      "url": "https://github.com/gnzlbg/slice_deque/issues/94",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# slice-deque is unmaintained\n\nThe author of the `slice-deque` crate is unresponsive and is not receiving security patches.\n\nMaintained alternatives:\n\n- [`slice-ring-buffer`](https://crates.io/crates/slice-ring-buffer)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0002",
      "package": "slice-deque",
      "date": "2019-05-07",
      "aliases": [
        "CVE-2019-15543",
        "GHSA-c3m3-c39q-pv23"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "related": [
        "RUSTSEC-2018-0008"
      ],
      "keywords": [
        "memory-corruption",
        "rce"
      ],
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Bug in SliceDeque::move_head_unchecked corrupts its memory\n\nAffected versions of this crate entered a corrupted state if\n`mem::size_of::<T>() % allocation_granularity() != 0` and a specific allocation\npattern was used: sufficiently shifting the deque elements over the mirrored\npage boundary.\n\nThis allows an attacker that controls controls both element insertion and\nremoval to corrupt the deque, such that reading elements from it would read\nbytes corresponding to other elements in the deque. (e.g. a read of T could read\nsome bytes from one value and some bytes from an adjacent one, resulting in a T\nwhose value representation is not meaningful). This is undefined behavior.\n \nThe flaw was corrected by using a pair of pointers to track the head and tail of\nthe deque instead of a pair of indices. This pair of pointers are represented\nusing a Rust slice.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0008",
      "package": "slice-deque",
      "aliases": [
        "CVE-2018-20995",
        "GHSA-hr3c-6mmp-6m39"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-12-05",
      "keywords": [
        "memory-corruption",
        "rce"
      ],
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    },
    "versions": {
      "patched": [
        ">= 0.1.16"
      ]
    },
    "text": "\n\n# Bug in SliceDeque::move_head_unchecked allows read of corrupted memory\n\nAffected versions of this crate did not properly update the\nhead and tail of the deque when inserting and removing elements from the front\nif, before insertion or removal, the tail of the deque was in the mirrored\nmemory region, and if, after insertion or removal, the head of the deque is\nexactly at the beginning of the mirrored memory region.\n\nAn attacker that controls both element insertion and removal into the deque\ncould put it in a corrupted state. Once the deque enters such an state, its head\nand tail are corrupted, but in bounds of the allocated memory. This can result\nin partial reads and writes, reads of uninitialized memory, reads of memory\ncontaining previously dropped objects, etc. An attacker could exploit this to\nalter program execution.\n\nThe flaw was corrected by properly updating the head and tail of the deque in\nthis case. \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0374",
      "package": "ouch",
      "date": "2024-09-22",
      "url": "https://github.com/ouch-org/ouch/issues/707",
      "categories": [
        "memory-corruption"
      ]
    },
    "affected": {
      "functions": {
        "ouch::archive::zip::convert_zip_date_time": [
          "<=0.3.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">0.3.1"
      ]
    },
    "text": "\n# Segmentation fault due to use of uninitialized memory\nWhen trying to decompress a file using \"ouch\", we can reach the function \"ouch::archive::zip::convert_zip_date_time\".\nIn the function, there is a unsafe function, \"transmute\". Once the \"transmute\" function is called to convert the type of \"month\" object,\nthe address of the object is changed to the uninitialized memory region. \nAfter that, when other function tries to dereference \"month\", segmentation fault occurs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0138",
      "package": "mz-avro",
      "date": "2021-10-14",
      "url": "https://github.com/MaterializeInc/materialize/issues/8669",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-jwh2-vrr9-vcp2"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# Incorrect use of `set_len` allows for un-initialized memory\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` \nimplementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure)\nand also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke\nundefined behavior.\n\nNote: there is only UB in the case where a user provides a struct whose `Read`\nimplementation inspects the buffer passed to `read_exact` before writing to it.\nThis is an unidiomatic (albeit possible) `Read` implementation.\n\nSee https://github.com/MaterializeInc/materialize/issues/8669 for details.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0005",
      "package": "rust-crypto",
      "date": "2016-09-06",
      "informational": "unmaintained",
      "url": "https://github.com/DaGenix/rust-crypto/issues/440"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.2.36"
      ]
    },
    "text": "\n\n# rust-crypto is unmaintained; switch to a modern alternative\n\nThe `rust-crypto` crate has not seen a release or GitHub commit since 2016,\nand its author is unresponsive.\n\n*NOTE: The (old) `rust-crypto` crate (with hyphen) should not be confused with\nsimilarly named (new) [RustCrypto GitHub Org] (without hyphen). The GitHub Org\nis actively maintained.*\n\nWe recommend you switch to one of the following crates instead, depending on\nwhich algorithms you need:\n\n- [dalek-cryptography GitHub Org]:\n  - Key agreement: [`x25519-dalek`]\n  - Signature algorithms: [`ed25519-dalek`]\n- [`ring`]:\n  - AEAD algorithms: AES-GCM, ChaCha20Poly1305\n  - Digest algorithms: SHA-256, SHA-384, SHA-512, SHA-512/256 (legacy: SHA-1)\n  - HMAC\n  - Key agreement: ECDH (P-256, P-384), X25519\n  - Key derivation: HKDF\n  - Password hashing: PBKDF2\n  - Signature algorithms: ECDSA (P-256, P-384), Ed25519, RSA (PKCS#1v1.5, PSS)\n- [RustCrypto GitHub Org]:\n  - AEAD algorithms: [`aes-gcm`], [`aes-gcm-siv`], [`aes-siv`], [`chacha20poly1305`], [`xsalsa20poly1305`]\n  - Block ciphers: [`aes`], [`cast5`], [`des`]\n  - Digest algorithms: [`sha2`], [`sha3`], [`blake2`], [`ripemd160`]\n    (legacy: [`sha-1`], [`md-5`])\n  - Key derivation: [`hkdf`]\n  - MACs: [`cmac`], [`hmac`], [`pmac`], [`poly1305`]\n  - Password hashing: [`pbkdf2`]\n  - Stream ciphers: [`aes-ctr`], [`chacha20`], [`hc-256`], [`salsa20`]\n- [`secp256k1`]:\n  - Key agreement: ECDH (secp256k1 only)\n  - Signature algorithms: ECDSA (secp256k1 only)\n- [`orion`]:\n  - AEAD algorithms: ChaCha20Poly1305 (IETF version), XChaCha20Poly1305\n  - Digest algorithms: SHA-512, BLAKE2b\n  - Key derivation: HKDF\n  - MACs: HMAC, Poly1305\n  - Password hashing: PBKDF2\n  - Stream ciphers: ChaCha20 (IETF version), XChaCha20\n\n[dalek-cryptography GitHub Org]: https://github.com/dalek-cryptography\n[RustCrypto GitHub Org]: https://github.com/RustCrypto\n[`aes`]: https://crates.io/crates/aes\n[`aes-ctr`]: https://crates.io/crates/aes-ctr\n[`aes-gcm`]: https://crates.io/crates/aes-gcm\n[`aes-gcm-siv`]: https://crates.io/crates/aes-gcm-siv\n[`aes-siv`]: https://crates.io/crates/aes-siv\n[`blake2`]: https://crates.io/crates/blake2\n[`cast5`]: https://crates.io/crates/cast5\n[`chacha20`]: https://crates.io/crates/chacha20\n[`chacha20poly1305`]: https://crates.io/crates/chacha20poly1305\n[`cmac`]: https://crates.io/crates/cmac\n[`des`]: https://crates.io/crates/des\n[`ed25519-dalek`]: https://crates.io/crates/ed25519-dalek\n[`hc-256`]: https://crates.io/crates/hc-256\n[`hkdf`]: https://crates.io/crates/hkdf\n[`hmac`]: https://crates.io/crates/hmac\n[`pbkdf2`]: https://crates.io/crates/pbkdf2\n[`pmac`]: https://crates.io/crates/pmac\n[`poly1305`]: https://crates.io/crates/poly1305\n[`ring`]: https://crates.io/crates/ring\n[`ripemd160`]: https://crates.io/crates/ripemd160\n[`salsa20`]: https://crates.io/crates/salsa20\n[`secp256k1`]: https://crates.io/crates/secp256k1\n[`sha-1`]: https://crates.io/crates/sha-1\n[`sha2`]: https://crates.io/crates/sha2\n[`sha3`]: https://crates.io/crates/sha3\n[`x25519-dalek`]: https://crates.io/crates/x25519-dalek\n[`xsalsa20poly1305`]: https://crates.io/crates/xsalsa20poly1305\n[`orion`]: https://crates.io/crates/orion\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0011",
      "package": "rust-crypto",
      "date": "2022-02-28",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "aesni"
      ],
      "aliases": [
        "GHSA-jp3w-3q88-34cf"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Miscomputation when performing AES encryption in rust-crypto\n\nThe following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.\n\nFor these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.\n\n```rust\nuse crypto::{\n    aes, blockmodes, buffer,\n    buffer::{BufferResult, ReadBuffer, WriteBuffer},\n    symmetriccipher,\n};\n\nfn encrypt(\n    key: &[u8],\n    iv: &[u8],\n    data: &str,\n) -> Result<String, symmetriccipher::SymmetricCipherError> {\n    let mut encryptor =\n        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);\n\n    let mut encrypted_data = Vec::<u8>::new();\n    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());\n    let mut buffer = [0; 4096];\n    let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);\n\n    loop {\n        let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true)?;\n\n        encrypted_data.extend(\n            write_buffer\n                .take_read_buffer()\n                .take_remaining()\n                .iter()\n                .copied(),\n        );\n\n        match result {\n            BufferResult::BufferUnderflow => break,\n            BufferResult::BufferOverflow => {}\n        }\n    }\n\n    Ok(hex::encode(encrypted_data))\n}\n\nfn working() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // The copy here makes the code work.\n    let key_copy = key;\n    let key2: Vec<u8> = key_copy.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn broken() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // This operation shouldn't affect the contents of key at all.\n    let key2: Vec<u8> = key.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn main() {\n    working();\n    broken();\n}\n```\n\nThe output from this program:\n\n```shell\n     Running `target/host/debug/rust-crypto-test`\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 90462bbe32965c8e7ea0addbbed4cddb\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 26e847e5e7df1947bf82a650548a7d5b\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `\"26e847e5e7df1947bf82a650548a7d5b\"`,\n right: `\"90462bbe32965c8e7ea0addbbed4cddb\"`', src/main.rs:83:5\n```\n\nNotably, the X1 key in the `broken()` test changes every time after rerunning the program.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0021",
      "package": "linea",
      "aliases": [
        "CVE-2019-16880",
        "GHSA-j52m-489x-v634"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-09-14",
      "keywords": [
        "double free"
      ],
      "url": "https://github.com/strake/linea.rs/issues/2"
    },
    "versions": {
      "patched": [
        "> 0.9.4"
      ]
    },
    "text": "\n\n# `Matrix::zip_elements` causes double free\n\nAffected versions of this crate did not properly implements the `Matrix::zip_elements` method, which causes an double free when the given trait implementation might panic.\n\nThis allows an attacker to corrupt or take control of the memory.\n \nThe flaw was corrected by Phosphorus15.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0082",
      "package": "vec-const",
      "date": "2021-08-14",
      "url": "https://github.com/Eolu/vec-const/issues/1#issuecomment-898908241",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45680",
        "GHSA-jmwx-r3gq-qq3p",
        "GHSA-x76r-966h-5qv9"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# vec-const attempts to construct a Vec from a pointer to a const slice\n\nAffected versions of this crate claimed to construct a const `Vec` with nonzero length and capacity, but that cannot be done because such a `Vec` requires a pointer from an allocator.\n\nThe implementation was later changed to just construct a `std::borrow::Cow`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0139",
      "package": "dces",
      "date": "2020-12-09",
      "url": "https://gitlab.redox-os.org/redox-os/dces-rust/-/issues/8",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36459",
        "GHSA-hxw9-jxqw-jc8j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# dces' World type can cause data races\n\nThe `World` type in `dces` is marked as `Send` without bounds on its\n`EntityStore` and `ComponentStore`.\n\nThis allows non-thread safe `EntityStore` and `ComponentStore`s to be sent\nacross threads and cause data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0067",
      "package": "lzf",
      "date": "2022-10-22",
      "url": "https://github.com/badboy/lzf-rs/issues/9",
      "informational": "unsound",
      "keywords": [
        "uninitialized-memory"
      ],
      "aliases": [
        "GHSA-5m39-wx2q-mxg3"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ]
    },
    "affected": {
      "functions": {
        "lzf::compress": [
          "< 0.3.2"
        ],
        "lzf::decompress": [
          "< 0.3.2"
        ]
      }
    },
    "text": "\n\n#  Invalid use of `mem::uninitialized` causes `use-of-uninitialized-value`\n\nThe compression and decompression function used `mem:uninitialized`\nto create an array of uninitialized values, to later write values into it.\nThis later leads to reads from uninitialized memory.\n\nThe flaw was corrected in commit b633bf265e41c60dfce3be7eac4e4dd5e18d06cf\nby using a heap-allocated `Vec` and removing out use of `mem::uninitialized`.\nThe fix was released in v0.3.2 and v1.0.0\n\nSubsequently the crate was deprecated and its use is discouraged.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0003",
      "package": "rust_sodium",
      "date": "2020-01-20",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/rust_sodium/pull/117"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.10.2"
      ]
    },
    "text": "\n\n# rust_sodium is unmaintained; switch to a modern alternative\n\nThe `rust_sodium` crate is no longer maintained by its current owner, who\nadvise in the repository readme that they are looking for\nsomeone else to take ownership of it.\n\nWe recommend you switch to an alternative crate such as:\n- [`sodiumoxide`](https://crates.io/crates/sodiumoxide)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0015",
      "package": "pty",
      "date": "2022-03-22",
      "informational": "unmaintained",
      "url": "https://github.com/hibariya/pty-rs/issues/19"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# pty is unmaintained\n\nThe repository hasn't received any updates since Jun 25, 2017 and the author is unresponsive.\n\nMaintained alternatives include:\n\n* [`tokio-pty-process`](https://crates.io/crates/tokio-pty-process)\n* [`pty-process`](https://crates.io/crates/pty-process)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0068",
      "package": "iced-x86",
      "date": "2021-05-19",
      "url": "https://github.com/icedland/iced/issues/168",
      "keywords": [
        "soundness"
      ],
      "aliases": [
        "CVE-2021-38188",
        "GHSA-jjx5-3f36-6927"
      ]
    },
    "affected": {
      "functions": {
        "iced_x86::Decoder::new": [
          "<= 1.10.3"
        ]
      }
    },
    "versions": {
      "patched": [
        "> 1.10.3"
      ]
    },
    "text": "\n\n# Soundness issue in `iced-x86` versions <= 1.10.3 \n\nVersions of iced-x86 <= 1.10.3 invoke undefined behavior which may cause soundness\nissues in crates using the `iced_x86::Decoder` struct. The `Decoder::new()` function\nmade a call to `slice.get_unchecked(slice.length())` to get the end position of \nthe input buffer. The flaw was fixed with safe logic that does not invoke undefined\nbehavior.\n\nMore details can be found at <https://github.com/icedland/iced/issues/168>.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0038",
      "package": "ordnung",
      "aliases": [
        "CVE-2020-35890",
        "CVE-2020-35891",
        "GHSA-4wj3-p7hj-cvx8",
        "GHSA-qrwc-jxf5-g8x6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-03",
      "url": "https://github.com/maciejhirsz/ordnung/issues/8"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Memory safety issues in `compact::Vec`\n\n`compact::Vec` contains multiple memory safety issues.\n\n1. It mishandles large capacity and causes out-of-bound access in 32-bit / allocator layout mismatch in 64-bit.\n2. `remove()` is not panic-safe and causes double-free when an index larger than the length is provided.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0028",
      "package": "buf_redux",
      "date": "2023-01-24",
      "url": "https://github.com/abonander/buf_redux/issues",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# buf_redux is Unmaintained\n\nLast release was over three years ago.\n\nThe maintainer(s) have been unreachable to respond to any issues that may or may not include security issues.\n\nThe repository is now archived and there is no security policy in place to contact the maintainer(s) otherwise.\n\nThe safety-undocumented unsafe in the crate may or may not be safe to use.\n\nThe crate also has a current future incompatibility warning [buf_redux/23](https://github.com/abonander/buf_redux/issues/23).\n\n## Possible Alternatives\n\nThe below may or may not provide alternative(s)\n\n- Rust alloc / std vec::Vec, collections::VecDeque\n- [buffer-redux](https://crates.io/crates/buffer-redux) - fork\n- [bytes](https://crates.io/crates/bytes)\n- [crates.io search for 'buffer'](https://crates.io/keywords/buffer)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0051",
      "package": "dlopen_derive",
      "date": "2023-07-30",
      "url": "https://github.com/szymonwieloch/rust-dlopen/issues/47",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `dlopen_derive` is unmaintained\n\n`dlopen_derive` hasn't been updated since June 9, 2019.\n\n`dlopen_derive` depends on [`quote = \"0.6.12\"`] and [`syn = \"0.15.34\"`]. Versions `1.0.0` of these dependencies were published on August 13, 2019. The `0.*` versions haven't received updates since.\n\nNote that `dlopen` is an unmaintained crate from the same repository as `dlopen_derive`. However, migrating away from `dlopen_derive` implies migrating away from `dlopen`, as well.\n\n## Recommended alternatives\n\n- [`dlopen2_derive`] (and `dlopen2`)\n\n[`dlopen2_derive`]: https://github.com/OpenByteDev/dlopen2\n[`quote = \"0.6.12\"`]: https://github.com/dtolnay/quote/releases/tag/0.6.12\n[`syn = \"0.15.34\"`]: https://github.com/dtolnay/syn/releases/tag/0.15.34\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0049",
      "package": "iana-time-zone",
      "date": "2022-08-15",
      "url": "https://github.com/strawlab/iana-time-zone/pull/54",
      "references": [
        "https://github.com/strawlab/iana-time-zone/pull/50#discussion_r945353515"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-3fg9-hcq5-vxrc"
      ]
    },
    "affected": {
      "os": [
        "ios",
        "macos"
      ],
      "functions": {
        "iana_time_zone::get_timezone": [
          "> 0.1.42, < 0.1.45"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.45"
      ],
      "unaffected": [
        "< 0.1.43"
      ]
    },
    "text": "\n\n# Use after free in MacOS / iOS implementation\n\nIn iana-time-zone v0.1.43 a use-after-free bug in the MacOS / iOS implementation was introduced.\n\nThe copied system time zone was released before its name was copied.\nIf the system time zone was changed between the call of `CFRelease` and `str::to_owned()`,\nrandom memory would be copied.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0107",
      "package": "hashconsing",
      "aliases": [
        "CVE-2020-36215",
        "GHSA-rw2c-c256-3r53"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/AdrienChampion/hashconsing/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.0"
      ]
    },
    "text": "\n\n# hashconsing's HConsed lacks Send/Sync bound for its Send/Sync trait.\n\nAffected versions of `hashconsing` implements `Send`/`Sync` for its `HConsed` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0157",
      "package": "vm-memory",
      "date": "2020-06-02",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2020-13759",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "aliases": [
        "CVE-2020-13759",
        "GHSA-mm4m-qg48-f7wc"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1",
        "^0.1.1"
      ]
    },
    "text": "\n\n# Improper Synchronization and Race Condition in vm-memory\n\nrust-vmm vm-memory before 0.1.1 and 0.2.x before 0.2.1 allows attackers to cause a denial of service (loss of IP networking) because read_obj and write_obj do not properly access memory. This affects aarch64 (with musl or glibc) and x86_64 (with musl).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0056",
      "package": "vm-memory",
      "date": "2023-09-01",
      "url": "https://github.com/rust-vmm/vm-memory/issues/250",
      "references": [
        "https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8"
      ],
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:L",
      "aliases": [
        "CVE-2023-41051",
        "GHSA-49hh-fprx-m68g"
      ]
    },
    "affected": {
      "functions": {
        "vm_memory::volatile_memory::VolatileMemory::get_atomic_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::aligned_as_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::aligned_as_mut": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::get_ref": [
          "< 0.12.2"
        ],
        "vm_memory::volatile_memory::VolatileMemory::get_array_ref": [
          "< 0.12.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.12.2"
      ]
    },
    "text": "\n\n# Default functions in VolatileMemory trait lack bounds checks, potentially leading to out-of-bounds memory accesses \n\nAn issue was discovered in the default implementations of the `VolatileMemory::{get_atomic_ref, aligned_as_ref, aligned_as_mut, get_ref, get_array_ref}` trait functions, which allows out-of-bounds memory access if the `VolatileMemory::get_slice` function returns a `VolatileSlice` whose length is less than the function\u2019s `count` argument. No implementations of `get_slice` provided in `vm_memory` are affected. Users of custom `VolatileMemory` implementations may be impacted if the custom implementation does not adhere to `get_slice`'s documentation.\n\nThe issue started in version 0.1.0 but was fixed in version 0.12.2 by inserting a check that verifies that the `VolatileSlice` returned by `get_slice` is of the correct length.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0166",
      "package": "personnummer",
      "date": "2020-09-04",
      "url": "https://github.com/personnummer/rust/pull/4",
      "aliases": [
        "GHSA-28r9-pq4c-wp3c"
      ],
      "informational": "notice"
    },
    "versions": {
      "patched": [
        ">= 3.0.1"
      ]
    },
    "text": "\n# personnummer Input validation error\n\nSwedish personal identity is in the form of YYMMDD-XXXX\n\nAn issue arises from the regular expression allowing the first three digits in\nthe last four digits of the personnummer to be 000, which is invalid.\n\nTo mitigate this without upgrading, a check on the last four digits can be made\nto make sure it's not 000x.\n\nThe affected version should not be relied on without the mitigation to check\nthat the swedish personal identity number is valid.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0007",
      "package": "lz4-compress",
      "date": "2017-04-17",
      "informational": "unmaintained",
      "url": "https://gitlab.redox-os.org/redox-os/tfs/issues/89"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# lz4-compress is unmaintained\n\n[According to the developers](https://gitlab.redox-os.org/redox-os/tfs/issues/89) this crate is no longer maintained.\n\nThe suggested alternative is [`lz4-compression`](https://crates.io/crates/lz4-compression), a maintained fork of `lz4-compress`.\n\nSee also [lz-fear](https://crates.io/crates/lz-fear) which is compatible with the reference LZ4 implementation in C, but not with lz4-compress.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0007",
      "package": "trust-dns-proto",
      "aliases": [
        "CVE-2018-20994",
        "GHSA-369h-pjr2-6wrh"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2018-10-09",
      "keywords": [
        "stack-overflow",
        "crash"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# Stack overflow when parsing malicious DNS packet\n\nThere's a stack overflow leading to a crash when Trust-DNS's parses a\nmalicious DNS packet.\n\nAffected versions of this crate did not properly handle parsing of DNS message\ncompression (RFC1035 section 4.1.4). The parser could be tricked into infinite\nloop when a compression offset pointed back to the same domain name to be\nparsed.\n\nThis allows an attacker to craft a malicious DNS packet which when consumed\nwith Trust-DNS could cause stack overflow and crash the affected software.\n\nThe flaw was corrected by trust-dns-proto 0.4.3 and upcoming 0.5.0 release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0005",
      "package": "pancurses",
      "aliases": [
        "CVE-2019-15546",
        "GHSA-m57c-4vvx-gjgq"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2019-06-15",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    },
    "affected": {
      "functions": {
        "pancurses::mvprintw": [
          ">= 0"
        ],
        "pancurses::printw": [
          ">= 0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Format string vulnerabilities in `pancurses`\n\n`pancurses::mvprintw` and `pancurses::printw` passes a pointer from a rust `&str` to C,\nallowing hostile input to execute a format string attack, which trivially allows writing\narbitrary data to stack memory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0007",
      "package": "qcell",
      "date": "2022-01-24",
      "url": "https://github.com/uazu/qcell/issues/20",
      "informational": "unsound",
      "keywords": [
        "unsound"
      ],
      "aliases": [
        "GHSA-9c9f-7x9p-4wqp"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# A malicious coder can get unsound access to TCell or TLCell memory\n\nThis is impossible to do by accident, but by carefully constructing\nmarker types to be covariant, a malicious coder can cheat the\nsingleton check in `TCellOwner` and `TLCellOwner`, giving unsound\naccess to cell memory.  This could take the form of getting two\nmutable references to the same memory, or a mutable reference and an\nimmutable reference.\n\nThe fix is for the crate to internally force the marker type to be\ninvariant.  This blocks the conversion between covariant types which\nRust normally allows.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0034",
      "package": "h2",
      "date": "2023-04-14",
      "url": "https://github.com/hyperium/hyper/issues/2877",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "http",
        "http2",
        "h2"
      ],
      "aliases": [
        "CVE-2023-26964",
        "GHSA-f8vr-r385-rh5r"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.17"
      ]
    },
    "text": "\n\n# Resource exhaustion vulnerability in h2 may lead to Denial of Service (DoS)\n\nIf an attacker is able to flood the network with pairs of `HEADERS`/`RST_STREAM` frames, such that the `h2` application is not able to accept them faster than the bytes are received, the pending accept queue can grow in memory usage. Being able to do this consistently can result in excessive memory use, and eventually trigger Out Of Memory.\n\nThis flaw is corrected in [hyperium/h2#668](https://github.com/hyperium/h2/pull/668), which restricts remote reset stream count by default.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0003",
      "package": "h2",
      "date": "2024-01-17",
      "references": [
        "https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "http",
        "http2",
        "h2"
      ],
      "related": [
        "CVE-2019-9514"
      ],
      "aliases": [
        "GHSA-8r5v-vm4m-4g25"
      ]
    },
    "versions": {
      "patched": [
        "^0.3.24",
        ">= 0.4.2"
      ]
    },
    "text": "\n\n# Resource exhaustion vulnerability in h2 may lead to Denial of Service (DoS)\n\nAn attacker with an HTTP/2 connection to an affected endpoint can send a steady stream of invalid frames to force the\ngeneration of reset frames on the victim endpoint.\nBy closing their recv window, the attacker could then force these resets to be queued in an unbounded fashion,\nresulting in Out Of Memory (OOM) and high CPU usage.\n\nThis fix is corrected in [hyperium/h2#737](https://github.com/hyperium/h2/pull/737), which limits the total number of\ninternal error resets emitted by default before the connection is closed.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0332",
      "package": "h2",
      "date": "2024-04-03",
      "references": [
        "https://seanmonstar.com/blog/hyper-http2-continuation-flood/"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "http",
        "http2",
        "h2"
      ],
      "aliases": [
        "GHSA-q6cp-qfwq-4gcv"
      ]
    },
    "versions": {
      "patched": [
        "^0.3.26",
        ">= 0.4.4"
      ]
    },
    "text": "\n\n# Degradation of service in h2 servers with CONTINUATION Flood\n\nAn attacker can send a flood of CONTINUATION frames, causing `h2` to process them indefinitely.\nThis results in an increase in CPU usage.\n\nTokio task budget helps prevent this from a complete denial-of-service, as the server can still\nrespond to legitimate requests, albeit with increased latency.\n\nMore details at \"https://seanmonstar.com/blog/hyper-http2-continuation-flood/.\n\nPatches available for 0.4.x and 0.3.x versions.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0131",
      "package": "rcu_cell",
      "date": "2020-11-14",
      "url": "https://github.com/Xudong-Huang/rcu_cell/issues/3",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36451",
        "GHSA-686h-j8r8-wmfm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Send/Sync bound needed on T  for Send/Sync impl of RcuCell<T>\n\nAffected versions of this crate unconditionally implement Send/Sync for `RcuCell<T>`.\nThis allows users to send `T: !Send` to other threads (while `T` enclosed within `RcuCell<T>`), and allows users to concurrently access `T: !Sync` by using the APIs of `RcuCell<T>` that provide access to `&T`.\n\nThis can result in memory corruption caused by data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0064",
      "package": "cpuid-bool",
      "date": "2021-05-06",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/utils/pull/381"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `cpuid-bool` has been renamed to `cpufeatures`\n\nPlease use the `cpufeatures`` crate going forward:\n\n<https://github.com/RustCrypto/utils/tree/master/cpufeatures>\n\nThere will be no further releases of `cpuid-bool`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0014",
      "package": "image",
      "aliases": [
        "CVE-2019-16138",
        "GHSA-m2pf-hprp-3vqm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-08-21",
      "keywords": [
        "drop",
        "use-after-free"
      ],
      "url": "https://github.com/image-rs/image/pull/985"
    },
    "affected": {
      "functions": {
        "image::hdr::HDRDecoder::read_image_transform": [
          "< 0.21.3, >= 0.10.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.21.3"
      ],
      "unaffected": [
        "< 0.10.2"
      ]
    },
    "text": "\n\n# Flaw in interface may drop uninitialized instance of arbitrary types\n\nAffected versions of this crate would call `Vec::set_len` on an uninitialized\nvector with user-provided type parameter, in an interface of the HDR image\nformat decoder. They would then also call other code that could panic before\ninitializing all instances.\n\nThis could run Drop implementations on uninitialized types, equivalent to\nuse-after-free, and allow an attacker arbitrary code execution.\n\nTwo different fixes were applied. It is possible to conserve the interface by\nensuring proper initialization before calling `Vec::set_len`. Drop is no longer\ncalled in case of panic, though.\n\nStarting from version `0.22`, a breaking change to the interface requires\ncallers to pre-allocate the output buffer and pass a mutable slice instead,\navoiding all unsafe code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0073",
      "package": "image",
      "aliases": [
        "CVE-2020-35916",
        "GHSA-9wgh-vjj7-7433"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-12",
      "url": "https://github.com/image-rs/image/issues/1357",
      "informational": "unsound",
      "keywords": [
        "pointer",
        "cast",
        "provenance"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.23.12"
      ]
    },
    "affected": {
      "functions": {
        "image::Bgr::from_slice_mut": [
          "< 0.23.12"
        ],
        "image::Bgra::from_slice_mut": [
          "< 0.23.12"
        ],
        "image::Luma::from_slice_mut": [
          "< 0.23.12"
        ],
        "image::LumaA::from_slice_mut": [
          "< 0.23.12"
        ],
        "image::Rgb::from_slice_mut": [
          "< 0.23.12"
        ],
        "image::Rgba::from_slice_mut": [
          "< 0.23.12"
        ]
      }
    },
    "text": "\n\n# Mutable reference with immutable provenance\n\nA mutable reference to a struct was constructed by dereferencing a pointer\nobtained from `slice::as_ptr`. Instead, `slice::as_mut_ptr` should have been\ncalled on the mutable slice argument. The former performs an implicit reborrow\nas an immutable shared reference which does not allow writing through the\nderived pointer.\n\nThere is no evidence for miscompilation, exploitable or otherwise, caused by\nthis bug. [Further investigation on Zulip][Zulip] suggests that the unoptimized\ngenerated LLVM IR does not contain any UB itself, effectively mitigating\nfurther effects.\n\n[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/146229-wg-secure-code/topic/Implications.20of.20using.20.60slice.3A.3Aas_ptr.60.20for.20mutable.20access/near/216499472\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0039",
      "package": "buffered-reader",
      "date": "2023-05-16",
      "url": "https://lists.sequoia-pgp.org/hyperkitty/list/announce@lists.sequoia-pgp.org/thread/SN2E3QRT4DMQ5JNEK6VIN6DJ5SH766DI/",
      "references": [
        "https://gitlab.com/sequoia-pgp/sequoia/-/tags/buffered-reader%2Fv1.2.0"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "panic"
      ],
      "aliases": [
        "GHSA-29mf-62xx-28jq"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.2, < 1.1.0",
        ">= 1.1.5, < 1.2.0",
        ">= 1.2.0"
      ]
    },
    "text": "\n\n# Out-of-bounds array access leads to panic\n\nAffected versions of the crate have a bug where attacker-controlled\ninput can result in the use of an out-of-bound array index.  Rust\ndetects the use of the out-of-bound index and causes the application\nto panic.  An attacker may be able to use this to cause a\ndenial-of-service.  However, it is not possible for an attacker to\nread from or write to the application's address space.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0047",
      "package": "lmdb-rs",
      "date": "2023-06-26",
      "informational": "unsound",
      "url": "https://github.com/vhbit/lmdb-rs/issues/67",
      "keywords": [
        "unsound"
      ],
      "aliases": [
        "GHSA-f9g6-fp84-fv92"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# impl `FromMdbValue` for bool is unsound\nThe implementation of `FromMdbValue` have several unsoundness issues. First of all, it allows to reinterpret arbitrary bytes as a bool and could make undefined behavior happen with safe function. Secondly, it allows transmuting pointer without taking memory layout into consideration. The details of reproducing the bug were included in url above.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0029",
      "package": "nats",
      "date": "2023-03-24",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "tls",
        "mitm"
      ],
      "aliases": [
        "GHSA-wvc4-j7g5-4f79"
      ]
    },
    "versions": {
      "patched": [
        ">=0.24.1"
      ],
      "unaffected": [
        "< 0.9.0"
      ]
    },
    "text": "\n\n# TLS certificate common name validation bypass\n\nThe NATS official Rust clients are vulnerable to MitM when using TLS.\n\nThe common name of the server's TLS certificate is validated against\nthe `host`name provided by the server's plaintext `INFO` message\nduring the initial connection setup phase. A MitM proxy can tamper with\nthe `host` field's value by substituting it with the common name of a\nvalid certificate it controls, fooling the client into accepting it.\n\n## Reproduction steps\n\n1. The NATS Rust client tries to establish a new connection\n2. The connection is intercepted by a MitM proxy\n3. The proxy makes a separate connection to the NATS server\n4. The NATS server replies with an `INFO` message\n5. The proxy reads the `INFO`, alters the `host` JSON field and passes\n   the tampered `INFO` back to the client\n6. The proxy upgrades the client connection to TLS, presenting a certificate issued\n   by a certificate authority present in the client's keychain.\n   In the previous step the `host` was set to the common name of said certificate\n7. `rustls` accepts the certificate, having verified that the common name matches the\n   attacker-controlled value it was given\n9. The client has been fooled by the MitM proxy into accepting the attacker-controlled certificate\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0055",
      "package": "axum-core",
      "date": "2022-08-31",
      "url": "https://github.com/tokio-rs/axum/pull/1346",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "ddos",
        "oom"
      ],
      "aliases": [
        "CVE-2022-3212",
        "GHSA-m77f-652q-wwp4"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.8, < 0.3.0-rc.1",
        ">= 0.3.0-rc.2"
      ]
    },
    "text": "\n\n# No default limit put on request bodies\n\n`<bytes::Bytes as axum_core::extract::FromRequest>::from_request` would not, by\ndefault, set a limit for the size of the request body. That meant if a malicious\npeer would send a very large (or infinite) body your server might run out of\nmemory and crash.\n\nThis also applies to these extractors which used `Bytes::from_request`\ninternally:\n- `axum::extract::Form`\n- `axum::extract::Json`\n- `String`\n\nThe fix is also in `axum-core` `0.3.0.rc.2` but `0.3.0.rc.1` _is_ vulnerable.\n\nBecause `axum` depends on `axum-core` it is vulnerable as well. The vulnerable\nversions of `axum` are `<= 0.5.15` and `0.6.0.rc.1`. `axum` `>= 0.5.16` and\n`>= 0.6.0.rc.2` does have the fix and are not vulnerable.\n\nThe patched versions will set a 2 MB limit by default.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0010",
      "package": "libflate",
      "aliases": [
        "CVE-2019-15552",
        "GHSA-rpcm-whqc-jfw8"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-07-04",
      "keywords": [
        "drop",
        "use-after-free"
      ],
      "url": "https://github.com/sile/libflate/issues/35"
    },
    "affected": {
      "functions": {
        "libflate::gzip::MultiDecoder::read": [
          "< 0.1.25, >= 0.1.14"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.25"
      ],
      "unaffected": [
        "< 0.1.14"
      ]
    },
    "text": "\n\n# MultiDecoder::read() drops uninitialized memory of arbitrary type on panic in client code\n\nAffected versions of libflate have set a field of an internal structure with a generic type to an uninitialized value in `MultiDecoder::read()` and reverted it to the original value after the function completed. However, execution of `MultiDecoder::read()` could be interrupted by a panic in caller-supplied `Read` implementation. This would cause `drop()` to be called on uninitialized memory of a generic type implementing `Read`.\n\nThis is equivalent to a use-after-free vulnerability and could allow an attacker to gain arbitrary code execution.\n\nThe flaw was corrected by aborting immediately instead of unwinding the stack in case of panic within `MultiDecoder::read()`. The issue was discovered and fixed by Shnatsel.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0090",
      "package": "thex",
      "aliases": [
        "CVE-2020-35927",
        "GHSA-j42v-6wpm-r847"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-08",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Thex<T> allows data races of non-Send types across threads\n\n`thex::Thex<T>` implements `Sync` for all types `T`. However, it is missing a\nbound for `T: Send`.\n\nThis allows non-Send types such as `Rc` to be sent across thread boundaries\nwhich can trigger undefined behavior and memory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0016",
      "package": "quickersort",
      "date": "2018-06-30",
      "informational": "unmaintained",
      "url": "https://github.com/notriddle/quickersort/commit/0bc164366315801f0c6b31f4081b7df9fc894076"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 3.0.1"
      ]
    },
    "text": "\n\n# quickersort is deprecated and unmaintained\n\nThe author of the `quickersort` crate has deprecated it and does not recommend using it anymore.\n\nEverything in it has been incorporated into [std::sort_unstable] in the standard library as of Rust 1.20.\n\n[std::sort_unstable]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.sort_unstable\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0353",
      "package": "gix-worktree",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-49jc-r788-3fc9",
      "references": [
        "https://github.com/advisories/GHSA-49jc-r788-3fc9",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35197"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L",
      "aliases": [
        "CVE-2024-35197",
        "GHSA-49jc-r788-3fc9"
      ],
      "license": "CC0-1.0"
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.34.0"
      ]
    },
    "text": "\n\n# Refs and paths with reserved Windows device names access the devices\n\n### Summary\n\nOn Windows, fetching refs that clash with legacy device names reads from the devices, and checking out paths that clash with such names writes arbitrary data to the devices. This allows a repository, when cloned, to cause indefinite blocking or the production of arbitrary message that appear to have come from the application, and potentially other harmful effects under limited circumstances.\n\n### Details\n\nIt is possible to create a Git repository that contains references or filenames that Windows treats as legacy DOS-style aliases for system devices. When such a repository is cloned:\n\n- In references, `gix-ref` does not include a check for such names before attempting to access them on disk, which reads from the devices, though the ability to exfiltrate data appears limited.\n- In paths, `gix-worktree-state` does not treat such names as collisions and instead writes to them, which writes arbitrary attacker-controlled data to the devices.\n\nSome such device names refer to devices that are often absent or inaccessible. But a few are guaranteed to be available, allowing some attacks to be carried out with low complexity. For both reading refs and writing paths, one important case is the console:\n\n- Reading a ref whose last component (e.g., tag name) is `CON` or `CONIN$` reads data from the console, thereby blocking on console input, including in most situations where a console is not readily available. This may facilitate denial of service attacks.\n- Checking out a file named `CON` or `CONOUT$` writes its contents to the console. This allows an untrusted repository to produce arbitrary text that appears to be a message from the application. Such text may facilitate social engineering if it is selected to instruct the user to perform a particular action.\n\nAnother potentially important case is serial ports. For example, `COM1` refers to the first serial port, if present. A malicious repository may be able to disrupt intended use of serial ports or attempt to interact with a device. In some configurations, it may be possible to interfere with the operation of a physical or virtual serial console. On Windows, local access to serial ports is often permitted even for limited user accounts without elevation.\n\n[Naming Files, Paths, and Namespaces](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions) covers most reserved names. `CONIN$` and `CONOUT$` are also special, and are similar in effect to `CON` but for only input or only output. These names are case-insensitive and can also be accessed with file extensions (e.g, `CON.txt` is equivalent to `CON`) and with some variations involving added spaces or colons.\n\n### PoC\n\n#### Ref example\n\nCreate a repository on a non-Windows system (or in WSL) with at least one commit. Use `git tag CON` to create a lightweight tag named `CON`. Place the repository somewhere it can be cloned on Windows. A `file://` URL is sufficient for testing if a private remote is unavailable. If using `git push`, pass `--tags` so the remote has the tag.\n\nOn a Windows system, clone the repository with `gix clone`. This command will block immediately, reading input from the console. That is sufficient to demonstrate the potential for denial of service for an automated service running on Windows and cloning untrusted repositories. The experiment can be stopped with <kbd>Ctrl</kbd>+<kbd>C</kbd>.\n\nHowever, if desired, input can be provided. Ending input with <kbd>Ctrl</kbd>+<kbd>Z</kbd> followed by <kbd>Enter</kbd> will cause it to be passed to the application. This will lead to an error message, the specific details of which vary by whether the input is empty or nonempty, and whether it matches or does not match the hexadecimal hash of the tagged commit.\n\n#### Path example\n\nCreate a repository on a non-Windows system (or in WSL) and commit a file named `CON` with the contents:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n```\n\nWhile that example text serves to illustrate the risk, any distinctive text is sufficient to observe the vulnerability. Place the repository somewhere it can be cloned on Windows. As above, a `file://` URL is sufficient.\n\nOn a Windows system, clone the repository with `gix clone`. The output usually looks like this, with the deceptive message appearing to come from `gix`:\n\n```text\nwarning: data loss imminent; you should run EVIL_COMMAND to back up your work!\n 04:45:15 indexing done 3.0 objects in 0.00s (12.1K objects/s)\n 04:45:15 decompressing done 309B in 0.00s (1.2MB/s)\n 04:45:15     Resolving done 3.0 objects in 0.05s (58.0 objects/s)\n 04:45:15      Decoding done 309B in 0.05s (6.0KB/s)\n 04:45:15 writing index file done 1.2KB in 0.00s (7.0MB/s)\n 04:45:15  create index file done 3.0 objects in 0.05s (55.0 objects/s)\n 04:45:15          read pack done 294B in 0.05s (5.4KB/s)\nError: IO error while writing blob or reading file metadata or changing filetype\n\nCaused by:\n    Incorrect function. (os error 1)\n```\n\nThe exact placement of the message is nondeterministic. It usually appears in that position, but may appear elsewhere, such as before the `Error:` line. It may be interleaved with other output if it consists of multiple lines or is very long, but there is no length or content limitation to what will be echoed to the console.\n\n### Impact\n\nIf Windows is not used, or untrusted repositories are not cloned or otherwise used, then there is no impact.\n\nThe impact is expected to be limited in common configurations, but may vary widely depending on what devices exist, how they are being used, how much knowledge an attacker has of the precise details of their use, and whether the user is likely to trust information that appears in a console. Accessing devices through refs is expected to be less dangerous than accessing them through filenames, since it is trivial to attempt to write arbitrary data using filenames.\n\nFor attacks using the `CON` or `CONOUT$` device names, the greatest risk is if a command the user would not otherwise run, and would not be convinced to run by untrusted instructions, seems reasonable when a trusted application such as `gix` appears to recommend it. The user may then be misled into running an attacker's command.\n\nA minor degradation in availability may also be possible, such as with a very large file named `CON`, though the user could usually interrupt the application.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0349",
      "package": "gix-worktree",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-7w47-3wg8-547c",
      "references": [
        "https://github.com/advisories/GHSA-7w47-3wg8-547c",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35186"
      ],
      "categories": [
        "code-execution"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
      "keywords": [
        "directory-traversal"
      ],
      "aliases": [
        "CVE-2024-35186",
        "GHSA-7w47-3wg8-547c"
      ],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": [
        ">= 0.34.0"
      ]
    },
    "text": "\n\n# Traversal outside working tree enables arbitrary code execution\n\n### Summary\n\nDuring checkout, gitoxide does not verify that paths point to locations in the working tree. A specially crafted repository can, when cloned, place new files anywhere writable by the application.\n\n### Details\n\nAlthough `gix-worktree-state` checks for collisions with existing files, it does not itself check if a path is really in the working tree when performing a checkout, nor do the path checks in `gix-fs` and `gix-worktree` prevent this. Cloning an untrusted repository containing specially crafted tree or blob names will create new files outside the repository, or inside the repository or a submodule's `.git` directory. The simplest cases are:\n\n- A tree named `..` to traverse upward. This facilitates arbitrary code execution because files can be placed in one or more locations where they are likely to be executed soon.\n- A tree named `.git` to enter a `.git` directory. This facilitates arbitrary code execution because hooks can be installed.\n\nA number of alternatives that achieve the same effect are also possible, some of which correspond to specific vulnerabilities that have affected Git in the past:\n\n- A tree or blob whose name contains one or more `/`, to traverse upward or downward. For example, even without containing any tree named `..` or `.git`, a repository can represent a file named `../outside` or `.git/hooks/pre-commit`. This is distinct from the more intuitive case a repository containing trees that represent those paths.\n- In Windows, a tree or blob whose name contains one or more `\\`, to traverse upward or downward. (Unlike `/`, these are valid on other systems.) See [GHSA-xjx4-8694-q2fq](https://github.com/git/git/security/advisories/GHSA-xjx4-8694-q2fq).\n- On a case-insensitive filesystem (such as NTFS, APFS, or HFS+), a tree named as a case variant of `.git`.\n- On HFS+, a tree named like `.git` or a case variant, with characters added that HFS+ ignores [in collation](https://developer.apple.com/library/archive/technotes/tn/tn1150.html#StringComparisonAlgorithm). See https://github.com/git/git/commit/6162a1d323d24fd8cbbb1a6145a91fb849b2568f.\n- On NTFS, a tree equivalent to `.git` (or a case variant) by the use of [NTFS stream](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c54dec26-1551-4d3a-a0ea-4fa40f848eb3) notation, such as `.git::$INDEX_ALLOCATION`. See [GHSA-5wph-8frv-58vj](https://github.com/git/git/security/advisories/GHSA-5wph-8frv-58vj).\n- On an NTFS volume with [8.3 aliasing](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#short-vs-long-names) enabled, a tree named as `git~1` (or a case variant). See [GHSA-589j-mmg9-733v](https://github.com/git/git/security/advisories/GHSA-589j-mmg9-733v).\n\nWhen a checkout creates some files outside the repository directory but fails to complete, the repository directory is usually removed, but the outside files remain.\n\n### PoC\n\nFor simplicity, these examples stage a stand-in file with a valid name, modify the index, and commit. The instructions assume `sed` supports `-i`, which is the case on most systems. If using Windows, a Git Bash shell should be used.\n\n#### Example: Downward traversal to install hooks\n\n1. Create a new repository with `git init dangerous-repo-installs-hook` and `cd` into the directory.\n2. Create the stand-in called `.git@hooks@pre-commit`, with the *contents*:\n   ```sh\n   #!/bin/sh\n   printf 'Vulnerable!\\n'\n   date >vulnerable\n   ```\n3. Stage the stand-in: `git add --chmod=+x .git@hooks@pre-commit`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.git@hooks@pre-commit|.git/hooks/pre-commit|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, on another or the same machine:\n\n1. Clone the repository with a `gix clone \u2026` command.\n2. Enter the newly created directory.\n3. *Optionally* run `ls -l .git/hooks` to observe that the `pre-commit` hook is already present.\n4. Make a new file and commit it with `git`. This causes the payload surreptitiously installed as a `pre-commit` hook to run, printing the message `Vulnerable!` and creating a file in the current directory containing the current date and time.\n\nNote that the effect is not limited to modifying the current directory. The payload could be written to perform any action that the user who runs `git commit` is capable of.\n\n#### Example: Upward traversal to create a file above the working tree\n\n1. Create a new repository with `git init dangerous-repo-reaches-up`, and `cd` into the directory.\n2. Create the stand-in: `echo 'A file outside the working tree, somehow.' >..@outside`\n3. Stage the stand-in: `git add ..@outside`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.\\.@outside|../outside|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, as above, on the same or another machine, clone the repository with a `gix clone \u2026` command. Observe that a file named `outside` is present alongside (not inside) the cloned directory.\n\n### Impact\n\nAny use of `gix` or another application that makes use of `gix-worktree-state`, or otherwise relies on `gix-fs` and `gix-worktree` for validation, is affected, if used to clone untrusted repositories. The above description focuses on code execution, as that leads to a complete loss of confidentiality, integrity, and availability, but creating files outside a working tree without attempting to execute code can directly impact integrity as well.\n\nIn use cases where no untrusted repository is ever cloned, this vulnerability has no impact. Furthermore, the impact of this vulnerability *may* be lower when `gix` is used to clone a repository for CI/CD purposes, even if untrusted, since in such uses the environment is usually isolated and arbitrary code is usually run deliberately from the repository with necessary safeguards in place.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0014",
      "package": "generational-arena",
      "date": "2024-02-11",
      "url": "https://github.com/fitzgen/generational-arena/issues/55",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `generational-arena` is unmaintained\nThe `generational-arena` crate's repository has been archived and is no longer maintained.\n\n## Alternatives\n - [slotmap](https://crates.io/crates/slotmap)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0005",
      "package": "threadalone",
      "date": "2024-01-07",
      "url": "https://github.com/cr0sh/threadalone/issues/1",
      "informational": "unsound",
      "aliases": [
        "GHSA-w59h-378f-2frm"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# Unsound sending of non-Send types across threads\n\nAffected versions can run the `Drop` impl of a non-Send type on a different\nthread than it was created on.\n\nThe flaw occurs when a stderr write performed by the `threadalone` crate fails,\nfor example because stderr is redirected to a location on a filesystem that is\nfull, or because stderr is a pipe that has been closed by the reader.\n\nDropping a non-Send type on the wrong thread is unsound. If used with a type\nsuch as a pthread-based `MutexGuard`, [the consequence is undefined\nbehavior][mutexguard]. If used with `Rc`, there would be a data race on the\nreference count, which is likewise undefined behavior.\n\n[mutexguard]: https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0012",
      "package": "cdr",
      "aliases": [
        "CVE-2021-26305",
        "GHSA-37jj-wp7g-7wj4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-02",
      "url": "https://github.com/hrektts/cdr-rs/issues/10",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.4"
      ]
    },
    "text": "\n\n# Reading uninitialized memory can cause UB (`Deserializer::read_vec`)\n\n`Deserializer::read_vec()` created an uninitialized buffer and passes it to a user-provided `Read` implementation (`Deserializer.reader.read_exact()`).\n\nPassing an uninitialized buffer to an arbitrary `Read` implementation is currently defined as undefined behavior in Rust. Official documentation for the `Read` trait explains the following: \"It is your responsibility to make sure that buf is initialized before calling read. Calling read with an uninitialized buf (of the kind one obtains via MaybeUninit<T>) is not safe, and can lead to undefined behavior.\"\n\nThe flaw was corrected in commit ce310f7 by zero-initializing the newly allocated buffer before handing it to `Deserializer.reader.read_exact()`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0020",
      "package": "const-cstr",
      "date": "2023-03-12",
      "url": "https://github.com/abonander/const-cstr",
      "informational": "unsound"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# const-cstr is Unmaintained\n\nLast release was about five years ago.\n\nThe maintainer(s) have been unreachable to respond to any issues that may or may not include security issues.\n\nThe repository is now archived and there is no security policy in place to contact the maintainer(s) otherwise.\n\nNo direct fork exist.\n\n# const-cstr is Unsound\n\nThe crate violates the safety contract of [ffi::CStr::from_bytes_with_nul_unchecked](https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked) used in `ConstCStr::as_cstr`\n\nNo interior nul bytes checking is done either by the constructor or the canonical macro to create the `ConstCStr`\n\n# const-cstr Panic\n\nAdditionally the crate may cause runtime panics if statically compiled and ran with any untrusted data that is not nul-terminated.\n\nThis is however unlikely but the the crate should not be used for untrusted data in context where panic may create a DoS vector.\n\n## Possible Alternatives\n\nThe below may or may not provide alternative(s)\n\n- [const_str::cstr!](https://docs.rs/const-str/latest/const_str/macro.cstr.html)\n- [cstr::cstr!](https://crates.io/crates/cstr)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0086",
      "package": "safe_core",
      "date": "2020-12-07",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_client`\n\nThis crate has been renamed from `safe_core` to `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0092",
      "package": "rmp-serde",
      "date": "2022-04-13",
      "url": "https://github.com/3Hren/msgpack-rust/issues/305",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-255r-3prx-mf99"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.1"
      ]
    },
    "text": "\n\n# `rmp-serde` `Raw` and `RawRef` unsound\n\nIt was found that `Raw::from_utf8` expects valid UTF-8. If invalid UTF-8 is received it can cause the process to crash.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0024",
      "package": "tough",
      "date": "2020-07-09",
      "aliases": [
        "CVE-2020-15093",
        "GHSA-5q2r-92f9-4m49"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
      "related": [
        "CVE-2020-6174"
      ],
      "url": "https://github.com/awslabs/tough/security/advisories/GHSA-5q2r-92f9-4m49"
    },
    "versions": {
      "patched": [
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# Improper uniqueness verification of signature threshold\n\nThe tough library, prior to 0.7.1, does not properly verify the uniqueness of\nkeys in the signatures provided to meet the threshold of cryptographic\nsignatures. It allows someone with access to a valid signing key to create\nmultiple valid signatures in order to circumvent TUF requiring a minimum\nthreshold of unique keys before the metadata is considered valid.\n\nAWS would like to thank Erick Tryzelaar of the Google Fuchsia Team for\nreporting this issue.\n\nA fix is available in version 0.7.1.\n\nCVE-2020-6174 is assigned to the same issue in the TUF reference\nimplementation.\n\nIf you have any questions or comments about this advisory, contact AWS Security\nat aws-security@amazon.com.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0093",
      "package": "ed25519-dalek",
      "date": "2022-06-11",
      "categories": [
        "crypto-failure"
      ],
      "url": "https://github.com/MystenLabs/ed25519-unsafe-libs",
      "aliases": [
        "GHSA-w5vr-6qhr-36cc"
      ]
    },
    "versions": {
      "patched": [
        ">= 2"
      ]
    },
    "text": "\n\n# Double Public Key Signing Function Oracle Attack on `ed25519-dalek`\n\nVersions of `ed25519-dalek` prior to v2.0 model private and public keys as\nseparate types which can be assembled into a `Keypair`, and also provide APIs\nfor serializing and deserializing 64-byte private/public keypairs.\n\nSuch APIs and serializations are inherently unsafe as the public key is one of\nthe inputs used in the deterministic computation of the `S` part of the signature,\nbut not in the `R` value. An adversary could somehow use the signing function as\nan oracle that allows arbitrary public keys as input can obtain two signatures\nfor the same message sharing the same `R` and only differ on the `S` part.\n\nUnfortunately, when this happens, one can easily extract the private key.\n\nRevised public APIs in v2.0 of `ed25519-dalek` do NOT allow a decoupled\nprivate/public keypair as signing input, except as part of specially labeled\n\"hazmat\" APIs which are clearly labeled as being dangerous if misused.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0101",
      "package": "conquer-once",
      "aliases": [
        "CVE-2020-36208",
        "GHSA-3jc5-5hc5-33gj"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-22",
      "url": "https://github.com/oliver-giersch/conquer-once/issues/3",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ],
      "unaffected": []
    },
    "text": "\n\n# conquer-once's OnceCell lacks Send bound for its Sync trait.\n\nAffected versions of `conquer-once` implements `Sync` for its `OnceCell` type\nwithout restricting it to `Send`able types.\n\nThis allows non-`Send` but `Sync` types such as `MutexGuard` to be sent across\nthreads leading to undefined behavior and memory corruption in concurrent\nprograms.\n\nThe issue was fixed by adding a `Send` constraint to `OnceCell`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0008",
      "package": "bra",
      "aliases": [
        "CVE-2021-25905",
        "GHSA-j8qq-58cr-8cc7"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "date": "2021-01-02",
      "url": "https://github.com/Enet4/bra-rs/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.1"
      ]
    },
    "text": "\n\n# reading on uninitialized buffer can cause UB (`impl<R> BufRead for GreedyAccessReader<R>`)\n\nAffected versions of this crate creates an uninitialized buffer and passes it to user-provided `Read` implementation.\n\nThis is unsound, because it allows safe Rust code to exhibit an undefined behavior (read from uninitialized memory).\n\nThe flaw was corrected in version 0.1.1 by zero-initializing a newly allocated buffer\nbefore handing it to a user-provided `Read` implementation. \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0085",
      "package": "safe_vault",
      "date": "2020-12-07",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_node/pull/1116"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_node`\n\nThis crate has been renamed from `safe_vault` to `sn_node`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_node>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0004",
      "package": "rustc-serialize",
      "date": "2022-01-01",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "stack overflow"
      ],
      "aliases": [
        "GHSA-2226-4v3c-cff8"
      ]
    },
    "versions": {
      "patched": []
    },
    "affected": {
      "functions": {
        "rustc_serialize::json::Json::from_str": [
          "*"
        ]
      }
    },
    "text": "\n\n# Stack overflow in rustc_serialize when parsing deeply nested JSON\n\nWhen parsing JSON using `json::Json::from_str`, there is no limit to the depth of the stack, therefore deeply nested objects can cause a stack overflow, which aborts the process.\n\nExample code that triggers the vulnerability is\n\n```rust\nfn main() {\n    let _ = rustc_serialize::json::Json::from_str(&\"[0,[\".repeat(10000));\n}\n```\n\n[serde](https://crates.io/crates/serde) is recommended as a replacement to rustc_serialize.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0333",
      "package": "rsa-export",
      "date": "2024-04-06",
      "references": [
        "https://crates.io/crates/rsa-export/0.3.3",
        "https://gitlab.com/smallglitch/rsa-export/-/commit/e29f17170d655a6f62eca8bf1f64ef0ce5807058"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `rsa-export` is unmaintained\n\nThis crate has been deprecated in favour of using the native support for exporting RSA keys into the standard PEM format.  \nSee [docs.rs documentation].\n\nIn addition to that, the operations in this crate (arithmetic and Base64 encoding) are not done in constant-time, \npotentially [exposing the user to sidechannel attacks].\n\n[docs.rs documentation]: https://docs.rs/rsa/0.9.6/rsa/index.html#pkcs8-rsa-key-encoding\n[exposing the user to sidechannel attacks]: https://arxiv.org/pdf/2108.04600.pdf\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0132",
      "package": "array-tools",
      "date": "2020-12-31",
      "url": "https://github.com/L117/array-tools/issues/2",
      "categories": [
        "memory-corruption"
      ],
      "aliases": [
        "CVE-2020-36452",
        "GHSA-6wp2-fw3v-mfmc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.2"
      ]
    },
    "text": "\n\n# `FixedCapacityDequeLike::clone()` can cause dropping uninitialized memory\n\nAffected versions of this crate don't guard against panics, so that partially uninitialized buffer is dropped when user-provided `T::clone()` panics in `FixedCapacityDequeLike<T, A>::clone()`. This causes memory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0128",
      "package": "rusqlite",
      "date": "2021-12-07",
      "url": "https://github.com/rusqlite/rusqlite/issues/1048",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free",
        "incorrect-lifetime"
      ],
      "aliases": [
        "CVE-2021-45713",
        "CVE-2021-45714",
        "CVE-2021-45715",
        "CVE-2021-45716",
        "CVE-2021-45717",
        "CVE-2021-45718",
        "CVE-2021-45719",
        "GHSA-4qr3-m7ww-hh9g",
        "GHSA-87xh-9q6h-r5cc",
        "GHSA-92cx-4xm7-jr9m",
        "GHSA-cm8g-544f-p9x9",
        "GHSA-f6f2-3w33-54r9",
        "GHSA-g4g4-3pqw-8m7f",
        "GHSA-g87r-23vw-7f87",
        "GHSA-q89g-4vhh-mvvm"
      ]
    },
    "affected": {
      "functions": {
        "rusqlite::Connection::create_scalar_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_aggregate_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_window_function": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::create_collation": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::commit_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::rollback_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ],
        "rusqlite::Connection::update_hook": [
          ">= 0.25.0, < 0.25.4",
          ">= 0.26.0, < 0.26.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.26.2",
        "0.25.4"
      ],
      "unaffected": [
        "< 0.25.0"
      ]
    },
    "text": "\n\n# Incorrect Lifetime Bounds on Closures in `rusqlite`\n\nThe lifetime bound on several closure-accepting `rusqlite` functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.\n\nThe impacted functions are:\n\n- Under `cfg(feature = \"functions\")`: `Connection::create_scalar_function`, `Connection::create_aggregate_function` and `Connection::create_window_function`.\n- Under `cfg(feature = \"hooks\")`: `Connection::commit_hook`, `Connection::rollback_hook` and `Connection::update_hook`.\n- Under `cfg(feature = \"collation\")`: `Connection::create_collation`.\n\nThe issue exists in all `0.25.*` versions prior to `0.25.4`, and all `0.26.*` versions prior to 0.26.2 (specifically: `0.25.0`, `0.25.1`, `0.25.2`, `0.25.3`, `0.26.0`, and `0.26.1`).\n\nThe fix is available in versions `0.26.2` and newer, and also has been back-ported to `0.25.4`. As it does not exist in `0.24.*`, all affected versions should have an upgrade path to a semver-compatible release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0014",
      "package": "rusqlite",
      "aliases": [
        "CVE-2020-35866",
        "CVE-2020-35867",
        "CVE-2020-35868",
        "CVE-2020-35869",
        "CVE-2020-35870",
        "CVE-2020-35871",
        "CVE-2020-35872",
        "CVE-2020-35873",
        "GHSA-28ph-f7gx-fqj8",
        "GHSA-3cgf-9m6x-pwwr",
        "GHSA-6q5w-m3c5-rv95",
        "GHSA-8h4j-vm3r-vcq3",
        "GHSA-8r7q-r9mx-35rh",
        "GHSA-g4w7-3qr8-5623",
        "GHSA-q3cc-7p7g-392c",
        "GHSA-rjh8-p66p-jrh5"
      ],
      "date": "2020-04-23",
      "url": "https://github.com/rusqlite/rusqlite/releases/tag/0.23.0"
    },
    "affected": {
      "functions": {
        "rusqlite::Connection::get_aux": [
          "< 0.23.0"
        ],
        "rusqlite::Connection::set_aux": [
          "< 0.23.0"
        ],
        "rusqlite::session::Session::attach": [
          "< 0.23.0"
        ],
        "rusqlite::session::Session::diff": [
          "< 0.23.0"
        ],
        "rusqlite::trace::log": [
          "< 0.23.0"
        ],
        "rusqlite::vtab::create_module": [
          "< 0.23.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.23.0"
      ]
    },
    "text": "\n\n# Various memory safety issues\n\nSeveral memory safety issues have been uncovered in an audit of\nrusqlite.\n\nSee https://github.com/rusqlite/rusqlite/releases/tag/0.23.0 for a complete list.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0024",
      "package": "safe-api",
      "date": "2021-02-15",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_api/pull/619"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_api`\n\nThis crate has been renamed from `safe-api` to `sn_api`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_api>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0035",
      "package": "websocket",
      "date": "2022-08-01",
      "url": "https://github.com/websockets-rs/rust-websocket/security/advisories/GHSA-qrjv-rf5q-qpxc",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "websocket"
      ],
      "aliases": [
        "CVE-2022-35922",
        "GHSA-qrjv-rf5q-qpxc"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.26.5"
      ]
    },
    "text": "\n\n# Unbounded memory allocation based on untrusted length\n\n## Impact\nUntrusted websocket connections can cause an out-of-memory (OOM) process abort in a client or a server.\nThe root cause of the issue is during dataframe parsing.\nAffected versions would allocate a buffer based on the declared dataframe size, which may come from an untrusted source.\nWhen `Vec::with_capacity` fails to allocate, the default Rust allocator will abort the current process, killing all threads. This affects only sync (non-Tokio) implementation. Async version also does not limit memory, but does not use `with_capacity`, so DoS can happen only when bytes for oversized dataframe or message actually got delivered by the attacker.\n\nThis is a security concern for you, if\n- your server application handles untrusted websocket connections\n- OR your client application connects to untrusted websocket servers\n\n## Patches\nThe crashes are fixed in version **0.26.5** by imposing default dataframe size limits.\nAffected users are advised to update to this version.\n\nNote that default memory limits are rather large (100MB dataframes and 200 MB messages), so they can still cause DoS in some environments (i.e. 32-bit). New API has been added to fine tune those limits for specific applications.\n\n### Workarounds\n\n* Migrate your project to another, maintained Websocket library like Tungstenite.\n* Accept only trusted WebSocket traffic.\n* Filter the WebSocket traffic though some kind of proxy that ensures sanity limits on messages.\n* Handle process aborts gracefully and limit process memory using OS tools.\n\n\n## Credits\nThis issue was reported by [Evan Richter](https://github.com/evanrichter) at ForAllSecure and found with [Mayhem](https://forallsecure.com/mayhem-for-code) and [Cargo Fuzz](https://github.com/rust-fuzz/cargo-fuzz).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0031",
      "package": "tiny_http",
      "aliases": [
        "CVE-2020-35884",
        "GHSA-7v2r-wxmg-mgvc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
      "date": "2020-06-16",
      "keywords": [
        "http",
        "request-smuggling"
      ],
      "url": "https://github.com/tiny-http/tiny-http/issues/173"
    },
    "versions": {
      "patched": [
        ">= 0.8.0",
        "^0.6.3"
      ]
    },
    "text": "\n\n# HTTP Request smuggling through malformed Transfer Encoding headers\n\nHTTP pipelining issues and request smuggling attacks are possible due to incorrect \nTransfer encoding header parsing.\n\nIt is possible conduct HTTP request smuggling attacks (CL:TE/TE:TE) by sending invalid Transfer Encoding headers. \n\nBy manipulating the HTTP response the attacker could poison a web-cache, perform an XSS attack, or obtain sensitive information \nfrom requests other than their own.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0087",
      "package": "slack-morphism",
      "date": "2022-10-10",
      "url": "https://github.com/abdolence/slack-morphism-rust/commit/65ef9fac4f39c4e171e2952a6cf029bb0d059a89",
      "aliases": [
        "CVE-2022-39292",
        "GHSA-4mjx-2gh5-ph8h"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.3.2"
      ]
    },
    "text": "\n# Slack Webhooks secrets leak in debug logs\n\nDebug log formatting made it possible to leak Webhooks secrets into debug logs.\n\nThe patched version has introduced more strict checks to avoid this.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0086",
      "package": "slack-morphism",
      "date": "2022-07-22",
      "url": "https://github.com/abdolence/slack-morphism-rust/pull/133",
      "aliases": [
        "CVE-2022-31162",
        "GHSA-99j7-mhfh-w84p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.41.0"
      ]
    },
    "text": "\n# Slack OAuth Secrets leak in debug logs\n\nDebug log formatting made it possible to leak OAuth secrets into debug logs.\n\nThe patched version has introduced more strict checks to avoid this.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0026",
      "package": "git-path",
      "date": "2023-03-14",
      "url": "https://github.com/Byron/gitoxide/pull/741",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Gitoxide has renamed its crates.\n\nAll crates in the gitoxide project have been renamed from git-<crate> to\ngix-<crate>. The git- prefixed crates are no longer being updated. Switch\nto using gix-path to continue receiving updates.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0073",
      "package": "prost-types",
      "date": "2021-07-08",
      "url": "https://github.com/tokio-rs/prost/issues/438",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2021-38192",
        "GHSA-x4qm-mcjq-v2gf"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ]
    },
    "affected": {
      "functions": {
        "prost_types::Timestamp::Into<SystemTime>": [
          "<= 0.7.0"
        ]
      }
    },
    "text": "\n\n# Conversion from `prost_types::Timestamp` to `SystemTime` can cause an overflow and panic \n\nAffected versions of this crate contained a bug in which untrusted input could cause an overflow and panic when converting a `Timestamp` to `SystemTime`.\n\nIt is recommended to upgrade to `prost-types` v0.8 and switch the usage of `From<Timestamp> for SystemTime` to `TryFrom<Timestamp> for SystemTime`.\n\nSee [#438] for more information.\n\n[#438]: https://github.com/tokio-rs/prost/issues/438 \n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0004",
      "package": "lucet-runtime-internals",
      "aliases": [
        "CVE-2020-35859",
        "GHSA-3933-wvjf-pcvc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "date": "2020-01-24",
      "url": "https://github.com/bytecodealliance/lucet/pull/401"
    },
    "versions": {
      "patched": [
        "< 0.5.0, >= 0.4.3",
        ">= 0.5.1"
      ]
    },
    "text": "\n\n# sigstack allocation bug can cause memory corruption or leak\n\nAn embedding using affected versions of lucet-runtime configured to use\nnon-default Wasm globals sizes of more than 4KiB, or compiled in debug mode\nwithout optimizations, could leak data from the signal handler stack to guest\nprograms. This can potentially cause data from the embedding host to leak to\nguest programs or cause corruption of guest program memory.\n\nThis flaw was resolved by correcting the sigstack allocation logic.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0041",
      "package": "trust-dns-server",
      "date": "2023-06-01",
      "url": "https://github.com/bluejekyll/trust-dns/pull/1952",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "packet loop"
      ],
      "aliases": [
        "GHSA-5fm9-h728-fwpj"
      ]
    },
    "versions": {
      "patched": [
        "^0.22.1",
        ">=0.23.0-alpha.3"
      ]
    },
    "text": "\n\n# Remote Attackers can cause Denial-of-Service (packet loops) with crafted DNS packets\n\ntrust-dns and trust-dns-server are vulnerable to remotely triggered denial-of-service attacks, consuming both network and CPU resources.\nDNS messages with the QR=1 bit set are responded to with a `FormErr` response.\nThis allows creating a traffic loop, in which these `FormErr` responses are sent nonstop between vulnerable servers.\n\nThere are two scenarios how this can be exploited: 1) Create a loop between two instances of trust-dns, consuming network resources, or 2) consuming the CPU of a single instance.\n\nWith two instances *A* and *B* an attacker sends a DNS query with a spoofed source IP address to *A*.\n*A* replies with a `FormErr` to *B*.\nNow both servers with ping-pong the message back and forth until by chance the packet is dropped in the network.\nMultiple spoofed packets can be sent by the attacker, increasing resource consumption.\n\nA single server can get locked up replying to itself.\nSame setup as above, but now *A* sends the reply to itself.\nThe packet is sent out as fast as the CPU and network stack manage.\nThis locks up a CPU core.\nMultiple packets from the attacker consume multiple CPU cores.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0001",
      "package": "trust-dns-server",
      "aliases": [
        "CVE-2020-35857",
        "GHSA-4cww-f7w5-x525"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2020-01-06",
      "keywords": [
        "stack-overflow",
        "crash"
      ],
      "url": "https://github.com/bluejekyll/trust-dns/issues/980"
    },
    "versions": {
      "patched": [
        ">= 0.18.1"
      ],
      "unaffected": [
        "< 0.16.0"
      ]
    },
    "text": "\n\n# Stack overflow when resolving additional records from MX or SRV null targets\n\nThere's a stack overflow leading to a crash and potential DOS when processing\nadditional records for return of MX or SRV record types from the server.\n\nThis is only possible when a zone is configured with a null target for MX or SRV records, i.e. '.'.\n\nExample effected zone record:\n```text\nno-service 86400 IN MX 0 .\n```\n\nPrior to 0.16.0 the additional record processing was not supported by trust-dns-server. There\nAre no known issues with upgrading from 0.16 or 0.17 to 0.18.1. The remidy should be to upgrade to\n0.18.1. If unable to do so, MX, SRV or other record types with a target to the null type, should be avoided.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0053",
      "package": "rustls-webpki",
      "date": "2023-08-22",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "certificate",
        "path building",
        "x509"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "related": [
        "CVE-2018-16875"
      ],
      "aliases": [
        "GHSA-fh2r-99q2-6mmg"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.100.2, < 0.101.0",
        ">= 0.101.4"
      ]
    },
    "text": "\n\n# rustls-webpki: CPU denial of service in certificate path building\n\nWhen this crate is given a pathological certificate chain to validate, it will\nspend CPU time exponential with the number of candidate certificates at each\nstep of path building.\n\nBoth TLS clients and TLS servers that accept client certificate are affected.\n\nWe now give each path building operation a budget of 100 signature verifications.\n\nThe original `webpki` crate is also affected.\n\nThis was previously reported in the original crate\n<https://github.com/briansmith/webpki/issues/69> and re-reported to us\nrecently by Luke Malinowski.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0058",
      "package": "stream-cipher",
      "date": "2020-10-15",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/traits/pull/337"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `cipher`\n\nThis crate has been renamed from `stream-cipher` to `cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/cipher>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0102",
      "package": "late-static",
      "aliases": [
        "CVE-2020-36209",
        "GHSA-wr55-mf5c-hhwm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/Richard-W/late-static/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# LateStatic has incorrect Sync bound\n\nAffected versions of this crate implemented `Sync` for `LateStatic` with `T: Send`, so that it is possible to create a data race to a type `T: Send + !Sync` (e.g. `Cell<T>`).\n\nThis can result in a memory corruption or other kinds of undefined behavior.\n\nThe flaw was corrected in commit 11f396c by replacing the `T: Send` bound to `T: Sync` bound in the `Sync` impl for `LateStatic<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0344",
      "package": "curve25519-dalek",
      "date": "2024-06-18",
      "categories": [
        "crypto-failure"
      ],
      "url": "https://github.com/dalek-cryptography/curve25519-dalek/pull/659"
    },
    "versions": {
      "patched": [
        ">= 4.1.3"
      ]
    },
    "text": "\n\n# Timing variability in `curve25519-dalek`'s `Scalar29::sub`/`Scalar52::sub`\n\nTiming variability of any kind is problematic when working with  potentially secret values such as\nelliptic curve scalars, and such issues can potentially leak private keys and other secrets. Such a\nproblem was recently discovered in `curve25519-dalek`.\n\nThe `Scalar29::sub` (32-bit) and `Scalar52::sub` (64-bit) functions contained usage of a mask value\ninside a loop where LLVM saw an opportunity to insert a branch instruction (`jns` on x86) to\nconditionally bypass this code section when the mask value is set to zero as can be seen in godbolt:\n\n- 32-bit (see L106): <https://godbolt.org/z/zvaWxzvqv>\n- 64-bit (see L48): <https://godbolt.org/z/PczYj7Pda>\n\nA similar problem was recently discovered in the Kyber reference implementation:\n\n<https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hqbtIGFKIpU/m/cnE3pbueBgAJ>\n\nAs discussed on that thread, one portable solution, which is also used in this PR, is to introduce a\nvolatile read as an optimization barrier, which prevents the compiler from optimizing it away.\n\nThe fix can be validated in godbolt here:\n\n- 32-bit: <https://godbolt.org/z/jc9j7eb8E>\n- 64-bit: <https://godbolt.org/z/x8d46Yfah>\n\nThe problem was discovered and the solution independently verified by \nAlexander Wagner <alexander.wagner@aisec.fraunhofer.de> and Lea Themint <lea.thiemt@tum.de> using\ntheir DATA tool:\n\n<https://github.com/Fraunhofer-AISEC/DATA>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0124",
      "package": "async-coap",
      "date": "2020-12-08",
      "url": "https://github.com/google/rust-async-coap/issues/33",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36444",
        "GHSA-9j8q-m9x5-9g6j"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# ArcGuard's Send and Sync should have bounds on RC\n\nAffected versions of this crate implement Send/Sync for `ArcGuard<RC, T>` with no trait bounds on `RC`. This allows users to send `RC: !Send` to other threads and also allows users to concurrently access `Rc: !Sync` from multiple threads.\n\nThis can result in memory corruption from data race or other undefined behavior caused by sending `T: !Send` to other threads (e.g. dropping `MutexGuard<T>` in another thread that didn't lock its mutex).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0004",
      "package": "claxon",
      "aliases": [
        "CVE-2018-20992",
        "GHSA-8c6g-4xc5-w96c"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
      "date": "2018-08-25",
      "keywords": [
        "uninitialized-memory"
      ],
      "url": "https://github.com/ruuda/claxon/commit/8f28ec275e412dd3af4f3cda460605512faf332c"
    },
    "versions": {
      "patched": [
        "^0.3.2",
        ">= 0.4.1"
      ]
    },
    "text": "\n\n# Malicious input could cause uninitialized memory to be exposed\n\nAffected versions of Claxon made an invalid assumption about the decode buffer\nsize being a multiple of a value read from the bitstream. This could cause parts\nof the decode buffer to not be overwritten. If the decode buffer was newly\nallocated and uninitialized, this uninitialized memory could be exposed.\n\nThis allows an attacker to observe parts of the uninitialized memory in the\ndecoded audio stream.\n\nThe flaw was corrected by checking that the value read from the bitstream divides\nthe decode buffer size, and returning a format error if it does not. If an error\nis returned, the decode buffer is not exposed. Regression tests and an\nadditional fuzzer have been added to prevent similar flaws in the future.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0006",
      "package": "bumpalo",
      "aliases": [
        "CVE-2020-35861",
        "GHSA-vqx7-pw4r-29rr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "categories": [
        "memory-exposure"
      ],
      "date": "2020-03-24",
      "url": "https://github.com/fitzgen/bumpalo/issues/69"
    },
    "versions": {
      "patched": [
        ">= 3.2.1"
      ],
      "unaffected": [
        "< 3.0.0"
      ]
    },
    "text": "\n\n# Flaw in `realloc` allows reading unknown memory\n\nWhen `realloc`ing, if we allocate new space, we need to copy the old\nallocation's bytes into the new space. There are `old_size` number of bytes in\nthe old allocation, but we were accidentally copying `new_size` number of bytes,\nwhich could lead to copying bytes into the realloc'd space from past the chunk\nthat we're bump allocating out of, from unknown memory.\n\nIf an attacker can cause `realloc`s, and can read the `realoc`ed data back,\nthis could allow them to read things from other regions of memory that they\nshouldn't be able to. For example, if some crypto keys happened to live in\nmemory right after a chunk we were bump allocating out of, this could allow\nthe attacker to read the crypto keys.\n\nBeyond just fixing the bug and adding a regression test, I've also taken two\nadditional steps:\n\n1. While we were already running the testsuite under `valgrind` in CI, because\n   `valgrind` exits with the same code that the program did, if there are\n   invalid reads/writes that happen not to trigger a segfault, the program can\n   still exit OK and we will be none the wiser. I've enabled the\n   `--error-exitcode=1` flag for `valgrind` in CI so that tests eagerly fail\n   in these scenarios.\n\n2. I've written a quickcheck test to exercise `realloc`. Without the bug fix\n   in this patch, this quickcheck immediately triggers invalid reads when run\n   under `valgrind`. We didn't previously have quickchecks that exercised\n   `realloc` because `realloc` isn't publicly exposed directly, and instead\n   can only be indirectly called. This new quickcheck test exercises `realloc`\n   via `bumpalo::collections::Vec::resize` and\n   `bumpalo::collections::Vec::shrink_to_fit` calls.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0078",
      "package": "bumpalo",
      "date": "2022-01-14",
      "url": "https://github.com/fitzgen/bumpalo/blob/main/CHANGELOG.md#3111",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-f85w-wvc7-crwc"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.11.1"
      ],
      "unaffected": [
        "< 1.1.0"
      ]
    },
    "affected": {
      "functions": {
        "bumpalo::collections::vec::Vec::into_iter": [
          "< 3.11.1"
        ]
      }
    },
    "text": "\n\n# Use-after-free due to a lifetime error in `Vec::into_iter()`\n\nIn affected versions of this crate, the lifetime of the iterator produced by\n`Vec::into_iter()` is not constrained to the lifetime of the `Bump` that\nallocated the vector's memory. Using the iterator after the `Bump` is dropped\ncauses use-after-free accesses.\n\nThe following example demonstrates memory corruption arising from a misuse of\nthis unsoundness.\n\n```rust\nuse bumpalo::{collections::Vec, Bump};\n\nfn main() {\n    let bump = Bump::new();\n    let mut vec = Vec::new_in(&bump);\n    vec.extend([0x01u8; 32]);\n    let into_iter = vec.into_iter();\n    drop(bump);\n\n    for _ in 0..100 {\n        let reuse_bump = Bump::new();\n        let _reuse_alloc = reuse_bump.alloc([0x41u8; 10]);\n    }\n\n    for x in into_iter {\n        print!(\"0x{:02x} \", x);\n    }\n    println!();\n}\n```\n\nThe issue was corrected in version 3.11.1 by adding a lifetime to the `IntoIter`\ntype, and updating the signature of `Vec::into_iter()` to constrain this\nlifetime.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0035",
      "package": "enumflags2",
      "date": "2023-04-17",
      "url": "https://github.com/meithecatte/enumflags2/releases/tag/v0.7.7",
      "informational": "unsound",
      "aliases": [
        "GHSA-qvc4-78gw-pv8p"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.7"
      ],
      "unaffected": [
        "< 0.7.0"
      ]
    },
    "text": "\n\n# Adverserial use of `make_bitflags!` macro can cause undefined behavior\n\nThe macro relied on an expression of the form `Enum::Variant` always being a\nvariant of the enum. However, it may also be an associated integer constant, in\nwhich case there's no guarantee that the value of said constant consists only of\nbits valid for this bitflag type.\n\nThus, code like this could create an invalid `BitFlags<Test>`, which would cause\niterating over it to trigger undefined behavior. As the debug formatter\ninternally iterates over the value, it is also affected.\n\n```rust\nuse enumflags2::{bitflags, make_bitflags};\n\n#[bitflags]\n#[repr(u8)]\n#[derive(Copy, Clone, Debug)]\nenum Test {\n    A = 1,\n    B = 2,\n}\n\nimpl Test {\n    const C: u8 = 69;\n}\n\nfn main() {\n    let x = make_bitflags!(Test::{C});\n    // printing or iterating over x is UB\n}\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0030",
      "package": "rulex",
      "date": "2022-05-21",
      "url": "https://github.com/rulex-rs/rulex/security/advisories/GHSA-v78m-2q7v-fjqp",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2022-31099",
        "GHSA-v78m-2q7v-fjqp"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# Stack overflow during recursive expression parsing\n\nWhen parsing untrusted rulex expressions, the stack may overflow, possibly\nenabling a Denial of Service attack. This happens when parsing an expression\nwith several hundred levels of nesting, causing the process to abort\nimmediately.\n\nThe flaw was corrected in commits `60aa2dc03a` by adding a check to recursion\ndepth.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0031",
      "package": "rulex",
      "date": "2022-05-21",
      "url": "https://github.com/rulex-rs/rulex/security/advisories/GHSA-8v9w-p43c-r885",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2022-31100",
        "GHSA-8v9w-p43c-r885"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# Panic due to improper UTF-8 indexing\n\nWhen parsing untrusted rulex expressions, rulex may panic, possibly enabling\na Denial of Service attack. This happens when the expression contains a multi-\nbyte UTF-8 code point in a string literal or after a backslash, because rulex\ntries to slice into the code point and panics as a result.\n\nThe flaw was corrected in commits `fac6d58b25` and `330b3534e7` by using\n`len_utf8()` to derive character width in bytes instead of assuming ASCII\nencoding of 1 byte per char.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0100",
      "package": "sys-info",
      "date": "2020-05-31",
      "url": "https://github.com/FillZpp/sys-info-rs/issues/63",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency",
        "double free"
      ],
      "aliases": [
        "CVE-2020-36434",
        "GHSA-2f5j-3mhq-xv58"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.8.0"
      ],
      "unaffected": []
    },
    "affected": {
      "os": [
        "linux"
      ],
      "functions": {
        "sys_info::disk_info": [
          "<= 0.1.1"
        ]
      }
    },
    "text": "\n\n# Double free when calling `sys_info::disk_info` from multiple threads\n\nAffected versions of `sys-info` use a static, global, list to store temporary disk information while running. The function that cleans up this list,\n`DFCleanup`, assumes a single threaded environment and will try to free the same memory twice in a multithreaded environment.\n\nThis results in consistent double-frees and segfaults when calling `sys_info::disk_info` from multiple threads at once.\n\nThe issue was fixed by moving the global variable into a local scope.\n\n## Safer Alternatives:\n - [`sysinfo`](https://crates.io/crates/sysinfo)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0149",
      "package": "appendix",
      "date": "2020-11-15",
      "url": "https://github.com/krl/appendix/issues/6",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36469",
        "GHSA-fvhr-7j8m-3cvc"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Data race and memory safety issue in `Index`\n\nThe `appendix` crate implements a key-value mapping data structure called\n`Index<K, V>` that is stored on disk. The crate allows for any type to inhabit\nthe generic `K` and `V` type parameters and implements Send and Sync for them\nunconditionally.\n\nUsing a type that is not marked as `Send` or `Sync` with `Index` can allow it\nto be used across multiple threads leading to data races. Additionally using\nreference types for the keys or values will lead to the segmentation faults\nin the crate's code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0019",
      "package": "xcb",
      "aliases": [
        "CVE-2021-26955",
        "CVE-2021-26956",
        "CVE-2021-26957",
        "CVE-2021-26958",
        "GHSA-2xpg-3hx4-fm9r",
        "GHSA-3288-cwgw-ch86",
        "GHSA-3cj3-jrrp-9rxf",
        "GHSA-mp6r-fgw2-rxfx"
      ],
      "date": "2021-02-04",
      "url": "https://github.com/RustSec/advisory-db/issues/653",
      "references": [
        "https://github.com/rust-x-bindings/rust-xcb/issues/78",
        "https://github.com/rust-x-bindings/rust-xcb/issues/94",
        "https://github.com/rust-x-bindings/rust-xcb/issues/95",
        "https://github.com/rust-x-bindings/rust-xcb/issues/96"
      ],
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0"
      ]
    },
    "text": "\n\n# Multiple soundness issues\n\n## Calls `std::str::from_utf8_unchecked()` without any checks\n\nThe function `xcb::xproto::GetAtomNameReply::name()` calls\n`std::str::from_utf8_unchecked()` on the raw bytes that were received from the\nX11 server without any validity checks. The X11 server only prevents interior\nnull bytes, but otherwise allows any X11 client to create an atom for arbitrary\nbytes.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/96\n\n## `xcb::xproto::GetPropertyReply::value()` allows arbitrary return types\n\nThe function `xcb::xproto::GetPropertyReply::value()` returns a slice of type\n`T` where `T` is an unconstrained type parameter. The raw bytes received from\nthe X11 server are interpreted as the requested type.\n\nThe users of the `xcb` crate are advised to only call this function with the\nintended types. These are `u8`, `u16`, and `u32`.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/95\n\n## Out of bounds read in `xcb::xproto::change_property()`\n\n`xcb::xproto::change_property` has (among others) the arguments `format: u8` and\n`data: &[T]`. The intended use is one of the following cases:\n- `format = 8` and `T = u8`\n- `format = 16` and `T = u16`\n- `format = 32` and `T = u32`\nHowever, this constraint is not enforced. For example, it is possible to call\nthe function with `format = 32` and `T = u8`. In this case, a read beyond the\nend of the `data` slice is performed and the bytes are sent to the X11 server.\n\nThe users of the `xcb` crate are advised to only call this function with one of\nthe intended argument combinations.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/94\n\n## 'Safe' wrapper around `std::mem::transmute()`\n\nThe function `xcb::base::cast_event()` takes a reference to a\n`xcb::base::GenericEvent` and returns a reference to an arbitrary type, as\nrequested by the caller (or found via type interference). The function is\nimplemented as a direct call to `std::mem::transmute()`. Since the return type\nis not constrained, this allows transmution to an incorrect type or a type that\nis larger than the X11 event that was passed in.\n\nX11 events are mostly always 32 bytes large and this function works as intended.\n\nUsers are advised to only cast to the event structs provided by the `xcb` crate\n(and hope for the best).\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/78\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0097",
      "package": "xcb",
      "aliases": [
        "CVE-2020-36205",
        "GHSA-c8hq-x4mm-p6q6"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-12-10",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/93",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 1.0"
      ]
    },
    "text": "\n\n# Soundness issue with base::Error\n\n`base::Error` type contains public field named `ptr`.\nWith this definition, it is possible to create a `base::Error` with an invalid pointer and trigger memory safety errors\nsuch as use-after-free or double-free with safe Rust.\n\nThe users of `xcb` crate are advised not to manipulate the field.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0045",
      "package": "adtensor",
      "aliases": [
        "CVE-2021-29936",
        "GHSA-rg4m-gww5-7p47"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-11",
      "url": "https://github.com/charles-r-earp/adtensor/issues/4",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# FromIterator implementation for Vector/Matrix can drop uninitialized memory\n\nThe `FromIterator<T>` methods for `Vector` and `Matrix` rely on the type\nparameter `N` to allocate space in the iterable.\n\nIf the passed in `N` type parameter is larger than the number of items returned\nby the iterator, it can lead to uninitialized memory being left in the\n`Vector` or `Matrix` type which gets dropped.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0037",
      "package": "pnet",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
      "date": "2019-06-11",
      "keywords": [
        "segfault"
      ],
      "url": "https://github.com/libpnet/libpnet/issues/449",
      "aliases": [
        "CVE-2019-25054",
        "GHSA-24g6-5rx7-58wj",
        "GHSA-r6ff-2q3c-v3pv"
      ]
    },
    "affected": {
      "functions": {
        "pnet::transport::IcmpTransportChannelIterator": [
          "< 0.27.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.27.2"
      ]
    },
    "text": "\n\n# Compiler optimisation for next_with_timeout in pnet::transport::IcmpTransportChannelIterator flaws to SEGFAULT\n\nAffected versions of this crate were optimized out by compiler,\nwhich caused dereference of uninitialized file descriptor which caused segfault.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0022",
      "package": "yottadb",
      "aliases": [
        "CVE-2021-27377",
        "GHSA-9658-c26v-7qvf"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-09",
      "url": "https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/40",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.0"
      ]
    },
    "affected": {
      "functions": {
        "yottadb::Key::sub_next_self_st": [
          "< 1.2.0"
        ],
        "yottadb::Key::sub_prev_self_st": [
          "< 1.2.0"
        ],
        "yottadb::KeyContext::sub_next_self_st": [
          "< 1.2.0"
        ],
        "yottadb::KeyContext::sub_prev_self_st": [
          "< 1.2.0"
        ]
      }
    },
    "text": "\n\n# Use-after-free in `subscript_next` and `subscript_prev` wrappers\n\nAffected versions of this crate had an unsound implementation which could pass\na pointer to freed memory to `ydb_subscript_next_st` and\n`ydb_subscript_prev_st` if the variable and subscripts did not have enough\nmemory allocated on the first call to hold the next variable in the database.\n\nFor example, the following code had undefined behavior:\n\n```rust\nlet mut key = Key::variable(String::from(\"a\"));\nKey::variable(\"averylongkeywithlotsofletters\")\n    .set_st(YDB_NOTTP, Vec::new(), b\"some val\")\n    .unwrap();\nkey.sub_next_self_st(YDB_NOTTP, Vec::new()).unwrap();\n```\n\n`yottadb` has no reverse-dependencies on crates.io and there are no known\ninstances of this API being used incorrectly in practice. The fix is backwards\ncompatible.\n\nThe flaw was corrected by recalculating the pointer each time it was reallocated.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0008",
      "package": "trillium-client",
      "date": "2024-01-23",
      "url": "https://github.com/trillium-rs/trillium/security/advisories/GHSA-9f9p-cp3c-72jf",
      "keywords": [
        "http",
        "request",
        "splitting"
      ],
      "aliases": [
        "GHSA-9f9p-cp3c-72jf",
        "CVE-2024-23644"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.5.4"
      ],
      "unaffected": []
    },
    "affected": {},
    "text": "\n\n# Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n\n### Summary\nInsufficient validation of outbound header values may lead to request splitting or response splitting attacks in scenarios where attackers have sufficient control over outbound headers.\n\n### Details\nOutbound `trillium_http::HeaderValue` and `trillium_http::HeaderName` can be constructed infallibly and were not checked for illegal bytes when sending requests. Thus, if an attacker has sufficient control over header values (or names) in a request that they could inject `\\r\\n` sequences, they could get the client and server out of sync, and then pivot to gain control over other parts of requests or responses. (i.e. exfiltrating data from other requests, SSRF, etc.)\n\n### Patches\n\n#### trillium-client >= 0.5.4:\n* If any header name or header value is invalid in the client request headers, awaiting the client Conn returns an `Error::MalformedHeader` prior to any network access.\n\n### Workarounds\n\ntrillium client applications should sanitize or validate untrusted input that is included in header values and header names. Carriage return, newline, and null characters are not allowed.\n\n### Impact\n\nThis only affects use cases where attackers have control of outbound headers, and can insert \"\\r\\n\" sequences. Specifically, if untrusted and unvalidated input is inserted into header names or values.\n\n### Credit\n\nDiscovered and reported by [@divergentdave](https://github.com/divergentdave)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0088",
      "package": "csv-sniffer",
      "date": "2021-01-05",
      "url": "https://github.com/jblondin/csv-sniffer/issues/1",
      "references": [
        "https://github.com/jblondin/csv-sniffer/pull/2"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45686",
        "GHSA-9783-42pm-x5jq",
        "GHSA-r67p-m7g9-gxw6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# `Read` on uninitialized memory may cause UB (fn preamble_skipcount())\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (within `fn preamble_skipcount()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0039",
      "package": "endian_trait",
      "aliases": [
        "CVE-2021-29929",
        "GHSA-vpw8-43wm-rxw5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-04",
      "url": "https://gitlab.com/myrrlyn/endian_trait/-/issues/1",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# panic in user-provided `Endian` impl triggers double drop of T\n\nAffected versions of the crate does not guard against panic from user-provided impl of `Endian` trait, which is a safe trait that users can implement.\nIf a user-provided implementation of the `Endian` trait panics, double-drop is triggered due to the duplicated ownership of `T` created by `ptr::read()`.\n\nDouble-drop (or double free) can cause memory corruption in the heap.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0027",
      "package": "async-nats",
      "date": "2023-03-24",
      "url": "https://github.com/nats-io/nats.rs/commit/817a7b942c462fa9d9938dcb62124173634132fb#diff-767d442397fcaaf2f83e8f924d4a70317a2ce4703a49964d6007707949cfa5f5L303-R304",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [
        "tls",
        "mitm"
      ],
      "aliases": [
        "GHSA-f5v5-ccqc-6w36"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.29.0"
      ]
    },
    "text": "\n\n# TLS certificate common name validation bypass\n\nThe NATS official Rust clients are vulnerable to MitM when using TLS.\n\nThe common name of the server's TLS certificate is validated against\nthe `host`name provided by the server's plaintext `INFO` message\nduring the initial connection setup phase. A MitM proxy can tamper with\nthe `host` field's value by substituting it with the common name of a\nvalid certificate it controls, fooling the client into accepting it.\n\n## Reproduction steps\n\n1. The NATS Rust client tries to establish a new connection\n2. The connection is intercepted by a MitM proxy\n3. The proxy makes a separate connection to the NATS server\n4. The NATS server replies with an `INFO` message\n5. The proxy reads the `INFO`, alters the `host` JSON field and passes\n   the tampered `INFO` back to the client\n6. The proxy upgrades the client connection to TLS, presenting a certificate issued\n   by a certificate authority present in the client's keychain.\n   In the previous step the `host` was set to the common name of said certificate\n7. `rustls` accepts the certificate, having verified that the common name matches the\n   attacker-controlled value it was given\n9. The client has been fooled by the MitM proxy into accepting the attacker-controlled certificate\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0059",
      "package": "aesni",
      "date": "2021-04-29",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `aesni` has been merged into the `aes` crate\n\nPlease use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nAES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.\nIf AES-NI is not present, the `aes` crate will fallback to a constant-time\nportable software implementation.\n\nTo prevent this fallback (and have absence of AES-NI result in an illegal\ninstruction crash instead), continue to pass the same RUSTFLAGS which were\npreviously required for the `aesni` crate to compile:\n\n```\nRUSTFLAGS=-Ctarget-feature=+aes,+ssse3\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0081",
      "package": "json",
      "date": "2022-02-01",
      "url": "https://github.com/maciejhirsz/json-rust/issues/205",
      "references": [
        "https://github.com/maciejhirsz/json-rust/issues/196"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# json is unmaintained\n\nLast release was almost 3 years ago.\n\nThe maintainer is unresponsive with outstanding issues.\n\nOne of the outstanding issues include [a possible soundness issue](https://github.com/maciejhirsz/json-rust/issues/196).\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n- [jzon](https://crates.io/crates/jzon) maintained fork of json\n- [serde_json](https://crates.io/crates/serde_json)\n- [json-deserializer](https://crates.io/crates/json-deserializer)\n- [simd-json](https://crates.io/crates/simd-json)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0066",
      "package": "conduit-hyper",
      "date": "2022-10-30",
      "url": "https://github.com/conduit-rust/conduit-hyper/security/advisories/GHSA-9398-5ghf-7pr6",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "GHSA-9398-5ghf-7pr6",
        "CVE-2022-39294"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.2"
      ],
      "unaffected": [
        "< 0.2.0-alpha.3"
      ]
    },
    "text": "\n\n# Denial of Service from unchecked request length\n\nPrior to version 0.4.2, `conduit-hyper` did not check any limit on a request's\nlength before calling `hyper::body::to_bytes`. An attacker could send a\nmalicious request with an abnormally large `Content-Length`, which could lead\nto a panic if memory allocation failed for that request.\n\nIn version 0.4.2, `conduit-hyper` sets an internal limit of 128 MiB per\nrequest, otherwise returning status 400 (\"Bad Request\").\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0051",
      "package": "lz4-sys",
      "date": "2022-08-25",
      "url": "https://github.com/lz4/lz4/pull/972",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "keywords": [
        "integer-overflow",
        "out-of-bounds"
      ],
      "related": [
        "CVE-2021-3520"
      ],
      "aliases": [
        "GHSA-9q5j-jm53-v7vr"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.9.4"
      ]
    },
    "text": "\n\n# Memory corruption in liblz4\n\nlz4-sys up to v1.9.3 bundles a version of liblz4 that is vulnerable to\n[CVE-2021-3520](https://nvd.nist.gov/vuln/detail/CVE-2021-3520).\n\nAttackers could craft a payload that triggers an integer overflow upon\ndecompression, causing an out-of-bounds write.\n\nThe flaw has been corrected in version v1.9.4 of liblz4, which is included\nin lz4-sys 1.9.4.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0046",
      "package": "telemetry",
      "aliases": [
        "CVE-2021-29937",
        "GHSA-hpcx-3pw8-g3j2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-02-17",
      "url": "https://github.com/Yoric/telemetry.rs/issues/45",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# misc::vec_with_size() can drop uninitialized memory if clone panics\n\n`misc::vec_with_size` creates a vector of the provided `size` and immediately\ncalls `vec.set_len(size)` on it, initially filling it with uninitialized memory.\nIt then inserts elements using `vec[i] = value.clone()`.\n\nIf the `value.clone()` call panics, uninitialized items in the vector will be\ndropped leading to undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0037",
      "package": "xsalsa20poly1305",
      "date": "2023-05-16",
      "informational": "unmaintained",
      "url": "https://github.com/RustCrypto/AEADs/pull/525"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `crypto_secretbox`\n\nThis crate has been forked/renamed from `xsalsa20poly1305` to `crypto_secretbox`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/nacl-compat/tree/master/crypto_secretbox>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0105",
      "package": "git-delta",
      "date": "2021-07-12",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-36376",
      "categories": [
        "file-disclosure"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
      "aliases": [
        "CVE-2021-36376",
        "GHSA-5xg3-j2j6-rcx4"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.3"
      ]
    },
    "text": "\n\n# Relative Path Traversal in git-delta\n\ngit-delta before 0.8.3 on Windows resolves an executable's pathname as a relative path from the current directory.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0138",
      "package": "lexer",
      "date": "2020-11-10",
      "url": "https://gitlab.com/nathanfaucett/rs-lexer/-/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36458",
        "GHSA-f997-8gxg-r354"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# ReaderResult should be bounded by Sync\n\nAffected versions of this crate implements `Sync` for `ReaderResult<T, E>` with the trait bound `T: Send, E: Send`.\n\nSince matching on the public enum `ReaderResult<T, E>` provides access to `&T` & `&E`,\nallowing data race to a non-Sync type `T` or `E`.\nThis can result in a memory corruption when multiple threads concurrently access `&T` or `&E`.\n\nSuggested fix for the bug is change the trait bounds imposed on `T` & `E` to be `T: Sync, E: Sync`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0120",
      "package": "abomonation",
      "date": "2021-10-17",
      "url": "https://github.com/TimelyDataflow/abomonation/issues/23",
      "categories": [],
      "keywords": [],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45708",
        "GHSA-5vwc-r48g-wj6c",
        "GHSA-hfxp-p695-629x"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# abomonation transmutes &T to and from &[u8] without sufficient constraints\n\nThis transmute is at the core of the abomonation crates. It's so easy to use it to violate alignment requirements that no test in the crate's test suite passes under miri.\nThe use of this transmute in serialization/deserialization also incorrectly assumes that the layout of a repr(Rust) type is stable.\nThis transmute can also disclose both the contents of padding bytes which may be an information leak and the contents of pointers, which may be used to defeat ASLR.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0041",
      "package": "crossbeam-utils",
      "date": "2022-02-05",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/781",
      "aliases": [
        "GHSA-qc84-gqf4-9926",
        "CVE-2022-23639"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.7"
      ]
    },
    "text": "\n\n# Unsoundness of AtomicCell<*64> arithmetics on 32-bit targets that support Atomic*64\n\n## Impact\n\nAffected versions of this crate incorrectly assumed that the alignment of {i,u}64 was always the same as Atomic{I,U}64.\n\nHowever, the alignment of {i,u}64 on a 32-bit target can be smaller than Atomic{I,U}64.\n\nThis can cause the following problems:\n\n- Unaligned memory accesses\n- Data race\n\nCrates using fetch_* methods with AtomicCell<{i,u}64> are affected by this issue.\n\n32-bit targets without Atomic{I,U}64 and 64-bit targets are not affected by this issue.\n\n32-bit targets with Atomic{I,U}64 and {i,u}64 have the same alignment are also not affected by this issue.\n\nThe following is a complete list of the builtin targets that may be affected. (last update: nightly-2022-02-11)\n\n- armv7-apple-ios (tier 3)\n- armv7s-apple-ios (tier 3)\n- i386-apple-ios (tier 3)\n- i586-unknown-linux-gnu\n- i586-unknown-linux-musl\n- i686-apple-darwin (tier 3)\n- i686-linux-android\n- i686-unknown-freebsd\n- i686-unknown-haiku (tier 3)\n- i686-unknown-linux-gnu\n- i686-unknown-linux-musl\n- i686-unknown-netbsd (tier 3)\n- i686-unknown-openbsd (tier 3)\n- i686-wrs-vxworks (tier 3)\n\n([script to get list](https://gist.github.com/taiki-e/3c7891e8c5f5e0cbcb44d7396aabfe10))\n\n## Patches\n\nThis has been fixed in crossbeam-utils 0.8.7.\n\nAffected 0.8.x releases have been yanked.\n\nThanks to @taiki-e\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0118",
      "package": "arrow",
      "date": "2021-09-14",
      "url": "https://github.com/apache/arrow-rs/issues/774",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "buffer-overflow"
      ],
      "aliases": [
        "GHSA-qgrp-8f3v-q85p"
      ]
    },
    "versions": {
      "patched": [
        ">= 6.4.0"
      ]
    },
    "text": "\n\n# `FixedSizeBinaryArray` does not perform bound checks on accessing values and offsets\n\n`FixedSizeBinaryArray` performs insufficient bounds checks, which allows out-of-bounds reads in safe code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0116",
      "package": "arrow",
      "date": "2021-09-14",
      "references": [
        "https://github.com/apache/arrow-rs/issues/772",
        "https://github.com/apache/arrow-rs/issues/773"
      ],
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "buffer-overflow"
      ],
      "aliases": [
        "GHSA-r7cj-wmwv-hfw5"
      ]
    },
    "versions": {
      "patched": [
        ">= 6.4.0"
      ]
    },
    "text": "\n\n# `BinaryArray` does not perform bound checks on reading values and offsets\n\n`BinaryArray` performs insufficient validation on creation, which allows out-of-bounds reads in safe code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0117",
      "package": "arrow",
      "date": "2021-09-14",
      "url": "https://github.com/apache/arrow-rs/issues/775",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "buffer-overflow"
      ],
      "aliases": [
        "GHSA-h588-76vg-prgj"
      ]
    },
    "versions": {
      "patched": [
        ">= 6.4.0"
      ]
    },
    "text": "\n\n# `DecimalArray` does not perform bound checks on accessing values and offsets\n\n`DecimalArray` performs insufficient bounds checks,\nwhich allows out-of-bounds reads in safe code\nif the length of the backing buffer is not a multiple of 16.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0350",
      "package": "gix-fs",
      "date": "2024-05-22",
      "url": "https://github.com/Byron/gitoxide/security/advisories/GHSA-7w47-3wg8-547c",
      "references": [
        "https://github.com/advisories/GHSA-7w47-3wg8-547c",
        "https://nvd.nist.gov/vuln/detail/CVE-2024-35186"
      ],
      "categories": [
        "code-execution"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
      "keywords": [
        "directory-traversal"
      ],
      "aliases": [
        "CVE-2024-35186",
        "GHSA-7w47-3wg8-547c"
      ],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": [
        ">= 0.11.0"
      ]
    },
    "text": "\n\n# Traversal outside working tree enables arbitrary code execution\n\n### Summary\n\nDuring checkout, gitoxide does not verify that paths point to locations in the working tree. A specially crafted repository can, when cloned, place new files anywhere writable by the application.\n\n### Details\n\nAlthough `gix-worktree-state` checks for collisions with existing files, it does not itself check if a path is really in the working tree when performing a checkout, nor do the path checks in `gix-fs` and `gix-worktree` prevent this. Cloning an untrusted repository containing specially crafted tree or blob names will create new files outside the repository, or inside the repository or a submodule's `.git` directory. The simplest cases are:\n\n- A tree named `..` to traverse upward. This facilitates arbitrary code execution because files can be placed in one or more locations where they are likely to be executed soon.\n- A tree named `.git` to enter a `.git` directory. This facilitates arbitrary code execution because hooks can be installed.\n\nA number of alternatives that achieve the same effect are also possible, some of which correspond to specific vulnerabilities that have affected Git in the past:\n\n- A tree or blob whose name contains one or more `/`, to traverse upward or downward. For example, even without containing any tree named `..` or `.git`, a repository can represent a file named `../outside` or `.git/hooks/pre-commit`. This is distinct from the more intuitive case a repository containing trees that represent those paths.\n- In Windows, a tree or blob whose name contains one or more `\\`, to traverse upward or downward. (Unlike `/`, these are valid on other systems.) See [GHSA-xjx4-8694-q2fq](https://github.com/git/git/security/advisories/GHSA-xjx4-8694-q2fq).\n- On a case-insensitive filesystem (such as NTFS, APFS, or HFS+), a tree named as a case variant of `.git`.\n- On HFS+, a tree named like `.git` or a case variant, with characters added that HFS+ ignores [in collation](https://developer.apple.com/library/archive/technotes/tn/tn1150.html#StringComparisonAlgorithm). See https://github.com/git/git/commit/6162a1d323d24fd8cbbb1a6145a91fb849b2568f.\n- On NTFS, a tree equivalent to `.git` (or a case variant) by the use of [NTFS stream](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c54dec26-1551-4d3a-a0ea-4fa40f848eb3) notation, such as `.git::$INDEX_ALLOCATION`. See [GHSA-5wph-8frv-58vj](https://github.com/git/git/security/advisories/GHSA-5wph-8frv-58vj).\n- On an NTFS volume with [8.3 aliasing](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#short-vs-long-names) enabled, a tree named as `git~1` (or a case variant). See [GHSA-589j-mmg9-733v](https://github.com/git/git/security/advisories/GHSA-589j-mmg9-733v).\n\nWhen a checkout creates some files outside the repository directory but fails to complete, the repository directory is usually removed, but the outside files remain.\n\n### PoC\n\nFor simplicity, these examples stage a stand-in file with a valid name, modify the index, and commit. The instructions assume `sed` supports `-i`, which is the case on most systems. If using Windows, a Git Bash shell should be used.\n\n#### Example: Downward traversal to install hooks\n\n1. Create a new repository with `git init dangerous-repo-installs-hook` and `cd` into the directory.\n2. Create the stand-in called `.git@hooks@pre-commit`, with the *contents*:\n   ```sh\n   #!/bin/sh\n   printf 'Vulnerable!\\n'\n   date >vulnerable\n   ```\n3. Stage the stand-in: `git add --chmod=+x .git@hooks@pre-commit`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.git@hooks@pre-commit|.git/hooks/pre-commit|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, on another or the same machine:\n\n1. Clone the repository with a `gix clone \u2026` command.\n2. Enter the newly created directory.\n3. *Optionally* run `ls -l .git/hooks` to observe that the `pre-commit` hook is already present.\n4. Make a new file and commit it with `git`. This causes the payload surreptitiously installed as a `pre-commit` hook to run, printing the message `Vulnerable!` and creating a file in the current directory containing the current date and time.\n\nNote that the effect is not limited to modifying the current directory. The payload could be written to perform any action that the user who runs `git commit` is capable of.\n\n#### Example: Upward traversal to create a file above the working tree\n\n1. Create a new repository with `git init dangerous-repo-reaches-up`, and `cd` into the directory.\n2. Create the stand-in: `echo 'A file outside the working tree, somehow.' >..@outside`\n3. Stage the stand-in: `git add ..@outside`\n4. Edit the index: `env LC_ALL=C sed -i.orig 's|\\.\\.@outside|../outside|' .git/index`\n5. Commit: `git commit -m 'Initial commit'`\n6. *Optionally*, push to a private remote.\n\nThen, as above, on the same or another machine, clone the repository with a `gix clone \u2026` command. Observe that a file named `outside` is present alongside (not inside) the cloned directory.\n\n### Impact\n\nAny use of `gix` or another application that makes use of `gix-worktree-state`, or otherwise relies on `gix-fs` and `gix-worktree` for validation, is affected, if used to clone untrusted repositories. The above description focuses on code execution, as that leads to a complete loss of confidentiality, integrity, and availability, but creating files outside a working tree without attempting to execute code can directly impact integrity as well.\n\nIn use cases where no untrusted repository is ever cloned, this vulnerability has no impact. Furthermore, the impact of this vulnerability *may* be lower when `gix` is used to clone a repository for CI/CD purposes, even if untrusted, since in such uses the environment is usually isolated and arbitrary code is usually run deliberately from the repository with necessary safeguards in place.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0077",
      "package": "better-macro",
      "date": "2021-07-22",
      "url": "https://github.com/raycar5/better-macro/blob/24ff1702397b9c19bbfa4c660e2316cd77d3b900/src/lib.rs#L36-L38",
      "categories": [
        "code-execution"
      ],
      "keywords": [
        "rce",
        "proc-macro"
      ],
      "aliases": [
        "CVE-2021-38196",
        "GHSA-79wf-qcqv-r22r"
      ]
    },
    "affected": {
      "functions": {
        "better_macro::println": [
          "> 1.0.0"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `better-macro` has deliberate RCE to prove a point\n\n[better-macro](https://crates.io/crates/better-macro) is a fake crate which is\n\"Proving A Point\" that proc-macros can run arbitrary code. This is not a particularly\nnovel or interesting observation.\n\nIt currently opens `https://github.com/raycar5/better-macro/blob/master/doc/hi.md`\nwhich doesn't appear to have any malicious content, but there's no guarantee that\nwill remain the case.\n\nThis crate has no useful functionality, and should not be used.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0099",
      "package": "aovec",
      "aliases": [
        "CVE-2020-36207",
        "GHSA-g489-xrw3-3v8w"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-10",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Aovec<T> lacks bound on its Send and Sync traits allowing data races\n\n`aovec::Aovec<T>` is a vector type that implements `Send` and `Sync` for all\ntypes `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0048",
      "package": "intaglio",
      "date": "2023-07-26",
      "url": "https://github.com/artichoke/intaglio/pull/236",
      "references": [
        "https://github.com/artichoke/intaglio/issues/235",
        "https://github.com/artichoke/intaglio/pull/236",
        "https://github.com/artichoke/intaglio/releases/tag/v1.9.0"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-gch5-hwqf-mxhp"
      ]
    },
    "affected": {
      "functions": {
        "intaglio::SymbolTable::intern": [
          "< 1.9.0"
        ],
        "intaglio::bytes::SymbolTable::intern": [
          "< 1.9.0"
        ],
        "intaglio::cstr::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ],
        "intaglio::osstr::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ],
        "intaglio::path::SymbolTable::intern": [
          "< 1.9.0, >= 1.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 1.9.0"
      ]
    },
    "text": "\n\n# Unsoundness in `intern` methods on `intaglio` symbol interners\n\nAffected versions of this crate have a stacked borrows violation when creating\nreferences to interned contents. All interner types are affected.\n\nThe flaw was corrected in version 1.9.0 by reordering move and borrowing\noperations and storing interned contents by raw pointer instead of as a `Box`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0062",
      "package": "miscreant",
      "date": "2021-02-28",
      "informational": "unmaintained",
      "url": "https://github.com/miscreant/miscreant.rs/commit/5d921f579e0c2b9960d472cf377b8487d97fbcec"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# project abandoned; migrate to the `aes-siv` crate\n\nThe Miscreant project has been abandoned and archived.\n\nThe Rust implementation has been adapted into the new `aes-siv` crate which\nimplements both the AES-CMAC-SIV and AES-PMAC-SIV constructions:\n\n<https://github.com/RustCrypto/AEADs/tree/master/aes-siv>\n\nPlease migrate to the `aes-siv` crate.\n\nAlternatively see the `aes-gcm-siv` crate for a newer, faster construction\nwhich provides similar properties:\n\n<https://github.com/RustCrypto/AEADs/tree/master/aes-gcm-siv>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0074",
      "package": "zerocopy",
      "date": "2023-12-14",
      "url": "https://github.com/google/zerocopy/issues/716",
      "keywords": [
        "ref",
        "refcell",
        "mutable-aliasing"
      ],
      "aliases": [
        "GHSA-3mv5-343c-w2qg",
        "GHSA-rjhf-4mh8-9xjq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.9, < 0.3.0",
        ">= 0.3.2, < 0.4.0",
        ">= 0.4.1, < 0.5.0",
        ">= 0.5.2, < 0.6.0",
        ">= 0.6.6, < 0.7.0",
        ">= 0.7.31"
      ],
      "unaffected": [
        "< 0.2.2"
      ]
    },
    "affected": {
      "functions": {
        "zerocopy::Ref::into_ref": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_mut": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_slice": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ],
        "zerocopy::Ref::into_mut_slice": [
          ">= 0.2.2, < 0.2.9",
          ">= 0.3.0, < 0.3.2",
          ">= 0.4.0, < 0.4.1",
          ">= 0.5.0, < 0.5.2",
          ">= 0.6.0, < 0.6.6",
          ">= 0.7.0, < 0.7.31"
        ]
      }
    },
    "text": "\n\n# Some Ref methods are unsound with some type parameters\n\nThe `Ref` methods `into_ref`, `into_mut`, `into_slice`, and `into_slice_mut` are unsound\nand may allow safe code to exhibit undefined behavior when used with `Ref<B, T>` where `B`\nis [`cell::Ref`](https://doc.rust-lang.org/core/cell/struct.Ref.html) or\n[`cell::RefMut`](https://doc.rust-lang.org/core/cell/struct.RefMut.html). Note that these\nmethods remain sound when used with `B` types other than `cell::Ref` or `cell::RefMut`.\n\nSee https://github.com/google/zerocopy/issues/716 for a more in-depth analysis.\n\nThe current plan is to yank the affected versions soon. See\nhttps://github.com/google/zerocopy/issues/679 for more detail.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0121",
      "package": "crypto2",
      "date": "2021-10-08",
      "url": "https://github.com/shadowsocks/crypto2/issues/27",
      "informational": "unsound",
      "keywords": [
        "crypto",
        "alignment",
        "unsound"
      ],
      "aliases": [
        "CVE-2021-45709",
        "GHSA-9hfg-pxr6-q4vp",
        "GHSA-pmcv-mgcf-rvxg"
      ]
    },
    "affected": {
      "functions": {
        "crypto2::streamcipher::Chacha20::encrypt_slice": [
          "*"
        ],
        "crypto2::streamcipher::Chacha20::decrypt_slice": [
          "*"
        ],
        "crypto2::streamcipher::xor_si512_inplace": [
          "*"
        ]
      }
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Non-aligned u32 read in Chacha20 encryption and decryption\nThe implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to `std::slice::from_raw_parts_mut`, which breaks the contract and introduces undefined behavior.\n\nThis affects Chacha20 encryption and decryption in crypto2.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0011",
      "package": "fil-ocl",
      "aliases": [
        "CVE-2021-25908",
        "GHSA-x3v2-fgr6-3wmm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-04",
      "url": "https://github.com/cogciprocate/ocl/issues/194",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.12.0"
      ]
    },
    "text": "\n\n# EventList's From<EventList> conversions can double drop on panic.\n\nAffected versions of this crate read from a container using `ptr::read` in\n`From<EventList>`, and then call a user specified `Into<Event>` function.\n\nThis issue can result in a double-free if the user provided function panics.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0082",
      "package": "warp",
      "date": "2022-01-14",
      "url": "https://github.com/seanmonstar/warp/issues/937",
      "categories": [
        "file-disclosure"
      ],
      "keywords": [
        "directory traversal",
        "http"
      ],
      "aliases": [
        "GHSA-8v4j-7jgf-5rg9"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.3"
      ]
    },
    "text": "\n\n# Improper validation of Windows paths could lead to directory traversal attack\n\nPath resolution in `warp::filters::fs::dir` didn't correctly validate Windows paths\nmeaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed\nand respond with the contents of `c:/windows/web/screen/img101.png`. Thus users\ncould potentially read files anywhere on the filesystem.\n\nThis only impacts Windows. Linux and other unix likes are not impacted by this.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0343",
      "package": "nano-id",
      "date": "2024-06-03",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L",
      "aliases": [
        "GHSA-2hfw-w739-p7x5",
        "GHSA-9hc7-6w9r-wj94",
        "CVE-2024-36400"
      ]
    },
    "affected": {
      "functions": {
        "nano_id::base58": [
          "< 0.4.0"
        ],
        "nano_id::base62": [
          "< 0.4.0"
        ],
        "nano_id::gen": [
          "< 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Reduced entropy due to inadequate character set usage\n\n## Description\n\nAffected versions of the nano-id crate incorrectly generated IDs using a reduced character set in the `nano_id::base62` and `nano_id::base58` functions. Specifically, the `base62` function used a character set of 32 symbols instead of the intended 62 symbols, and the `base58` function used a character set of 16 symbols instead of the intended 58 symbols. Additionally, the `nano_id::gen` macro is also affected when a custom character set that is not a power of 2 in size is specified.\n\nIt should be noted that `nano_id::base64` is not affected by this vulnerability.\n\n## Impact\n\nThis can result in a significant reduction in entropy, making the generated IDs predictable and vulnerable to brute-force attacks when the IDs are used in security-sensitive contexts such as session tokens or unique identifiers.\n\n## Patches\n\nThe flaws were corrected in commit [a9022772b2f1ce38929b5b81eccc670ac9d3ab23](https://github.com/viz-rs/nano-id/commit/a9022772b2f1ce38929b5b81eccc670ac9d3ab23) by updating the the `nano_id::gen` macro to use all specified characters correctly.\n\n## PoC\n\n```rust\nuse std::collections::BTreeSet;\n\nfn main() {\n    test_base58();\n    test_base62();\n}\n\nfn test_base58() {\n    let mut produced_symbols = BTreeSet::new();\n\n    for _ in 0..100_000 {\nid = \"RUSTSEC-2024-0343\"\n        for c in id.chars() {\n            produced_symbols.insert(c);\n        }\n    }\n\n    println!(\n        \"{} symbols generated from nano_id::base58\",\n        produced_symbols.len()\n    );\n}\n\nfn test_base62() {\n    let mut produced_symbols = BTreeSet::new();\n\n    for _ in 0..100_000 {\nid = \"RUSTSEC-2024-0343\"\n        for c in id.chars() {\n            produced_symbols.insert(c);\n        }\n    }\n\n    println!(\n        \"{} symbols generated from nano_id::base62\",\n        produced_symbols.len()\n    );\n}\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0133",
      "package": "cargo-download",
      "date": "2021-12-25",
      "url": "https://github.com/Xion/cargo-download",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# cargo-download is unmaintained\n\nThe cargo download subcommand (via cargo-download crate) is broken and maintainer has disappeared from GitHub and hasn't had any commits for a year. \n\nUsing this downloader will result to corrupted crates.\n\nMaintainer has not responded to maintenance takeover.\n\nJust use wget / curl directly.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0066",
      "package": "evm-core",
      "date": "2021-05-11",
      "url": "https://github.com/rust-blockchain/evm",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "GHSA-773q-5334-5gf9"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.26.1",
        "0.25.1",
        "0.24.1",
        "0.23.1",
        "0.21.1"
      ]
    },
    "text": "\n\n# Denial of service on EVM execution due to memory over-allocation\n\nPrior to the patch, when executing specific EVM opcodes related\nto memory operations that use `evm_core::Memory::copy_large`, the\ncrate can over-allocate memory when it is not needed, making it\npossible for an attacker to perform denial-of-service attack.\n\nThe flaw was corrected in commit `19ade85`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0010",
      "package": "enum-map",
      "date": "2022-02-17",
      "url": "https://gitlab.com/KonradBorowski/enum-map/-/blob/master/CHANGELOG.md#version-202",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-rxhx-9fj6-6h2m"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.0.2"
      ],
      "unaffected": [
        "< 2.0.0-2"
      ]
    },
    "text": "\n\n# enum_map macro can cause UB when `Enum` trait is incorrectly implemented\n\nAffected versions of this crate did not properly check the length of an enum when using `enum_map!` macro, trusting user-provided length.\n\nWhen the `LENGTH` in the `Enum` trait does not match the array length in the `EnumArray` trait, this can result in the initialization of the enum map with uninitialized types, which in turn can allow an attacker to execute arbitrary code.\n\nThis problem can only occur with a manual implementation of the Enum trait, it will never occur for enums that use `#[derive(Enum)]`.\n\nExample code that triggers this vulnerability looks like this:\n\n```rust\nenum E {\n    A,\n    B,\n    C,\n}\n\nimpl Enum for E {\n    const LENGTH: usize = 2;\n\n    fn from_usize(value: usize) -> E {\n        match value {\n            0 => E::A,\n            1 => E::B,\n            2 => E::C,\n            _ => unimplemented!(),\n        }\n    }\n\n    fn into_usize(self) -> usize {\n        self as usize\n    }\n}\n\nimpl<V> EnumArray<V> for E {\n    type Array = [V; 3];\n}\n\nlet _map: EnumMap<E, String> = enum_map! { _ => \"Hello, world!\".into() };\n```\n\nThe flaw was corrected in commit [b824e23](https://gitlab.com/KonradBorowski/enum-map/-/commit/b824e232f2fb47837740070096ac253df8e80dfc) by putting `LENGTH` property on sealed trait for macro to read.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0118",
      "package": "tiny_future",
      "date": "2020-12-08",
      "url": "https://github.com/KizzyCode/tiny_future/issues/1",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36438",
        "GHSA-fg42-vwxx-xx5j",
        "GHSA-m296-j53x-xv95"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Future<T> lacks bounds on Send and Sync.\n\n`tiny_future` contains a light-weight implementation of `Future`s. The `Future`\ntype it has lacked bound on its `Send` and `Sync` traits.\n\nThis allows for a bug where non-thread safe types such as `Cell` can be used in\n`Future`s and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `c791919` by adding trait bounds to `Future`'s\n`Send` and `Sync`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0083",
      "package": "derive-com-impl",
      "date": "2021-01-20",
      "url": "https://github.com/Connicpu/com-impl/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "com",
        "queryinterface",
        "addref"
      ],
      "aliases": [
        "CVE-2021-45681",
        "GHSA-9rg7-3j4f-cf4x",
        "GHSA-w4cc-pc2h-whcj"
      ]
    },
    "affected": {
      "functions": {
        "derive_com_impl::derive_com_impl": [
          "<= 0.1.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.2"
      ]
    },
    "text": "\n\n# QueryInterface should call AddRef before returning pointer\n\nAffected version of this crate, which is a required dependency in com-impl, \nprovides a faulty implementation of the `IUnknown::QueryInterface` method.\n\n`QueryInterface` implementation must call `IUnknown::AddRef` before returning the pointer,\nas describe in this documentation:\n<https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)>\n\nAs it is not incrementing the refcount as expected, the following calls to `IUnknown::Release` method \nwill cause WMI to drop reference to the interface, and can lead to invalid reference.\n\nThis is documented in <https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting>\n\nThere is no simple workaround, as you can't know how many time QueryInterface will be called.\nThe only way to quick fix this is to use the macro expanded version of the code and modify \nthe QueryInterface method to add the AddRef call yourself.\n\nThe issue was corrected in commit `9803f31fbd1717d482d848f041044d061fca6da7`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0007",
      "package": "av-data",
      "aliases": [
        "CVE-2021-25904",
        "GHSA-352p-rhvq-7g78"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-07",
      "url": "https://github.com/rust-av/rust-av/issues/136",
      "categories": [
        "memory-exposure",
        "privilege-escalation"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# `Frame::copy_from_raw_parts` can lead to segfault without `unsafe`\n\n`fn Frame::copy_from_raw_parts()` is a safe API that can take a\nraw pointer and dereference it. It is possible to read arbitrary memory address\nwith an arbitrarily fed pointer. This allows the safe API to access & read\narbitrary address in memory. Feeding an invalid memory address pointer to\nthe API may also cause the program to segfault.\n\nThe flaw was corrected in https://github.com/rust-av/rust-av/pull/137,\nby removing the API `fn Frame::copy_from_raw_parts()`.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0022",
      "package": "temporary",
      "date": "2018-08-22",
      "url": "https://github.com/stainless-steel/temporary/issues/2",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "uninitialized-memory"
      ],
      "aliases": [
        "GHSA-2jq9-6xx7-3h29"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.6.4"
      ],
      "unaffected": [
        "< 0.3.0"
      ]
    },
    "text": "\n\n# Use of uninitialized memory in temporary\n\nUninit memory is used as a RNG seed in temporary\n\nThe following function is used as a way to get entropy from the system, which does operations on and exposes uninit memory, which is UB.\n\n```rust\nfn random_seed(_: &Path, _: &str) -> [u64; 2] {\n    use std::mem::uninitialized as rand;\n    unsafe { [rand::<u64>() ^ 0x12345678, rand::<u64>() ^ 0x87654321] }\n}\n```\n\nThis has been resolved in the 0.6.4 release.\n\nThe crate is not intended to be used outside of a testing environment.\n\nFor a general purpose crate to create temporary directories, [`tempfile`](https://crates.io/crates/tempfile) is an alternative for this crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0050",
      "package": "reorder",
      "aliases": [
        "CVE-2021-29941",
        "CVE-2021-29942",
        "GHSA-3h87-v52r-p9rg",
        "GHSA-jpwg-6gf5-5vh9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-24",
      "url": "https://github.com/tiby312/reorder/issues/1",
      "keywords": [
        "memory-corruption",
        "out-of-bounds"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.1.0"
      ]
    },
    "text": "\n\n# swap_index can write out of bounds and return uninitialized memory\n\n`swap_index` takes an iterator and swaps the items with their corresponding\nindexes. It reserves capacity and sets the length of the vector based on the\n`.len()` method of the iterator.\n\nIf the `len()` returned by the iterator is larger than the actual number of\nelements yielded, then `swap_index` creates a vector containing uninitialized\nmembers. If the `len()` returned by the iterator is smaller than the actual\nnumber of members yielded, then `swap_index` can write out of bounds past\nits allocated vector.\n\nAs noted by the Rust documentation, [`len()`](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len)\nand `size_hint()` are primarily meant for optimization and incorrect values\nfrom their implementations should not lead to memory safety violations.\n\n\n# Patch\n\nA new version crate was pushed that marks this function as unsafe.\n\nreorder = \"1.1.0\"\n\nPrevious versions have also been yanked from crates.io.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0054",
      "package": "wee_alloc",
      "date": "2022-05-11",
      "url": "https://github.com/rustwasm/wee_alloc/issues/107",
      "references": [
        "https://www.reddit.com/r/rust/comments/x1cle0/dont_use_wee_alloc_in_production_code_targeting/",
        "https://github.com/rustwasm/wee_alloc/issues/85",
        "https://github.com/rustwasm/wee_alloc/issues/106"
      ],
      "informational": "unmaintained",
      "aliases": [
        "GHSA-rc23-xxgq-x27g"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# wee_alloc is Unmaintained\n\nTwo of the maintainers have indicated that the crate may not be maintained.\n\nThe crate has open issues including memory leaks and may not be suitable for production use.\n\nIt may be best to switch to the default Rust standard allocator on wasm32 targets.\n\nLast release seems to have been three years ago.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - Rust standard [default allocator] on wasm32-target\n\n## Honorable Mention(s)\n\n The below may serve to educate on potential future alternatives:\n\n - [lol_alloc](https://crates.io/crates/lol_alloc)\n\n[default allocator]: https://github.com/alexcrichton/dlmalloc-rs\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0089",
      "package": "raw-cpuid",
      "date": "2021-01-20",
      "url": "https://github.com/gz/rust-cpuid/issues/43",
      "categories": [
        "memory-corruption",
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2021-45687",
        "GHSA-jf5h-cf95-w759",
        "GHSA-w428-f65r-h4q2"
      ]
    },
    "versions": {
      "patched": [
        ">= 9.1.1"
      ],
      "unaffected": [
        "<= 3.1.0"
      ]
    },
    "text": "\n\n# Optional `Deserialize` implementations lacking validation\n\nWhen activating the non-default feature `serialize`, most structs implement\n`serde::Deserialize` without sufficient validation. This allows breaking\ninvariants in safe code, leading to:\n\n* Undefined behavior in `as_string()` methods (which use\n  `std::str::from_utf8_unchecked()` internally).\n* Panics due to failed assertions.\n\nSee https://github.com/gz/rust-cpuid/issues/43.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0013",
      "package": "raw-cpuid",
      "aliases": [
        "CVE-2021-26306",
        "CVE-2021-26307",
        "GHSA-hvqc-pc78-x9wh",
        "GHSA-jrf8-cmgg-gv2m"
      ],
      "date": "2021-01-20",
      "url": "https://github.com/RustSec/advisory-db/pull/614",
      "categories": [
        "memory-corruption",
        "denial-of-service"
      ]
    },
    "versions": {
      "patched": [
        ">= 9.0.0"
      ]
    },
    "affected": {
      "arch": [
        "x86",
        "x86_64"
      ]
    },
    "text": "\n\n# Soundness issues in `raw-cpuid`\n\n## Undefined behavior in `as_string()` methods\n\n`VendorInfo::as_string()`, `SoCVendorBrand::as_string()`,\nand `ExtendedFunctionInfo::processor_brand_string()` construct byte slices\nusing `std::slice::from_raw_parts()`, with data coming from\n`#[repr(Rust)]` structs. This is always undefined behavior.\n\nSee https://github.com/gz/rust-cpuid/issues/40.\n\nThis flaw has been fixed in v9.0.0, by making the relevant structs\n`#[repr(C)]`.\n\n## `native_cpuid::cpuid_count()` is unsound\n\n`native_cpuid::cpuid_count()` exposes the unsafe `__cpuid_count()` intrinsic\nfrom `core::arch::x86` or `core::arch::x86_64` as a safe function, and uses\nit internally, without checking the\n[safety requirement](https://doc.rust-lang.org/core/arch/index.html#overview):\n\n> The CPU the program is currently running on supports the function being\n> called.\n\nCPUID is available in most, but not all, x86/x86_64 environments. The crate\ncompiles only on these architectures, so others are unaffected.\n\nThis issue is mitigated by the fact that affected programs are expected\nto crash deterministically every time.\n\nSee https://github.com/gz/rust-cpuid/issues/41.\n\nThe flaw has been fixed in v9.0.0, by intentionally breaking compilation\nwhen targeting SGX or 32-bit x86 without SSE. This covers all affected CPUs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0130",
      "package": "lru",
      "date": "2021-12-21",
      "url": "https://github.com/jeromefroe/lru-rs/issues/120",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "use-after-free"
      ],
      "aliases": [
        "CVE-2021-45720",
        "GHSA-qqmc-hwqp-8g2w",
        "GHSA-v362-2895-h9r2"
      ]
    },
    "affected": {
      "functions": {
        "lru::LruCache::iter": [
          "< 0.7.1"
        ],
        "lru::LruCache::iter_mut": [
          "< 0.7.1"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.7.1"
      ]
    },
    "text": "\n\n# Use after free in lru crate\n\nLru crate has use after free vulnerability.\n\nLru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0002",
      "package": "tar",
      "aliases": [
        "CVE-2018-20990",
        "GHSA-2367-c296-3mp2"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2018-06-29",
      "keywords": [
        "file-overwrite"
      ],
      "url": "https://github.com/alexcrichton/tar-rs/pull/156"
    },
    "versions": {
      "patched": [
        ">= 0.4.16"
      ],
      "unaffected": []
    },
    "text": "\n\n# Links in archives can overwrite any existing file\n\nWhen unpacking a tarball with the `unpack_in`-family of functions it's intended\nthat only files within the specified directory are able to be written. Tarballs\nwith hard links or symlinks, however, can be used to overwrite any file on the\nfilesystem.\n\nTarballs can contain multiple entries for the same file. A tarball which first\ncontains an entry for a hard link or symlink pointing to any file on the\nfilesystem will have the link created, and then afterwards if the same file is\nlisted in the tarball the hard link will be rewritten and any file can be\nrewritten on the filesystem.\n\nThis has been fixed in https://github.com/alexcrichton/tar-rs/pull/156 and is\npublished as `tar` 0.4.16. Thanks to Max Justicz for discovering this and\nemailing about the issue!\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0080",
      "package": "tar",
      "aliases": [
        "CVE-2021-38511",
        "GHSA-62jx-8vmh-4mcw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2021-07-19",
      "url": "https://github.com/alexcrichton/tar-rs/issues/238"
    },
    "versions": {
      "patched": [
        ">= 0.4.36"
      ]
    },
    "affected": {
      "functions": {
        "tar::Archive::unpack": [
          "< 0.4.36"
        ]
      }
    },
    "text": "\n\n# Links in archive can create arbitrary directories\n\nWhen unpacking a tarball that contains a symlink the `tar` crate may create\ndirectories outside of the directory it's supposed to unpack into.\n\nThe function errors when it's trying to create a file, but the folders are\nalready created at this point.\n\n```rust\nuse std::{io, io::Result};\nuse tar::{Archive, Builder, EntryType, Header};\n\nfn main() -> Result<()> {\n    let mut buf = Vec::new();\n\n    {\n        let mut builder = Builder::new(&mut buf);\n\n        // symlink: parent -> ..\n        let mut header = Header::new_gnu();\n        header.set_path(\"symlink\")?;\n        header.set_link_name(\"..\")?;\n        header.set_entry_type(EntryType::Symlink);\n        header.set_size(0);\n        header.set_cksum();\n        builder.append(&header, io::empty())?;\n\n        // file: symlink/exploit/foo/bar\n        let mut header = Header::new_gnu();\n        header.set_path(\"symlink/exploit/foo/bar\")?;\n        header.set_size(0);\n        header.set_cksum();\n        builder.append(&header, io::empty())?;\n\n        builder.finish()?;\n    };\n\n    Archive::new(&*buf).unpack(\"demo\")\n}\n```\n\nThis has been fixed in https://github.com/alexcrichton/tar-rs/pull/259 and is\npublished as `tar` 0.4.36. Thanks to Martin Michaelis (@mgjm) for discovering\nand reporting this, and Nikhil Benesch (@benesch) for the fix!\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0148",
      "package": "nphysics3d",
      "date": "2021-01-29",
      "url": "https://github.com/dimforge/nphysics",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# nphysics3d is unmaintained\n\nThe maintainer has advised that this crate is passively-maintained and that it\nis being superseded by the [Rapier](https://github.com/dimforge/rapier) project.\n"
  },
  {
    "advisory": {
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "date": "2020-05-11",
      "id": "RUSTSEC-2020-0021",
      "package": "rio",
      "aliases": [
        "CVE-2020-35876",
        "GHSA-8rc5-mr4f-m243"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "url": "https://github.com/spacejam/rio/issues/11"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# rio allows a use-after-free buffer access when a future is leaked\n\nWhen a `rio::Completion` is leaked, its drop code will not run. The drop code\nis responsible for waiting until the kernel completes the I/O operation into, or\nout of, the buffer borrowed by `rio::Completion`. Leaking the struct will allow\none to access and/or drop the buffer, which can lead to a use-after-free,\ndata races or leaking secrets.\n\nUpstream is not interested in fixing the issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0005",
      "package": "cbox",
      "aliases": [
        "CVE-2020-35860",
        "GHSA-3vjm-36rr-7qrq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-03-19",
      "url": "https://github.com/TomBebbington/cbox-rs/issues/2"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# CBox API allows to de-reference raw pointers without `unsafe` code\n\n`CBox` and `CSemiBox` are part of the public API of the cbox crate\nand they allow to create smart pointers from raw pointers and de-reference\nthem without the need of `unsafe` code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0139",
      "package": "ansi_term",
      "date": "2021-08-18",
      "url": "https://github.com/ogham/rust-ansi-term/issues/72",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# ansi_term is Unmaintained\n\nThe maintainer has advised that this crate is deprecated and will not receive any maintenance.\n\nThe crate does not seem to have much dependencies and may or may not be ok to use as-is.\n\nLast release seems to have been three years ago.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [ansiterm](https://crates.io/crates/ansiterm)\n - [anstyle](https://github.com/epage/anstyle)\n - [console](https://crates.io/crates/console)\n - [nu-ansi-term](https://crates.io/crates/nu-ansi-term)\n - [owo-colors](https://crates.io/crates/owo-colors)\n - [stylish](https://crates.io/crates/stylish)\n - [yansi](https://crates.io/crates/yansi)\n\n## Dependency Specific Migration(s)\n\n - [structopt, clap2](https://github.com/clap-rs/clap/discussions/4172)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0029",
      "package": "crossbeam",
      "date": "2022-06-07",
      "categories": [
        "thread-safety",
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/98",
      "aliases": [
        "GHSA-rwf4-gx62-rqfw"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# `MsQueue` `push`/`pop` use the wrong orderings\n\nAffected versions of this crate use orderings which are too weak to support this data structure.\nIt is likely this has caused memory corruption in the wild: <https://github.com/crossbeam-rs/crossbeam/issues/97#issuecomment-412785919>.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0009",
      "package": "crossbeam",
      "aliases": [
        "CVE-2018-20996",
        "GHSA-c3cw-c387-pj65"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2018-12-09",
      "keywords": [
        "concurrency",
        "memory-management",
        "memory-corruption"
      ],
      "url": "https://github.com/crossbeam-rs/crossbeam-epoch/issues/82"
    },
    "versions": {
      "patched": [
        ">= 0.4.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# MsQueue and SegQueue suffer from double-free\n\nEven if an element is popped from a queue, crossbeam would run its\ndestructor inside the epoch-based garbage collector. This is a source\nof double frees.\n\nThe flaw was corrected by wrapping elements inside queues in a\n`ManuallyDrop`.\n\nThanks to @c0gent for reporting the issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0020",
      "package": "crossbeam",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-8gj8-hv75-gp94"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# `SegQueue` creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0064",
      "package": "ffi_utils",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_ffi_utils/pull/45"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_ffi_utils`\n\nThis crate has been renamed from `ffi_utils` to `sn_ffi_utils`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_ffi_utils>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0004",
      "package": "lazy-init",
      "aliases": [
        "CVE-2021-25901",
        "GHSA-w47j-hqpf-qw9w"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
      "date": "2021-01-17",
      "categories": [
        "memory-corruption"
      ],
      "url": "https://github.com/khuey/lazy-init/issues/9"
    },
    "versions": {
      "patched": [
        "> 0.4.0"
      ]
    },
    "text": "\n\n# Missing Send bound for Lazy\n\nAll current versions of this crate allow causing data races in safe code.\n\nThe flaw will be fixed in the next release.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0072",
      "package": "futures-intrusive",
      "aliases": [
        "CVE-2020-35915",
        "GHSA-4hjg-cx88-g9f9"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-10-31",
      "url": "https://github.com/Matthias247/futures-intrusive/issues/53",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# GenericMutexGuard allows data races of non-Sync types across threads\n\n`GenericMutexGuard<T>` was given the `Sync` auto trait as long as `T` is `Send`\ndue to its contained members. However, since the guard is supposed to represent\nan **acquired lock** and allows concurrent access to the underlying data from\ndifferent threads, it should only be `Sync` when the underlying data is.\n\nThis is a soundness issue and allows data races, potentially leading to crashes\nand segfaults from safe Rust code.\n\nThe flaw was corrected by adding a `T: Send + Sync` bound for\n`GenericMutexGuard`'s `Sync` trait.\n\nThis bug is [similar to one](https://github.com/rust-lang/rust/issues/41622) in\n`std::sync::Mutex`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0021",
      "package": "crossbeam-queue",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-6888-wf7j-34jq"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "text": "\n\n# `SegQueue` creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0086",
      "package": "flumedb",
      "date": "2021-01-07",
      "url": "https://github.com/sunrise-choir/flumedb-rs/issues/10",
      "references": [
        "https://github.com/sunrise-choir/flumedb-rs/pull/12"
      ],
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45684",
        "GHSA-p46c-w9m3-7qr2",
        "GHSA-p56p-gq3f-whg8"
      ]
    },
    "versions": {
      "patched": [
        ">=0.1.6"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB ( `read_entry()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\nThere are two of such cases (`go_offset_log::read_entry()` & `offset_log::read_entry()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0087",
      "package": "try-mutex",
      "aliases": [
        "CVE-2020-35924",
        "GHSA-64j8-7gp2-xjx5"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-17",
      "url": "https://github.com/mpdn/try-mutex/issues/2",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.0"
      ]
    },
    "text": "\n\n# TryMutex<T> allows sending non-Send type across threads\n\nAffected versions of this crate unconditionally implemented Sync trait for `TryMutex<T>` type.\n\nThis allows users to put non-Send `T` type in `TryMutex` and send it to another thread, which can cause a data race.\n\nThe flaw was corrected in the 0.3.0 release by adding `T: Send` bound for the Sync trait implementation.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0146",
      "package": "twoway",
      "date": "2021-05-20",
      "url": "https://github.com/bluss/twoway",
      "references": [
        "https://github.com/bluss/twoway/commit/e99b3c718df1117ad7f54c33f6540c8f46cc17dd"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Crate `twoway` deprecated by the author\n\nThe commit [`e99b3c7`](https://github.com/bluss/twoway/commit/e99b3c718df1117ad7f54c33f6540c8f46cc17dd) releasing version 0.2.2 explicitly deprecates `twoway` in favour of [`memchr`](https://crates.io/crates/memchr) crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0044",
      "package": "atom",
      "aliases": [
        "CVE-2020-35897",
        "GHSA-9cg2-2j2h-59v9"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-09-21",
      "informational": "unsound",
      "url": "https://github.com/slide-rs/atom/issues/13",
      "categories": [
        "thread-safety"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.6"
      ]
    },
    "text": "\n\n# Unsafe Send implementation in Atom allows data races\n\nThe `atom` crate contains a security issue revolving around its implementation\nof the Send trait. It incorrectly allows any arbitrary type to be sent across\nthreads potentially leading to use-after-free issues through memory races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2017-0005",
      "package": "cookie",
      "aliases": [
        "CVE-2017-18589",
        "GHSA-vjrq-cg9x-rfjp"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2017-05-06",
      "keywords": [
        "crash"
      ],
      "url": "https://github.com/alexcrichton/cookie-rs/pull/86"
    },
    "versions": {
      "patched": [
        "< 0.6.0",
        "^0.6.2",
        ">= 0.7.6"
      ]
    },
    "text": "\n\n# Large cookie Max-Age values can cause a denial of service\n\nAffected versions of this crate use the `time` crate and the method\n`Duration::seconds` to parse the `Max-Age` duration cookie setting. This method\nwill panic if the value is greater than 2^64/1000 and less than or equal to\n2^64, which can result in denial of service for a client or server.\n\nThis flaw was corrected by explicitly checking for the `Max-Age` being in this\ninteger range and clamping the value to the maximum duration value.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0023",
      "package": "rulinalg",
      "aliases": [
        "CVE-2020-35879",
        "GHSA-q2gj-9r85-p832"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-02-11",
      "url": "https://github.com/AtheMathmo/rulinalg/issues/201"
    },
    "affected": {
      "functions": {
        "rulinalg::matrix::RowMut::raw_slice": [
          ">= 0.4.0"
        ],
        "rulinalg::matrix::RowMut::raw_slice_mut": [
          ">= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Lifetime boundary for `raw_slice` and `raw_slice_mut` are incorrect\n\nThe affected version of `rulinalg` has incorrect lifetime boundary definitions\nfor `RowMut::raw_slice` and `RowMut::raw_slice_mut`. They do not conform with\nRust's borrowing rule and allows the user to create multiple mutable references\nto the same location. This may result in unexpected calculation result and data\nrace if both references are used at the same time.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0147",
      "package": "rulinalg",
      "date": "2020-02-11",
      "url": "https://github.com/AtheMathmo/rulinalg/issues/201#issuecomment-584749313",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# rulinalg is unmaintained, use nalgebra instead\n\nThe `rulinalg` crate is no longer maintained, use [nalgebra](https://crates.io/crates/nalgebra)\ninstead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0140",
      "package": "rusttype",
      "date": "2021-04-01",
      "url": "https://gitlab.redox-os.org/redox-os/rusttype/-/issues/148",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# rusttype is Unmaintained\n\nThe maintainer has advised this crate is deprecated and will not\nreceive any maintenance.\n\nThe maintainer has further advised to migrate over to `ab_glyph`.\n\nLast release seems to have been over two years ago.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [ab_glyph](https://crates.io/crates/ab_glyph)\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0151",
      "package": "generator",
      "aliases": [
        "CVE-2020-36471",
        "GHSA-w3g5-2848-2v8r"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-16",
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/27",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.0"
      ]
    },
    "text": "\n\n# Generators can cause data races if non-Send types are used in their generator functions\n\nThe `Generator` type is an iterable which uses a generator function that yields\nvalues. In affected versions of the crate, the provided function yielding values\nhad no `Send` bounds despite the `Generator` itself implementing `Send`.\n\nThe generator function lacking a `Send` bound means that types that are\ndangerous to send across threads such as `Rc` could be sent as part of a\ngenerator, potentially leading to data races.\n\nThis flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)\nby enforcing that the generator function be bound by `Send`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0020",
      "package": "generator",
      "date": "2019-09-06",
      "keywords": [
        "memory-corruption"
      ],
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/9",
      "aliases": [
        "CVE-2019-16144",
        "GHSA-6c65-xcf5-299x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.6.18"
      ]
    },
    "text": "\n\n# fix unsound APIs that could lead to UB\n\nAffected versions of this crate API could use uninitialized memory with some APIs in special\ncases, like use the API in none generator context. This could lead to UB.\nThe flaw was corrected by <https://github.com/Xudong-Huang/generator-rs/issues/9>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/11>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/13>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/14>                                                  \nThis patch fixes all those issues above.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0074",
      "package": "prettytable-rs",
      "date": "2022-12-02",
      "url": "https://github.com/phsym/prettytable-rs/issues/145",
      "informational": "unsound",
      "keywords": [
        "tab",
        "table",
        "format",
        "pretty",
        "print"
      ],
      "aliases": [
        "GHSA-gfgm-chr3-x6px"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.0"
      ]
    },
    "text": "\n\n# Force cast a &Vec<T> to &[T]\n\nIn function `Table::as_ref`, a reference of vector is force cast to slice. There are multiple problems here:\n1. To guarantee the size is correct, we have to first do `Vec::shrink_to_fit`. The function requires a mutable reference, so we have to force cast from immutable to mutable, which is UB.\n2. Even if (1) is sound, `&Vec<T>` and `&[T]` still might not have the same layout. Treating them equally may lead to UB.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0125",
      "package": "simple_asn1",
      "date": "2021-11-14",
      "url": "https://github.com/acw/simple_asn1/issues/27",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "panic",
        "string_slice"
      ],
      "aliases": [
        "CVE-2021-45711",
        "GHSA-3m6f-3gfg-4x56",
        "GHSA-g4h2-4wvh-grc5"
      ]
    },
    "versions": {
      "patched": [
        ">=0.6.1"
      ],
      "unaffected": [
        "<0.6.0"
      ]
    },
    "text": "\n\n# Panic on incorrect date input to `simple_asn1`\n\nVersion 0.6.0 of the `simple_asn1` crate panics on certain malformed\ninputs to its parsing functions, including `from_der` and `der_decode`.\nBecause this crate is frequently used with inputs from the network, this\nshould be considered a security vulnerability.\n\nThe issue occurs when parsing the old ASN.1 \"UTCTime\" time format.  If an\nattacker provides a UTCTime where the first character is ASCII but the\nsecond character is above 0x7f, a string slice operation in the\n`from_der_` function will try to slice into the middle of a UTF-8\ncharacter, and cause a panic.\n\nThis error was introduced in commit\n[`d7d39d709577710e9dc8`](https://github.com/acw/simple_asn1/commit/d7d39d709577710e9dc8833ee57d200eef366db8),\nwhich updated `simple_asn1` to use `time` instead of `chrono` because of\n[`RUSTSEC-2020-159`](https://rustsec.org/advisories/RUSTSEC-2020-0159).\nVersions of `simple_asn1` before 0.6.0 are not affected by this issue.\n\nThe [patch](https://github.com/acw/simple_asn1/pull/28) was applied in\n`simple_asn1` version 0.6.1.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0065",
      "package": "fake_clock",
      "date": "2020-11-02",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_fake_clock/pull/38"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been renamed to `sn_fake_clock`\n\nThis crate has been renamed from `fake_clock` to `sn_fake_clock`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_fake_clock>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0372",
      "package": "ic-cdk",
      "date": "2024-09-05",
      "url": "https://github.com/dfinity/cdk-rs/pull/509",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "canister",
        "icp",
        "cdk"
      ],
      "aliases": [
        "CVE-2024-7884",
        "GHSA-rwq6-crjg-9cpw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        "^0.8.2",
        "^0.9.3",
        "^0.10.1",
        "^0.11.6",
        "^0.12.2",
        "^0.13.5",
        "^0.14.1",
        "^0.15.1",
        ">= 0.16.0"
      ],
      "unaffected": [
        "< 0.8.0"
      ]
    },
    "text": "\n# Memory leak when calling a canister method via `ic_cdk::call`\n\nWhen a canister method is called via `ic_cdk::call*`, a new Future `CallFuture` is created  and can be awaited by the caller to get the execution result. Internally, the state of the Future is tracked and stored in a struct called `CallFutureState`.  A bug in the polling implementation of the `CallFuture` allows multiple references to be held for this internal state and not all references were dropped before the `Future` is resolved. Since we have unaccounted references held, a copy of the internal state ended up being persisted in the canister's heap and thus causing a memory leak. \n\n### Impact\nCanisters built in Rust with `ic_cdk` and `ic_cdk_timers` are affected. If these canisters call a canister method, use timers or heartbeat, they will likely leak a small amount of memory on every such operation. **In the worst case, this could lead to heap memory exhaustion triggered by an attacker.**\n\nMotoko based canisters are not affected by the bug.\n\n### Patches\nThe patch has been backported to all minor versions between `>= 0.8.0, <= 0.15.0`. The patched versions available are `0.8.2, 0.9.3, 0.10.1, 0.11.6, 0.12.2, 0.13.5, 0.14.1, 0.15.1` and their previous versions have been yanked. \n\n### Workarounds\nThere are no known workarounds at the moment. Developers are recommended to upgrade their canister as soon as possible to the latest available patched version of `ic_cdk` to avoid running out of Wasm heap memory. \n\n> Upgrading the canisters (without updating `ic_cdk`) also frees the leaked memory but it's only a temporary solution.\n\n### Referencesas\n- [dfinity/cdk-rs/pull/509](https://github.com/dfinity/cdk-rs/pull/509)\n- [ic_cdk docs](https://docs.rs/ic-cdk/latest/ic_cdk/)\n- [Internet Computer Specification](https://internetcomputer.org/docs/current/references/ic-interface-spec)\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0015",
      "package": "term",
      "date": "2018-11-19",
      "informational": "unmaintained",
      "url": "https://github.com/Stebalien/term/issues/93"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.6.1"
      ]
    },
    "text": "\n\n# term is looking for a new maintainer\n\nThe author of the `term` crate does not have time to maintain it and is looking\nfor a new maintainer.\n\nSome maintained alternatives you can potentially switch to instead, depending\non your needs:\n\n- [`crossterm`](https://github.com/crossterm-rs/crossterm)\n- [`termcolor`](https://crates.io/crates/termcolor)\n- [`yansi`](https://crates.io/crates/yansi)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0079",
      "package": "socket2",
      "date": "2020-11-06",
      "url": "https://github.com/rust-lang/socket2-rs/issues/119",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-35919",
        "CVE-2020-35920",
        "GHSA-458v-4hrf-g3m4",
        "GHSA-c79c-gwph-gqfm"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.3.16"
      ]
    },
    "text": "\n\n# `socket2` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`socket2`](https://crates.io/crates/socket2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0022",
      "package": "portaudio-rs",
      "aliases": [
        "CVE-2019-16881",
        "GHSA-qpjr-ch72-2qq4"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "code-execution",
        "memory-corruption"
      ],
      "date": "2019-09-14",
      "keywords": [
        "audio",
        "ffi"
      ],
      "url": "https://github.com/mvdnes/portaudio-rs/issues/20"
    },
    "versions": {
      "patched": [
        "> 0.3.1"
      ]
    },
    "text": "\n\n# Stream callback function is not unwind safe\n\nAffected versions of this crate is not panic safe within callback functions `stream_callback` and `stream_finished_callback`.\n\nThe call to user-provided closure might panic before a `mem::forget` call, which then causes a use after free that grants attacker to control the callback function pointer.\n\nThis allows an attacker to construct an arbitrary code execution .\n \nThe flaw was reported by Phosphorus15.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0018",
      "package": "qwutils",
      "aliases": [
        "CVE-2021-26954",
        "GHSA-68p4-pjpf-xwcq"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
      "date": "2021-02-03",
      "url": "https://github.com/qwertz19281/rust_utils/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "affected": {
      "functions": {
        "qwutils::imp::vec::VecExt::insert_slice_clone": [
          "< 0.3.1"
        ]
      }
    },
    "text": "\n\n# insert_slice_clone can double drop if Clone panics.\n\nAffected versions of this crate used `ptr::copy` when inserting into the middle\nof a `Vec`. When ownership was temporarily duplicated during this copy, it calls\nthe clone method of a user provided element.\n\nThis issue can result in an element being double-freed if the clone call panics.\n\nCommit `20cb73d` fixed this issue by adding a `set_len(0)` call before\noperating on the vector to avoid dropping the elements during a panic.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0111",
      "package": "may_queue",
      "aliases": [
        "CVE-2020-36217",
        "GHSA-pphf-f93w-gc84"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-10",
      "url": "https://github.com/Xudong-Huang/may/issues/88",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# may_queue's Queue lacks Send/Sync bound for its Send/Sync trait.\n\nAffected versions of `may_queue` implements `Send`/`Sync` for its `Queue` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0024",
      "package": "double-checked-cell",
      "date": "2022-05-11",
      "url": "https://github.com/niklasf/double-checked-cell/commit/9cf94d75316ef441033ce4c80def7c1a8c7643fe",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# double-checked-cell is unmaintained\n\nThe author recommends switching to\n[`once_cell`](https://crates.io/crates/once_cell), which offers a superset\nof the functionality.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0103",
      "package": "autorand",
      "aliases": [
        "CVE-2020-36210",
        "GHSA-cgmg-2v6m-fjg7"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-12-31",
      "url": "https://github.com/mersinvald/autorand-rs/issues/5",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.3"
      ]
    },
    "text": "\n\n# `impl Random` on arrays can lead to dropping uninitialized memory\n\nAffected versions of this crate had a panic safety issue to drop partially uninitialized array of `T` upon panic in a user provided function `T::random()`. Dropping uninitialized `T` can potentially cause memory corruption or undefined behavior.\n\nThe flaw was corrected in commit 565d508 by using `MaybeUninit<T>` to avoid possible dropping of uninitialized memory upon panic.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0337",
      "package": "zip_next",
      "date": "2024-04-20",
      "url": "https://github.com/zip-rs/zip/issues/446",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# The crate `zip_next` has been renamed to `zip`.\n\nPlease switch to the new name. `zip_next` will receive no further releases.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0057",
      "package": "badge",
      "date": "2022-08-31",
      "url": "https://github.com/rust-lang/docs.rs/issues/1813#issuecomment-1232875809",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# badge is Unmaintained\n\nThe maintainer has advised this crate is deprecated and will not receive any maintenance.\n\nThe crate depends on the deprecated `rusttype` crate and won't receive updates\nanymore.\n\n## Possible Alternative(s)\n\n The below list has not been vetted in any way and may or may not contain alternatives;\n\n - [badge-maker](https://crates.io/crates/badge-maker)\n - [badgeland](https://crates.io/crates/badgeland)\n - [badgen](https://crates.io/crates/badgen)\n - [badgers](https://crates.io/crates/badgers) (API compatible fork of the `badge` crate using `ab_glyph` as a replacement for `rusttype`)\n - [rsbadges](https://crates.io/crates/rsbadges) (used deprecated `rusttype`)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0071",
      "package": "grep-cli",
      "date": "2021-06-12",
      "url": "https://github.com/BurntSushi/ripgrep/issues/1773",
      "categories": [
        "code-execution"
      ],
      "keywords": [
        "windows",
        "ripgrep",
        "PATH",
        "arbitrary",
        "binary"
      ],
      "aliases": [
        "CVE-2021-3013",
        "GHSA-g4xg-fxmg-vcg5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.6"
      ],
      "unaffected": []
    },
    "affected": {
      "os": [
        "windows"
      ],
      "functions": {
        "grep_cli::DecompressionReader::new": [
          "< 0.1.6"
        ]
      }
    },
    "text": "\n\n# `grep-cli` may run arbitrary executables on Windows\n\nOn Windows in versions of `grep-cli` prior to `0.1.6`, it's possible for some\nof the routines to execute arbitrary executables. In particular, a quirk of\nthe Windows process execution API is that it will automatically consider the\ncurrent directory before other directories when resolving relative binary\nnames. Therefore, if you use `grep-cli` to read decompressed files in an\nuntrusted directory with that directory as the CWD, a malicious actor to could\nput, e.g., a `gz.exe` binary in that directory and `grep-cli` will use the\nmalicious actor's version of `gz.exe` instead of the system's.\n\nThis is also technically possible on Unix as well, but only if the `PATH`\nvariable contains `.`. Conventionally, they do not.\n\nA `DecompressionReader` has been fixed to automatically resolve binary names\nusing `PATH`, instead of relying on the Windows API to do it.\n\nIf you use `grep-cli`'s `CommandReader` with a `std::process::Command` value\non Windows, then it is recommended to either construct the `Command` with an\nabsolute binary name, or use `grep-cli`'s new\n[`resolve_binary`](https://docs.rs/grep-cli/0.1.6/grep_cli/fn.resolve_binary.html)\nhelper function.\n\nTo be clear, `grep-cli 0.1.6` mitigates this issue in two ways:\n\n* A `DecompressionReader` will resolve decompression programs to absolute\npaths automatically using the `PATH` environment variable, instead of relying\non Windows APIs to do it (which would result in the undesirable behavior of\nchecking the CWD for a program first).\n* A new function, `resolve_binary`, was added to help users of this crate\nmitigate this behavior when they need to create their own\n`std::process::Command`. For example,\n[ripgrep uses `grep_cli::resolve_binary`](https://github.com/BurntSushi/ripgrep/blob/7ce66f73cf7e76e9f2557922ac8e650eb02cf4ed/crates/core/search.rs#L119-L122)\non the argument given to its `--pre` flag.\n\nWhile the first mitigation fixes this issue for sensible values of `PATH`\nwhen doing decompression search, the second mitigation is imperfect. The more\nfundamental issue is that `std::process::Command` is itself vulnerable to this.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0079",
      "package": "pqc_kyber",
      "date": "2023-12-01",
      "url": "https://github.com/Argyle-Software/kyber/issues/108",
      "references": [
        "https://kyberslash.cr.yp.to/faq.html",
        "https://kyberslash.cr.yp.to/libraries.html",
        "https://github.com/bwesterb/argyle-kyber/commit/b5c6ad13f4eece80e59c6ebeafd787ba1519f5f6"
      ],
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "keywords": [
        "timing-attack"
      ],
      "aliases": [
        "GHSA-x5j2-g63m-f8g4"
      ]
    },
    "affected": {},
    "versions": {
      "patched": []
    },
    "text": "\n\n# KyberSlash: division timings depending on secrets\n\nVarious Kyber software libraries in various environments leak secret information into timing, specifically because\n\n * these libraries include a line of code that divides a secret numerator by a public denominator,\n * the number of CPU cycles for division in various environments varies depending on the inputs to the division, and\n * this variation appears within the range of numerators used in these libraries.\n\nThe KyberSlash pages track which Kyber [libraries](https://kyberslash.cr.yp.to/libraries.html) have this issue, and include a [FAQ](https://kyberslash.cr.yp.to/faq.html) about the issue.\n\n## Author\n\nThe KyberSlash pages were written by Daniel J. Bernstein. The FAQ originally said \"I\", but some people seemed to have trouble finding this authorship statement, so the FAQ now says \"Bernstein\" instead.\n\n## URL\n\nThe permanent link for the KyberSlash pages is [https://kyberslash.cr.yp.to](https://kyberslash.cr.yp.to).\n\n## Mitigation status in `pqc_kyber` crate\n\nThe issue has not been resolved in the upstream `pqc_kyber` crate.\n\nA third-party fork that mitigates this attack vector has been published as [`safe_pqc_kyber`](https://crates.io/crates/safe_pqc_kyber).\n\n## Alternatives\n\nThe [`ml-kem`](https://crates.io/crates/ml-kem) crate is a maintained\nalternative pure Rust implementation of ML-KEM / Kyber.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0006",
      "package": "cassandra",
      "date": "2016-12-15",
      "informational": "unmaintained",
      "url": "https://github.com/tupshin/cassandra-rs/issues/52"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.8.1"
      ]
    },
    "text": "\n\n# `cassandra` crate is unmaintained; use `cassandra-cpp` instead\n\nThe `cassandra` crate has not seen a release since December 2016, and its author\nis unresponsive.\n\nThe `cassandra-cpp` crate is a maintained fork:\n\nhttps://github.com/Metaswitch/cassandra-rs\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0089",
      "package": "aliyun-oss-client",
      "date": "2022-11-19",
      "url": "https://github.com/advisories/GHSA-3w3h-7xgx-grwc",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "CVE-2022-39397",
        "GHSA-3w3h-7xgx-grwc"
      ],
      "cvss": "CVSS:3.1/AV:P/AC:L/PR:H/UI:R/S:C/C:H/I:L/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.8.1"
      ]
    },
    "text": "\n\n# `aliyun-oss-client` secret exposure\n\nThe `aliyun-oss-client` unintentionally divulges the authentication secret.\n\nThis bug was fixed in [this](https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29) commit by limiting the concerned traits to be `pub` only within the crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0063",
      "package": "quinn-proto",
      "date": "2023-09-21",
      "url": "https://github.com/quinn-rs/quinn/pull/1667",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "panic"
      ],
      "aliases": [
        "CVE-2023-42805",
        "GHSA-q8wc-j5m9-27w3"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        "^0.9.5",
        ">= 0.10.5"
      ]
    },
    "text": "\n\n# Denial of service in Quinn servers\n\nReceiving QUIC frames containing a frame with unknown frame type could lead to a panic.\nUnfortunately this is issue was not found by our fuzzing infrastructure.\n\nThanks to the QUIC Tester research group for reporting this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0373",
      "package": "quinn-proto",
      "date": "2024-09-02",
      "url": "https://github.com/quinn-rs/quinn",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "panic"
      ],
      "aliases": [
        "GHSA-vr26-jcq5-fjj8",
        "CVE-2024-45311"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.11.7"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# `Endpoint::retry()` calls can lead to panicking\n\nIn 0.11.0, we overhauled the server-side `Endpoint` implementation to enable\nmore careful handling of incoming connection attempts. However, some of the\ncode paths that cleaned up state after connection attempts were processed\nconfused the initial destination connection ID with the destination connection\nID of a substantial package. This resulted in the internal `Endpoint` state\nbecoming inconsistent, which could then lead to a panic.\n\nhttps://github.com/quinn-rs/quinn/commit/e01609ccd8738bd438d86fa7185a0f85598cb58f\n\nThanks to [@finbear](https://github.com/finnbear) for reporting and investingating,\nand to [@BiagoFesta](https://github.com/BiagoFesta) for coordinating.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0016",
      "package": "partial_sort",
      "date": "2023-02-20",
      "url": "https://github.com/sundy-li/partial_sort/issues/7",
      "informational": "unsound",
      "categories": [
        "memory-exposure"
      ],
      "keywords": [
        "out-of-bounds read"
      ],
      "aliases": [
        "GHSA-5x36-7567-3cw6"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Possible out-of-bounds read in release mode\n\nAffected versions of this crate were using a debug assertion to validate the\n`last` parameter of `partial_sort()`. This would allow invalid inputs to cause\nan out-of-bounds read instead of immediately panicking, when compiled without\ndebug assertions.\n\nAll writes are bounds-checked, so the out-of-bounds memory access is read-only.\nThis also means that the first attempted out-of-bounds write will panic,\nlimiting the possible reads.\n\nThe accessible region is further limited by an initial bounds-checked read\nat `(last / 2) - 1`, i.e., it is proportional to the size of the vector.\n\nThis bug has been fixed in v0.2.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0070",
      "package": "nalgebra",
      "date": "2021-06-06",
      "url": "https://github.com/dimforge/nalgebra/issues/883",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "memory-safety"
      ],
      "aliases": [
        "CVE-2021-38190",
        "GHSA-3w8g-xr3f-2mp8"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.27.1"
      ],
      "unaffected": [
        "< 0.11.0"
      ]
    },
    "text": "\n\n# VecStorage Deserialize Allows Violation of Length Invariant\n\nThe `Deserialize` implementation for `VecStorage` did not maintain the invariant that the number of elements must equal `nrows * ncols`. Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.\n\nThis flaw was introduced in v0.11.0 ([`086e6e`](https://github.com/dimforge/nalgebra/commit/086e6e719f53fecba6dadad2e953a487976387f5)) due to the addition of an automatically derived implementation of `Deserialize` for `MatrixVec`. `MatrixVec` was later renamed to `VecStorage` in v0.16.13 ([`0f66403`](https://github.com/dimforge/nalgebra/commit/0f66403cbbe9eeac15cedd8a906c0d6a3d8841f2)) and continued to use the automatically derived implementation of `Deserialize`.\n\nThis flaw was corrected in commit [`5bff536`](https://github.com/dimforge/nalgebra/commit/5bff5368bf38ddfa31416e4ae9897b163031a513) by returning an error during deserialization if the number of elements does not exactly match the expected size.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0040",
      "package": "obstack",
      "aliases": [
        "CVE-2020-35894",
        "GHSA-85j6-f8j6-q26x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "date": "2020-09-03",
      "informational": "unsound",
      "url": "https://github.com/petertodd/rust-obstack/issues/4"
    },
    "versions": {
      "patched": [
        ">= 0.1.4"
      ]
    },
    "text": "\n\n# Obstack generates unaligned references\n\nObstack generates unaligned references for types that require a large alignment.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0060",
      "package": "orbtk",
      "date": "2022-10-13",
      "url": "https://github.com/redox-os/orbtk/blob/eba9e77821551076bbf1d9f7ab44d788150e3446/README.md#orbtk-is-sunsetting",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# orbtk is Unmaintained\n\nThe `orbtk` crate is no longer maintained.\n\nAlternatives proposed by the authors:\n\n * [`iced`](https://crates.io/crates/iced)\n * [`slint`](https://crates.io/crates/slint)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0361",
      "package": "cosmwasm-vm",
      "date": "2024-08-08",
      "url": "https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2024-004.md",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "resource-consumption"
      ],
      "aliases": [
        "GHSA-rg2q-2jh9-447q"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.5.7, < 2.0.0",
        ">= 2.0.6, < 2.1.0",
        ">= 2.1.3"
      ]
    },
    "text": "\n\n# CWA-2024-004: Gas mispricing in cosmwasm-vm\n\nSome Wasm operations take significantly more gas than our benchmarks indicated. This can lead to missing the gas target we defined by a factor of ~10x. This means a malicious contract could take 10 times as much time to execute as expected, which can be used to temporarily DoS a chain.\n\nFor more information, see [CWA-2024-004](https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2024-004.md).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0366",
      "package": "cosmwasm-vm",
      "date": "2024-08-27",
      "url": "https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2023-004.md",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "resource-consumption",
        "crash",
        "deadlock"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.2.8, < 1.3.0",
        ">= 1.3.4, < 1.4.0",
        ">= 1.4.2, < 1.5.0",
        ">= 1.5.1"
      ]
    },
    "text": "\n\n# CWA-2023-004: Excessive number of function parameters in compiled Wasm\n\nA specifically crafted Wasm file can cause the VM to consume excessive amounts of memory when compiling a contract.\nThis can lead to high memory usage, slowdowns, potentially a crash and can poison a lock in the VM,\npreventing any further interaction with contracts.\n\nFor more information, see [CWA-2023-004](https://github.com/CosmWasm/advisories/blob/main/CWAs/CWA-2023-004.md).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0363",
      "package": "sqlx",
      "date": "2024-08-15",
      "url": "https://github.com/launchbadge/sqlx/issues/3440",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "sql",
        "injection",
        "overflow",
        "truncation"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.8.1"
      ]
    },
    "text": "\n\n# Binary Protocol Misinterpretation caused by Truncating or Overflowing Casts\n\nThe following presentation at this year's DEF CON was brought to our attention on the SQLx Discord:\n\n> SQL Injection isn't Dead: Smuggling Queries at the Protocol Level  \n> <http://web.archive.org/web/20240812130923/https://media.defcon.org/DEF%20CON%2032/DEF%20CON%2032%20presentations/DEF%20CON%2032%20-%20Paul%20Gerste%20-%20SQL%20Injection%20Isn't%20Dead%20Smuggling%20Queries%20at%20the%20Protocol%20Level.pdf>  \n> (Archive link for posterity.)\n\nEssentially, encoding a value larger than 4GiB can cause the length prefix in the protocol to overflow, \ncausing the server to interpret the rest of the string as binary protocol commands or other data.\n\nIt appears SQLx _does_ perform truncating casts in a way that could be problematic, \nfor example: <https://github.com/launchbadge/sqlx/blob/6f2905695b9606b5f51b40ce10af63ac9e696bb8/sqlx-postgres/src/arguments.rs#L163>\n\nThis code has existed essentially since the beginning, \nso it is reasonable to assume that all published versions `<= 0.8.0` are affected.\n\n## Mitigation\n\nAs always, you should make sure your application is validating untrustworthy user input. \nReject any input over 4 GiB, or any input that could _encode_ to a string longer than 4 GiB. \nDynamically built queries are also potentially problematic if it pushes the message size over this 4 GiB bound.\n\n[`Encode::size_hint()`](https://docs.rs/sqlx/latest/sqlx/trait.Encode.html#method.size_hint) \ncan be used for sanity checks, but do not assume that the size returned is accurate. \nFor example, the `Json<T>` and `Text<T>` adapters have no reasonable way to predict or estimate the final encoded size, \nso they just return `size_of::<T>()` instead.\n\nFor web application backends, consider adding some middleware that limits the size of request bodies by default.\n\n## Resolution\n\n`sqlx 0.8.1` has been released with the fix: <https://github.com/launchbadge/sqlx/blob/main/CHANGELOG.md#081---2024-08-23>\n\nPostgres users are advised to upgrade ASAP as a possible exploit has been demonstrated:\n<https://github.com/launchbadge/sqlx/issues/3440#issuecomment-2307956901>\n\nMySQL and SQLite do not _appear_ to be exploitable, but upgrading is recommended nonetheless.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0002",
      "package": "vmm-sys-util",
      "date": "2024-01-02",
      "url": "https://github.com/advisories/GHSA-875g-mfp6-g7f9",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L",
      "aliases": [
        "CVE-2023-50711",
        "GHSA-875g-mfp6-g7f9"
      ]
    },
    "affected": {
      "functions": {
        "vmm_sys_util::fam::FamStructWrapper::deserialize": [
          "< 0.12.0, >= 0.5.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.12.0"
      ],
      "unaffected": [
        "< 0.5.0"
      ]
    },
    "text": "\n\n# `serde` deserialization for `FamStructWrapper` lacks bound checks that could potentially lead to out-of-bounds memory access\n\n## Impact\n\nAn issue was discovered in the `FamStructWrapper::deserialize` implementation\nprovided by the crate for `vmm_sys_util::fam::FamStructWrapper`, which can lead\nto out of bounds memory accesses. The deserialization does not check that the\nlength stored in the header matches the flexible array length. Mismatch in the\nlengths might allow out of bounds memory access through Rust-safe methods.\n\nImpacted versions: >= 0.5.0\n\n## Patches\n\nThe issue was corrected in version 0.12.0 by inserting a check that verifies\nthe lengths of compared flexible arrays are equal for any deserialized header\nand aborting deserialization otherwise. Moreover, the API was changed so that\nheader length can only be modified through Rust-unsafe code. This ensures that\nusers cannot trigger out-of-bounds memory access from Rust-safe code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0042",
      "package": "insert_many",
      "aliases": [
        "CVE-2021-29933",
        "GHSA-29hg-r7c7-54fr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-26",
      "url": "https://github.com/rphmeier/insert_many/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# insert_many can drop elements twice on panic\n\nAffected versions of `insert_many` used `ptr::copy` to move over items in a\nvector to make space before inserting, duplicating their ownership. It then\niterated over a provided `Iterator` to insert the new items.\n\nIf the iterator's `.next()` method panics then the vector would drop the same\nelements twice.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0069",
      "package": "lettre",
      "date": "2020-11-11",
      "url": "https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b",
      "categories": [
        "code-execution",
        "file-disclosure"
      ],
      "keywords": [
        "email",
        "sendmail"
      ],
      "aliases": [
        "CVE-2020-28247",
        "GHSA-vc2p-r46x-m3vx"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N"
    },
    "versions": {
      "patched": [
        ">= 0.10.0-alpha.4",
        "< 0.10.0-alpha.1, >= 0.9.5",
        "< 0.9.0, >= 0.8.4",
        "< 0.8.0, >= 0.7.1"
      ],
      "unaffected": [
        "< 0.7.0"
      ]
    },
    "affected": {
      "functions": {
        "lettre::sendmail::SendmailTransport::send": [
          "< 0.10.0-alpha.1"
        ],
        "lettre::transport::sendmail::SendmailTransport::send": [
          ">= 0.10.0-alpha.1, <= 0.10.0-alpha.3"
        ],
        "lettre::transport::sendmail::SendmailTransport::send_raw": [
          ">= 0.10.0-alpha.1, <= 0.10.0-alpha.3"
        ]
      }
    },
    "text": "\n\n# Argument injection in sendmail transport\n\nAffected versions of lettre allowed argument injection\nto the sendmail command. It was possible, using forged `to` addresses,\nto pass arbitrary arguments to the sendmail executable.\n\nDepending on the implementation (original sendmail, postfix, exim, etc.)\nit could be possible in some cases to write email data into arbitrary files (using sendmail's\nlogging features).\n \nThe flaw is corrected by modifying the executed command to stop parsing arguments\nbefore passing the destination addresses.\n\nNOTE: This vulnerability only affects the `sendmail` transport. Others, including `smtp`, are not\naffected.\n\nThis vulnerability was reported by vin01.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0069",
      "package": "lettre",
      "date": "2021-05-22",
      "url": "https://github.com/lettre/lettre/pull/627/commits/93458d01fed0ec81c0e7b4e98e6f35961356fae2",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "email",
        "smtp"
      ],
      "aliases": [
        "GHSA-qc36-q22q-cjw3",
        "CVE-2021-38189"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.0-rc.3",
        "< 0.10.0-alpha.1, >= 0.9.6"
      ],
      "unaffected": [
        "< 0.7.0"
      ]
    },
    "affected": {
      "functions": {
        "lettre::smtp::SmtpTransport::send": [
          "< 0.10.0-alpha.1"
        ],
        "lettre::transport::smtp::SmtpTransport::send": [
          ">= 0.10.0-alpha.1, < 0.10.0-rc.3"
        ],
        "lettre::transport::smtp::SmtpTransport::send_raw": [
          ">= 0.10.0-alpha.1, < 0.10.0-rc.3"
        ]
      }
    },
    "text": "\n\n# SMTP command injection in body\n\nAffected versions of lettre allowed SMTP command injection through an attacker's controlled message body. The module for escaping lines starting with a period wouldn't catch a period that was placed after a double CRLF sequence, allowing the attacker to end the current message and write arbitrary SMTP commands after it.\n\nThe flaw is fixed by correctly handling consecutive CRLF sequences.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0148",
      "package": "cgc",
      "date": "2020-12-10",
      "url": "https://github.com/playXE/cgc/issues/5",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "aliasing",
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36466",
        "CVE-2020-36467",
        "CVE-2020-36468",
        "GHSA-f3mq-99jr-ww4r",
        "GHSA-f9xr-3m55-5q2v",
        "GHSA-pwhf-7427-9vv2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple soundness issues in `Ptr`\n\nAffected versions of this crate have the following issues:\n\n1. `Ptr` implements `Send` and `Sync` for all types, this can lead to data\n   races by sending non-thread safe types across threads.\n\n2. `Ptr::get` violates mutable alias rules by returning multiple mutable\n   references to the same object.\n\n3. `Ptr::write` uses non-atomic writes to the underlying pointer. This means\n   that when used across threads it can lead to data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0077",
      "package": "rosenpass",
      "date": "2023-11-04",
      "references": [
        "https://github.com/rosenpass/rosenpass/commit/93439858d1c44294a7b377f775c4fc897a370bb2"
      ],
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "remote",
        "single-byte"
      ],
      "license": "CC0-1.0",
      "aliases": [
        "GHSA-6ggr-cwv4-g7qg"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# Remotely exploitable DoS condition in Rosenpass <=0.2.0\n\nAffected version do this crate did not validate the size of buffers when attempting to decode messages.\n\nThis allows an attacker to trigger a panic by sending a UDP datagram with a 1 byte payload over network.\n\nThis flaw was corrected by validating the size of the buffers before attempting to decode the message.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0074",
      "package": "ammonia",
      "date": "2021-07-08",
      "url": "https://github.com/rust-ammonia/ammonia/pull/142",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "html",
        "xss"
      ],
      "aliases": [
        "CVE-2021-38193",
        "GHSA-5325-xw5m-phm3"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.1.0",
        ">= 2.1.3, < 3.0.0"
      ]
    },
    "text": "\n\n# Incorrect handling of embedded SVG and MathML leads to mutation XSS\n\nAffected versions of this crate did not account for namespace-related parsing\ndifferences between HTML, SVG, and MathML. Even if the `svg` and `math` elements\nare not allowed, the underlying HTML parser still treats them differently.\nRunning cleanup without accounting for these differing namespaces resulted in an \"impossible\"\nDOM, which appeared \"safe\" when examining the DOM tree, but when serialized and deserialized,\ncould be exploited to inject arbitrary markup.\n\nTo exploit this, the application using this library must allow a tag that is parsed as raw text in HTML.\nThese [elements] are:\n\n* title\n* textarea\n* xmp\n* iframe\n* noembed\n* noframes\n* plaintext\n* noscript\n* style\n* script\n\nApplications that do not explicitly allow any of these tags should not be affected, since none are allowed by default.\n\n[elements]: https://github.com/servo/html5ever/blob/57eb334c0ffccc6f88d563419f0fbeef6ff5741c/html5ever/src/tree_builder/rules.rs\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0003",
      "package": "ammonia",
      "date": "2022-01-19",
      "url": "https://github.com/rust-ammonia/ammonia/pull/147",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "html",
        "xss"
      ],
      "aliases": [
        "GHSA-p2g9-94wh-65c2"
      ]
    },
    "affected": {
      "functions": {
        "ammonia::clean_text": [
          "<= 3.1.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 3.1.3"
      ],
      "unaffected": [
        "< 3.0.0"
      ]
    },
    "text": "\n\n# Space bug in `clean_text`\n\nAn incorrect mapping from HTML specification to ASCII codes was used.\nBecause HTML treats the Form Feed as whitespace, code like this has an injection bug:\n\n    let html = format!(\"<div title={}>\", clean_text(user_supplied_string));\n\nApplications are not affected if they quote their attributes, or if they don't use `clean_text` at all.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0001",
      "package": "ammonia",
      "aliases": [
        "CVE-2019-15542",
        "GHSA-5hp8-35wj-m525"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-04-27",
      "keywords": [
        "stack-overflow",
        "crash"
      ],
      "url": "https://github.com/rust-ammonia/ammonia/blob/master/CHANGELOG.md#210"
    },
    "affected": {
      "functions": {
        "ammonia::Document::to_string": [
          "< 2.1.0"
        ],
        "ammonia::Document::write_to": [
          "< 2.1.0"
        ],
        "ammonia::clean": [
          "< 2.1.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 2.1.0"
      ]
    },
    "text": "\n\n# Uncontrolled recursion leads to abort in HTML serialization\n\nAffected versions of this crate did use recursion for serialization of HTML\nDOM trees.\n\nThis allows an attacker to cause abort due to stack overflow by providing\na pathologically nested input.\n\nThe flaw was corrected by serializing the DOM tree iteratively instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0074",
      "package": "pyo3",
      "aliases": [
        "CVE-2020-35917",
        "GHSA-2vx6-fcw6-hpr6"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-28",
      "url": "https://github.com/PyO3/pyo3/pull/1297",
      "keywords": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.12.4"
      ],
      "unaffected": [
        "< 0.12.0"
      ]
    },
    "text": "\n\n# Reference counting error in `From<Py<T>>`\n\nA bug in `From<Py<T>>` would lead to an extra reference count decrement, often\nleading to use-after-free issues.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0168",
      "package": "mach",
      "date": "2020-07-14",
      "url": "https://github.com/fitzgen/mach/issues/63",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# mach is unmaintained\n\n\nLast release was almost 4 years ago.\n\nMaintainer(s) seem to be completely unreachable. \n\n## Possible Alternative(s)\n\nThese may or may not be suitable alternatives and have not been vetted in any way;\n- [mach2](https://crates.io/crates/mach2) - direct fork\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0037",
      "package": "crayon",
      "aliases": [
        "CVE-2020-35889",
        "GHSA-m833-jv95-mfjh"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-08-31",
      "informational": "unsound",
      "url": "https://github.com/shawnscode/crayon/issues/87"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Misbehaving `HandleLike` implementation can lead to memory safety violation\n\nUnsafe code in `ObjectPool` has time-of-check to time-of-use (TOCTOU) bug that\ncan eventually lead to a memory safety violation. `ObjectPool` and `HandlePool`\nimplicitly assumes that `HandleLike` trait methods are pure, i.e., they always\nreturn the same value. However, this assumption is unsound since `HandleLike`\nis a safe, public trait that allows a custom implementation.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0018",
      "package": "crayon",
      "date": "2024-02-27",
      "url": "https://github.com/shawnscode/crayon/issues/109",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "std::mem::uninitialized",
        "address-sanitizer"
      ],
      "aliases": [
        "GHSA-xfhw-6mc4-mgxf"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "< 0.6.0"
      ]
    },
    "affected": {
      "functions": {
        "crayon::utils::object_pool::ObjectPool<H,T>::free": [
          ">=0.6.0"
        ]
      }
    },
    "text": "\n\n# ObjectPool creates uninitialized memory when freeing objects\n\nAs of version 0.6.0, the ObjectPool explicitly creates an uninitialized instance of its\ntype parameter when it attempts to free an object, and swaps it into the storage. This\ncauses instant undefined behavior due to reading the uninitialized memory in order to\nwrite it to the pool storage.\n\nExtremely basic usage of the crate can trigger this issue, e.g. this code from a doctest:\n\n```rust\nuse crayon::prelude::*;\napplication::oneshot().unwrap();\n\nlet mut params = MeshParams::default();\n\nlet mesh = video::create_mesh(params, None).unwrap();\n\n// Deletes the mesh object.\nvideo::delete_mesh(mesh); // <-- UB\n```\n\nThe Clippy warning for this code was silenced in commit c2fde19caf6149d91faa504263f0bc5cafc35de5.\n\nDiscovered via https://asan.saethlin.dev/ub?crate=crayon&version=0.7.1\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0004",
      "package": "cosmwasm",
      "date": "2024-01-20",
      "url": "https://github.com/CosmWasm/cosmwasm/issues/1430",
      "informational": "unmaintained",
      "categories": [],
      "license": "CC0-1.0"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `cosmwasm` is unmaintained\n\nThe crate `cosmwasm` is [not used anymore] since spring 2020.\nThe functionality was split in multiple different crates, such as the standard library `cosmwasm-std` and the virtual machine `cosmwasm-vm`. An overview can be found in the [cosmwasm repository].\n\nIf you have this crate in your dependency tree, this is very likely by mistake and should be corrected.\n\n[not used anymore]: https://github.com/CosmWasm/cosmwasm/issues/1430\n[cosmwasm repository]: https://github.com/CosmWasm/cosmwasm\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0152",
      "package": "max7301",
      "date": "2020-12-18",
      "url": "https://github.com/edarc/max7301/issues/1",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36472",
        "GHSA-rmff-f8w9-c9rm"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# ImmediateIO and TransactionalIO can cause data races\n\nThe `ImmediateIO` and `TransactionalIO` types implement `Sync` for all contained\n`Expander<EI>` types regardless of if the `Expander` itself is safe to use\nacross threads.\n\nAs the `IO` types allow retrieving the `Expander`, this can lead to non-thread\nsafe types being sent across threads as part of the `Expander` leading to data\nraces.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0085",
      "package": "binjs_io",
      "date": "2021-01-03",
      "url": "https://github.com/binast/binjs-ref/issues/460",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45683",
        "GHSA-c6px-4grw-hrjr",
        "GHSA-cw4j-cf6c-mmfv"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# 'Read' on uninitialized memory may cause UB\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. The crate currently contains 4 occurrences of such cases.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0051",
      "package": "outer_cgi",
      "aliases": [
        "CVE-2021-30454",
        "GHSA-6vmq-jh76-hq43"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-01-31",
      "url": "https://github.com/SolraBizna/outer_cgi/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.2.1"
      ]
    },
    "text": "\n\n# KeyValueReader passes uninitialized memory to Read instance\n\nThe `KeyValueReader` type in affected versions of this crate set up an\nuninitialized memory buffer and passed them to be read in to a user-provided\n`Read` instance.\n\nThe `Read` instance could read uninitialized memory and cause undefined\nbehavior and miscompilations.\n\nThis issue was fixed in commit [dd59b30](https://github.com/SolraBizna/outer_cgi/commit/dd59b3066e616a08e756f72de8dc3ab11b7036c4)\nby zero-initializing the buffers before passing them.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0163",
      "package": "term_size",
      "date": "2020-11-03",
      "informational": "unmaintained",
      "url": "https://github.com/clap-rs/term_size-rs/pull/31"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# `term_size` is unmaintained; use `terminal_size` instead\n\nThe [`term_size`](https://crates.io/crates/term_size) crate is no longer maintained. Consider using\n[`terminal_size`](https://crates.io/crates/terminal_size) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0368",
      "package": "olm-sys",
      "date": "2024-09-02",
      "url": "https://gitlab.gnome.org/BrainBlasted/olm-sys/-/issues/12",
      "references": [
        "https://matrix.org/blog/2024/08/libolm-deprecation/"
      ],
      "categories": [
        "crypto-failure"
      ],
      "related": [
        "CVE-2024-45191",
        "CVE-2024-45192",
        "CVE-2024-45193"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# olm-sys: wrapped library unmaintained, potentially vulnerable\n\nAfter several cryptographic vulnerabilities in `libolm` were disclosed publicly, the Matrix Foundation has [officially deprecated the library](https://matrix.org/blog/2024/08/libolm-deprecation/). `olm-sys` is a thin wrapper around `libolm` and is now deprecated and potentially vulnerable in kind.\n\nUsers of `olm-sys` and its higher-level abstraction, `olm-rs`, are highly encouraged to switch to [`vodozemac`](https://crates.io/crates/vodozemac) as soon as possible. It is the successor effort to `libolm` and is written in Rust.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0093",
      "package": "async-h1",
      "date": "2020-12-17",
      "url": "https://github.com/http-rs/async-h1/releases/tag/v2.3.0",
      "categories": [],
      "keywords": [
        "smuggling",
        "http",
        "reverse proxy",
        "request smuggling"
      ],
      "aliases": [
        "CVE-2020-26281",
        "CVE-2020-36202",
        "GHSA-4vr9-8cjf-vf9c",
        "GHSA-c8rq-crxj-mj9m"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.3.0"
      ],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "async_h1::server::decode": [
          "< 2.3.0"
        ],
        "async_h1::server::accept": [
          "< 2.3.0"
        ]
      }
    },
    "text": "\n\n# Async-h1 request smuggling possible with long unread bodies\n\nThis vulnerability affects any webserver that uses async-h1 behind a reverse proxy, including all such Tide applications.\n\nIf the server does not read the body of a request which is longer than some buffer length, async-h1 will attempt to read a subsequent request from the body content starting at that offset into the body.\n\nOne way to exploit this vulnerability would be for an adversary to craft a request such that the body contains a request that would not be noticed by a reverse proxy, allowing it to forge forwarded/x-forwarded headers. If an application trusted the authenticity of these headers, it could be misled by the smuggled request.\n\nAnother potential concern with this vulnerability is that if a reverse proxy is sending multiple http clients' requests along the same keep-alive connection, it would be possible for the smuggled request to specify a long content and capture another user's request in its body. This content could be captured in a post request to an endpoint that allows the content to be subsequently retrieved by the adversary.\n\nThe flaw was corrected in commit [7df79f](https://github.com/http-rs/async-h1/commit/7df79f1d5d99fc0f492b315eebc7f0d301a85212) by ensuring that the request body is always consumed from the tcp stream before attempting to read subsequent keep-alive request headers from it.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0091",
      "package": "gfx-auxil",
      "date": "2021-01-07",
      "url": "https://github.com/gfx-rs/gfx/issues/3567",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45689",
        "GHSA-28p5-7rg4-8v99",
        "GHSA-ff2r-xpwq-6whj"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Reading on uninitialized buffer may cause UB ( `gfx_auxil::read_spirv()` )\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0156",
      "package": "libsecp256k1-rs",
      "date": "2020-01-22",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2019-20399",
      "categories": [
        "crypto-failure"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "aliases": [
        "CVE-2019-20399",
        "GHSA-7cqg-8449-rmfv"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.1"
      ]
    },
    "text": "\n\n# Observable Discrepancy in libsecp256k1-rs\n\nA timing vulnerability in the Scalar::check_overflow function in Parity libsecp256k1-rs before 0.3.1 potentially allows an attacker to leak information via a side-channel attack.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0093",
      "package": "crossbeam-deque",
      "aliases": [
        "GHSA-pqqp-xmhj-wgcw",
        "CVE-2021-32810"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2021-07-30",
      "url": "https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-pqqp-xmhj-wgcw"
    },
    "versions": {
      "patched": [
        ">= 0.7.4, < 0.8.0",
        ">= 0.8.1"
      ]
    },
    "text": "\n\n# Data race in crossbeam-deque\n\nIn the affected version of this crate, the result of the race condition is that one or more tasks in the worker queue can be popped twice instead of other tasks that are forgotten and never popped. If tasks are allocated on the heap, this can cause double free and a memory leak. If not, this still can cause a logical bug.\n\nCrates using `Stealer::steal`, `Stealer::steal_batch`, or `Stealer::steal_batch_and_pop` are affected by this issue.\n\nCredits to @kmaork for discovering, reporting and fixing the bug.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0052",
      "package": "id-map",
      "aliases": [
        "CVE-2021-30455",
        "CVE-2021-30456",
        "CVE-2021-30457",
        "GHSA-8gmx-cpcg-f8h5",
        "GHSA-rccq-j2m7-8fwr",
        "GHSA-vfqx-hv88-f9cv"
      ],
      "date": "2021-02-26",
      "url": "https://github.com/andrewhickman/id-map/issues/3",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "double-free"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Multiple functions can cause double-frees\n\nThe following functions in the crate are affected:\n\n## `IdMap::clone_from`\n\nThe `clone_from` implementation for `IdMap` drops the values present in the\nmap and then begins cloning values from the other map. If a `.clone()` call\npancics, then the afformentioned dropped elements can be freed again.\n\n## `get_or_insert`\n\n`get_or_insert` reserves space for a value, before calling the user provided\ninsertion function `f`. If the function `f` panics then uninitialized or\npreviously freed memory can be dropped.\n\n## `remove_set`\n\nWhen removing a set of elements, `ptr::drop_in_place` is called on each of the\nelement to be removed. If the `Drop` impl of one of these elements panics then\nthe previously dropped elements can be dropped again.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0072",
      "package": "hyper-staticfile",
      "date": "2022-12-23",
      "url": "https://github.com/stephank/hyper-staticfile/commit/f12cadc6666c6f555d29725f5bc45da2103f24ea",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "open redirect",
        "http"
      ],
      "aliases": [
        "GHSA-5wvv-q5fv-2388"
      ]
    },
    "versions": {
      "patched": [
        "^0.9.4",
        ">= 0.10.0-alpha.5"
      ]
    },
    "text": "\n\n# Location header incorporates user input, allowing open redirect\n\nWhen `hyper-staticfile` performs a redirect for a directory request (e.g. a\nrequest for `/dir` that redirects to `/dir/`), the `Location` header value was\nderived from user input (the request path), simply appending a slash. The\nintent was to perform an origin-relative redirect, but specific inputs\nallowed performing a scheme-relative redirect instead.\n\nAn attacker could craft a special URL that would appear to be for the correct\ndomain, but immediately redirects to a malicious domain. Such a URL can benefit\nphishing attacks, for example an innocent looking link in an email.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0069",
      "package": "hyper-staticfile",
      "date": "2022-11-30",
      "url": "https://github.com/stephank/hyper-staticfile/issues/35",
      "categories": [
        "file-disclosure"
      ],
      "keywords": [
        "directory traversal",
        "http"
      ],
      "aliases": [
        "GHSA-7p7c-pvvx-2vx3"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        "^0.9.2",
        ">= 0.10.0-alpha.2"
      ]
    },
    "text": "\n\n# Improper validation of Windows paths could lead to directory traversal attack\n\nPath resolution in `hyper-staticfile` didn't correctly validate Windows paths\nmeaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed\nand respond with the contents of `c:/windows/web/screen/img101.png`. Thus users\ncould potentially read files anywhere on the filesystem.\n\nThis only impacts Windows. Linux and other unix likes are not impacted by this.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0126",
      "package": "signal-simple",
      "date": "2020-11-15",
      "url": "https://github.com/kitsuneninetails/signal-rust/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36446",
        "GHSA-36cg-4jff-5863",
        "GHSA-8892-84wf-cg8f"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# SyncChannel<T> can move 'T: !Send' to other threads\n\nAffected versions of this crate unconditionally implement Send/Sync for `SyncChannel<T>`.\n`SyncChannel<T>` doesn't provide access to `&T` but merely serves as a channel that consumes and returns owned `T`.\n\nUsers can create UB in safe Rust by sending `T: !Send` to other threads with `SyncChannel::send/recv` APIs. Using `T = Arc<Cell<_>` allows to create data races (which can lead to memory corruption), and using `T = MutexGuard<T>` allows to unlock a mutex from a thread that didn't lock the mutex.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0038",
      "package": "fltk",
      "aliases": [
        "CVE-2021-28306",
        "CVE-2021-28307",
        "CVE-2021-28308",
        "GHSA-5pg8-h4gv-m3p8",
        "GHSA-7qcc-g2m9-8533",
        "GHSA-vjmg-pc8h-p6p8"
      ],
      "date": "2021-03-06",
      "keywords": [
        "undefined_behavior"
      ],
      "url": "https://github.com/MoAlyousef/fltk-rs/issues/519"
    },
    "affected": {
      "functions": {
        "fltk::prelude::WidgetExt::set_label_type": [
          "< 0.15.2"
        ],
        "fltk::prelude::WindowExt::set_icon": [
          "< 0.14.12"
        ],
        "fltk::image::Pixmap::new": [
          "< 0.15.2, >= 0.14.12"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.15.3"
      ]
    },
    "text": "\n\n# Multiple memory safety issues\n\nAffected versions contain multiple memory safety issues, such as:\n\n - Setting a multi label type where an image doesn't exist would lead to a NULL pointer dereference.\n - Setting a window icon using a non-raster image (which FLTK rasterizes lazily) would lead to a NULL dereference.\n - Pixmap constructor would not check for correct pixmaps which could lead to out-of bound reads.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2016-0004",
      "package": "libusb",
      "date": "2016-09-10",
      "informational": "unmaintained",
      "url": "https://github.com/dcuddeback/libusb-rs/issues/33"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.3.0"
      ]
    },
    "text": "\n\n# libusb is unmaintained; use rusb instead\n\nThe `libusb` crate has not seen a release since September 2016, and its author\nis unresponsive.\n\nThe `rusb` crate is a maintained fork:\n\nhttps://github.com/a1ien/rusb\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0047",
      "package": "oqs",
      "date": "2022-02-25",
      "url": "https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/KFgw5_qCXiI?pli=1",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "GHSA-h864-m8vm-3xvj"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.2"
      ]
    },
    "text": "\n\n# Post-Quantum Signature scheme Rainbow level I parametersets broken\n\nWard Beullens found a practical key-recovery attack against Rainbow.\nThe level I parametersets are removed from liboqs starting from version `0.7.2`.\nFind the scientific details in [Breaking Rainbow Takes a Weekend on a Laptop](https://eprint.iacr.org/2022/214).\n\nThis means all the `oqs::sig::Algorithm::RainbowI*` variants are insecure.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0045",
      "package": "oqs",
      "date": "2022-07-30",
      "categories": [
        "crypto-failure"
      ],
      "aliases": [
        "GHSA-hrjv-pf36-jpmr"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.7.2"
      ]
    },
    "text": "\n\n# Post-Quantum Key Encapsulation Mechanism SIKE broken\n\nWouter Castryck and Thomas Decru presented an efficient key recovery attack on the SIDH protocol.\nAs a result, the secret key of SIKEp751 can be recovered in a matter of hours.\nThe SIKE and SIDH schemes will be removed from oqs 0.7.2.\n\nThe affected schemes are the `oqs::kem::Algorithm::Sike*` and `oqs::kem::Algorithm::Sidh*` enum variants.\n\n[An efficient key recovery attack on SIDH (preliminary version)](https://eprint.iacr.org/2022/975)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0127",
      "package": "v9",
      "date": "2020-12-18",
      "url": "https://github.com/purpleposeidon/v9/issues/1",
      "references": [
        "https://github.com/purpleposeidon/v9/commit/18847c50e5d36561cc91c996c3539ddb1eacf6c7"
      ],
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36447",
        "GHSA-3837-87vh-xq3w",
        "GHSA-pfjq-935c-4895"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.43"
      ]
    },
    "text": "\n\n# SyncRef's clone() and debug() allow data races\n\nAffected versions of this crate unconditionally implement `Sync` for `SyncRef<T>`.\nThis definition allows data races if `&T` is accessible through `&SyncRef`.\n\n`SyncRef<T>` derives `Clone` and `Debug`, and the default implementations of those traits access `&T` by invoking `T::clone()` & `T::fmt()`. It is possible to create data races & undefined behavior by concurrently invoking `SyncRef<T>::clone()` or `SyncRef<T>::fmt()` from multiple threads with `T: !Sync`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0161",
      "package": "array-macro",
      "date": "2020-05-07",
      "url": "https://gitlab.com/KonradBorowski/array-macro/-/commit/01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
      "categories": [
        "memory-corruption"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-83gg-pwxf-jr89"
      ]
    },
    "versions": {
      "patched": [
        ">= 1.0.5"
      ],
      "unaffected": [
        "< 0.1.2"
      ]
    },
    "text": "\n\n# `array!` macro is unsound in presence of traits that implement methods it calls internally\n\nAffected versions of this crate called some methods using auto-ref. The affected code looked like this.\n\n```rust\nlet mut arr = $crate::__core::mem::MaybeUninit::uninit();\nlet mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);\n```\n\nIn this case, the problem is that `as_mut_ptr` is a method of `&mut MaybeUninit`, not `MaybeUninit`. This made it possible for traits to hijack the method calls in order to cause unsoundness.\n\n```rust\ntrait AsMutPtr<T> {\n    fn as_mut_ptr(&self) -> *mut T;\n}\nimpl<T> AsMutPtr<T> for std::mem::MaybeUninit<T> {\n    fn as_mut_ptr(&self) -> *mut T {\n        std::ptr::null_mut()\n    }\n}\narray![0; 1];\n```\n\nThe flaw was corrected by explicitly referencing variables in macro body in order to avoid auto-ref.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0017",
      "package": "array-macro",
      "date": "2022-04-27",
      "url": "https://gitlab.com/KonradBorowski/array-macro/-/issues/5",
      "categories": [
        "code-execution",
        "memory-corruption",
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-7v4j-8wvr-v55r"
      ]
    },
    "versions": {
      "patched": [
        ">= 2.1.2"
      ],
      "unaffected": [
        "< 2.1.0"
      ]
    },
    "text": "\n\n# `array!` macro is unsound when its length is impure constant\n\nAffected versions of this crate did substitute the array length provided by an user at compile-time multiple times.\n\nWhen an impure constant expression is passed as an array length (such as a result of an impure procedural macro), this can result in the initialization of an array with uninitialized types, which in turn can allow an attacker to execute arbitrary code.\n\nThe flaw was corrected in commit [d5b63f72](https://gitlab.com/KonradBorowski/array-macro/-/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d) by making sure that array length is substituted just once.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0083",
      "package": "safe_app",
      "date": "2020-12-07",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "text": "\n\n# crate has been superseded by `sn_client`\n\nThis crate has been superseded by `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0025",
      "package": "bigint",
      "aliases": [
        "CVE-2020-35880",
        "GHSA-wgx2-6432-j3fw"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-05-07",
      "informational": "unmaintained",
      "url": "https://github.com/paritytech/bigint/commit/7e71521a61b009afc94c91135353102658550d42"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# bigint is unmaintained, use uint instead\n\nThe `bigint` crate is not maintained any more and contains several known bugs (including a soundness bug);\nuse [`uint`](https://crates.io/crates/uint) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0016",
      "package": "chttp",
      "aliases": [
        "CVE-2019-16140",
        "GHSA-5rrv-m36h-qwf8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-09-01",
      "keywords": [
        "memory-management",
        "memory-corruption"
      ],
      "url": "https://github.com/sagebind/isahc/issues/2"
    },
    "versions": {
      "patched": [
        ">= 0.1.3"
      ],
      "unaffected": [
        "< 0.1.1"
      ]
    },
    "text": "\n\n# Use-after-free in buffer conversion implementation\n\nThe From<Buffer> implementation for Vec<u8> was not properly implemented,\nreturning a vector backed by freed memory. This could lead to memory corruption\nor be exploited to cause undefined behavior.\n \nA fix was published in version 0.1.3.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0095",
      "package": "difference",
      "date": "2020-12-20",
      "url": "https://github.com/johannhof/difference.rs/issues/45",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 2.0.0"
      ]
    },
    "text": "\n\n# difference is unmaintained\n\nThe author of the `difference` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`dissimilar`](https://crates.io/crates/dissimilar)\n\n- [`similar`](https://crates.io/crates/similar)\n\n- [`treediff`](https://crates.io/crates/treediff)\n\n- [`diffus`](https://crates.io/crates/diffus)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0052",
      "package": "crossbeam-channel",
      "aliases": [
        "CVE-2020-15254",
        "CVE-2020-35904",
        "GHSA-m8h8-v6jh-c762",
        "GHSA-v5m7-53cv-f3hx"
      ],
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-06-26",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/533"
    },
    "versions": {
      "patched": [
        ">= 0.4.4"
      ],
      "unaffected": [
        "< 0.4.3"
      ]
    },
    "text": "\n\n# Undefined Behavior in bounded channel\n\nThe affected version of this crate's the `bounded` channel incorrectly assumes that `Vec::from_iter` has allocated capacity that same as the number of iterator elements. `Vec::from_iter` does not actually guarantee that and may allocate extra memory. The destructor of the `bounded` channel reconstructs `Vec` from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when `Vec::from_iter` has allocated different sizes with the number of iterator elements.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0019",
      "package": "crossbeam-channel",
      "date": "2022-05-10",
      "informational": "unsound",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/458",
      "aliases": [
        "GHSA-9g55-pg62-m8hh"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.3"
      ]
    },
    "text": "\n\n# Channel creates zero value of any type\n\nAffected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null).\n \nThe flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0063",
      "package": "comrak",
      "date": "2021-05-04",
      "url": "https://github.com/kivikakk/comrak/releases/tag/0.10.1",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "xss"
      ],
      "aliases": [
        "CVE-2021-38186",
        "GHSA-6wj2-g87r-pm62"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.1"
      ]
    },
    "text": "\n\n# XSS in `comrak`\n\n[comrak](https://github.com/kivikakk/comrak) operates by default in a \"safe\"\nmode of operation where unsafe content, such as arbitrary raw HTML or URLs with\nnon-standard schemes, are not permitted in the output.  This is per the\nreference GFM implementation, [cmark-gfm](https://github.com/github/cmark).\n\nAmpersands were not being correctly escaped in link targets, making it possible\nto fashion unsafe URLs using schemes like `data:` or `javascript:` by entering\nthem as HTML entities, e.g. `&#x64&#x61&#x74&#x61&#x3a`.  The intended\nbehaviour, demonstrated upstream, is that these should be escaped and therefore\nharmless, but this behaviour was broken in comrak.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0026",
      "package": "comrak",
      "aliases": [
        "CVE-2021-27671",
        "GHSA-xmr7-v725-2jjr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
      "date": "2021-02-21",
      "url": "https://github.com/kivikakk/comrak/releases/tag/0.9.1",
      "categories": [
        "format-injection"
      ],
      "keywords": [
        "xss"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.1"
      ]
    },
    "text": "\n\n# XSS in `comrak`\n\nThe [comrak](https://github.com/kivikakk/comrak) we were matching unsafe URL prefixes, such as `data:` or `javascript:` , in a case-sensitive manner. This meant prefixes like `Data:` were untouched.\n\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0008",
      "package": "windows",
      "date": "2022-01-02",
      "url": "https://github.com/microsoft/windows-rs/issues/1409",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [],
      "informational": "unsound",
      "aliases": [
        "GHSA-x4mq-m75f-mx8m"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.32.0"
      ],
      "unaffected": [
        "< 0.1.2"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ]
    },
    "text": "\n\n# Delegate functions are missing `Send` bound\n\nAffected versions of this crate did not require event handlers to have `Send` bound despite there being no guarantee of them being called on any particular thread, which can potentially lead to data races and undefined behavior.\n\nThe flaw was corrected in commit [afe3252](https://github.com/microsoft/windows-rs/commit/afe32525c22209aa8f632a0f4ad607863b51796a) by adding `Send` bounds.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0081",
      "package": "mio",
      "aliases": [
        "CVE-2020-35922",
        "GHSA-pf3p-x6qj-6j7q"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-02",
      "url": "https://github.com/tokio-rs/mio/issues/1386",
      "keywords": [
        "memory",
        "layout",
        "cast"
      ],
      "informational": "unsound"
    },
    "versions": {
      "patched": [
        ">= 0.7.6"
      ],
      "unaffected": [
        "< 0.7.0"
      ]
    },
    "text": "\n\n# `mio` invalidly assumes the memory layout of std::net::SocketAddr\n\nThe [`mio`](https://crates.io/crates/mio) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0019",
      "package": "mio",
      "date": "2024-03-04",
      "url": "https://github.com/tokio-rs/mio/security/advisories/GHSA-r8w9-5wcg-vfj7",
      "aliases": [
        "CVE-2024-27308",
        "GHSA-r8w9-5wcg-vfj7"
      ]
    },
    "affected": {
      "os": [
        "windows"
      ],
      "functions": {
        "mio::windows::NamedPipe::new": [
          ">= 0.7.2, <= 0.8.10"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.8.11"
      ],
      "unaffected": [
        "< 0.7.2"
      ]
    },
    "text": "\n\n# Tokens for named pipes may be delivered after deregistration\n\n## Impact\n\nWhen using named pipes on Windows, mio will under some circumstances return invalid tokens that correspond to named pipes that have already been deregistered from the mio registry. The impact of this vulnerability depends on how mio is used. For some applications, invalid tokens may be ignored or cause a warning or a crash. On the other hand, for applications that store pointers in the tokens, this vulnerability may result in a use-after-free.\n\nFor users of Tokio, this vulnerability is serious and can result in a use-after-free in Tokio.\n\nThe vulnerability is Windows-specific, and can only happen if you are using named pipes. Other IO resources are not affected.\n\n## Affected versions\n\nThis vulnerability has been fixed in mio v0.8.11.\n\nAll versions of mio between v0.7.2 and v0.8.10 are vulnerable.\n\nTokio is vulnerable when you are using a vulnerable version of mio AND you are using at least Tokio v1.30.0. Versions of Tokio prior to v1.30.0 will ignore invalid tokens, so they are not vulnerable.\n\n## Workarounds\n\nVulnerable libraries that use mio can work around this issue by detecting and ignoring invalid tokens.\n\n## Technical details\n\nWhen an IO resource registered with mio has a readiness event, mio delivers that readiness event to the user using a user-specified token. Mio guarantees that when an IO resource is [deregistered](https://docs.rs/mio/latest/mio/struct.Registry.html#method.deregister), then it will never return the token for that IO resource again. However, for named pipes on windows, mio may sometimes deliver the token for a named pipe even though the named pipe has been previously deregistered.\n\nThis vulnerability was originally reported in the Tokio issue tracker: [tokio-rs/tokio#6369](https://github.com/tokio-rs/tokio/issues/6369)  \nThis vulnerability was fixed in: [tokio-rs/mio#1760](https://github.com/tokio-rs/mio/pull/1760)\n\nThank you to [@rofoun](https://github.com/rofoun) and [@radekvit](https://github.com/radekvit) for discovering and reporting this issue.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0008",
      "package": "simd-json",
      "aliases": [
        "CVE-2019-15550",
        "GHSA-gwfj-pw2x-h6c2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-06-24",
      "keywords": [
        "simd"
      ],
      "url": "https://github.com/Licenser/simdjson-rs/pull/27"
    },
    "affected": {
      "arch": [
        "x86",
        "x86_64"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.15"
      ],
      "unaffected": [
        "<= 0.1.13"
      ]
    },
    "text": "\n\n# Flaw in string parsing can lead to crashes due to invalid memory access.\n\nThe affected version of this crate did not guard against accessing memory\nbeyond the range of its input data. A pointer cast to read the data into\na 256-bit register could lead to a segmentation fault when the end plus\nthe 32 bytes (256 bit) read would overlap into the next page during string\nparsing.\n\n```\npage   |  ...  page 1  ...  | ... page 2  ... |\ndata   | x[n * 32 byte]xx__ |                 |\naccess | ..][ 32 byte ]     |                 |\nsegflt |               [ 32 | byte ]          |\n```\n\nThis allows an attacker to eventually crash a service.\n\nThe flaw was corrected by using a padding buffer for the last read from the\ninput. So that we are we never read over the boundary of the input data.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0070",
      "package": "self_cell",
      "date": "2023-11-10",
      "url": "https://github.com/Voultapher/self_cell/issues/49",
      "categories": [],
      "keywords": [
        "unsound",
        "self_cell",
        "self-referential"
      ],
      "aliases": [
        "GHSA-48m6-wm5p-rr6h"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.10.3, < 1.0.0",
        ">= 1.0.2"
      ]
    },
    "text": "\n\n# Insufficient covariance check makes self_cell unsound\n\nAll public versions prior to `1.02` used an insufficient check to ensure that\nusers correctly marked the dependent type as either `covariant` or\n`not_covariant`. This allowed users to mark a dependent as covariant even though\nits type was not covariant but invariant, for certain invariant types involving\ntrait object lifetimes. One example for such a dependent type is `type\nDependent<'a> = RefCell<Box<dyn fmt::Display + 'a>>`. Such a type allowed\nunsound usage in purely safe user code that leads to undefined behavior. The\npatched versions now produce a compile time error if such a type is marked as\n`covariant`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0091",
      "package": "tauri",
      "date": "2022-09-19",
      "url": "https://github.com/tauri-apps/tauri/issues/5234",
      "categories": [
        "privilege-escalation"
      ],
      "aliases": [
        "CVE-2022-41874",
        "GHSA-q9wv-22m9-vhqh"
      ],
      "cvss": "CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:C/C:L/I:N/A:N"
    },
    "versions": {
      "patched": [
        ">= 1.0.7, < 1.1.0",
        ">= 1.1.2"
      ],
      "unaffected": [
        "< 1.0.0"
      ]
    },
    "text": "\n\n# `tauri` filesystem scope partial bypass\n\nA bug identified in [this](https://github.com/tauri-apps/tauri/issues/5234) issue allows a partial filesystem scope bypass if glob characters are used within file dialog or drag-and-drop functionalities.\n\n[This](https://github.com/tauri-apps/tauri/pull/5237) PR fixes the issue by escaping glob characters.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0088",
      "package": "tauri",
      "date": "2022-08-07",
      "url": "https://github.com/tauri-apps/tauri/issues/4882",
      "categories": [
        "privilege-escalation"
      ],
      "aliases": [
        "CVE-2022-39215",
        "GHSA-28m8-9j7v-x499"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:N"
    },
    "versions": {
      "patched": [
        ">= 1.0.6"
      ]
    },
    "text": "\n\n# `tauri`'s `readDir` endpoint allows possible enumeration outside of filesystem scope\n\nIt is possible for `readDir` to incorrectly enumerate files from a symlinked directory if called recursively when specifying an empty string for the dir parameter as outlined in [this](https://github.com/tauri-apps/tauri/issues/4882) issue.\n\nThis is corrected in [this](https://github.com/tauri-apps/tauri/pull/5123) PR by checking if a directory is a symlink before reading from it.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0002",
      "package": "interfaces2",
      "date": "2021-01-04",
      "informational": "unmaintained",
      "url": "https://github.com/aep/interfaces-rs"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# interfaces2 is unmaintained, use interfaces instead\n\nThe `interfaces2` crate is not maintained any more;\nuse [`interfaces`](https://crates.io/crates/interfaces) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0084",
      "package": "bronzedb-protocol",
      "date": "2021-01-03",
      "url": "https://github.com/Hexilee/BronzeDB/issues/1",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45682",
        "GHSA-5phc-849h-vcxg",
        "GHSA-jv2r-jx6q-89jg"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `Read` on uninitialized buffer can cause UB (impl of `ReadKVExt`)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0120",
      "package": "libsbc",
      "date": "2020-11-10",
      "url": "https://github.com/mvertescher/libsbc-rs/issues/4",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36440",
        "GHSA-f6g6-54hm-fhxv"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.1.5"
      ]
    },
    "text": "\n\n# `Decoder<R>` can carry `R: !Send` to other threads\n\nAffected versions of this crate implements `Send` for `Decoder<R>` for any `R: Read`. This allows `Decoder<R>` to contain `R: !Send` and carry (move) it to another thread.\n\nThis can result in undefined behavior such as memory corruption from data race on `R`, or dropping `R = MutexGuard<_>` from a thread that didn't lock the mutex.\n\nThe flaw was corrected in commit a34d6e1 by adding trait bound `R: Send` to the `Send` impl for `Decoder<R>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0033",
      "package": "http",
      "aliases": [
        "CVE-2019-25008",
        "CVE-2020-25574",
        "GHSA-x7vr-c387-8w57",
        "GHSA-xvc9-xwgj-4cq9"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "categories": [
        "denial-of-service"
      ],
      "date": "2019-11-16",
      "keywords": [
        "http",
        "integer-overflow",
        "DoS"
      ],
      "url": "https://github.com/hyperium/http/issues/352"
    },
    "affected": {
      "functions": {
        "http::header::HeaderMap::reserve": [
          "< 0.1.20"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.20"
      ]
    },
    "text": "\n\n# Integer Overflow in HeaderMap::reserve() can cause Denial of Service\n\n`HeaderMap::reserve()` used `usize::next_power_of_two()` to calculate the increased capacity.\nHowever, `next_power_of_two()` silently overflows to 0 if given a sufficiently large number\nin release mode.\n\nIf the map was not empty when the overflow happens,\nthe library will invoke `self.grow(0)` and start infinite probing.\nThis allows an attacker who controls the argument to `reserve()`\nto cause a potential denial of service (DoS).\n\nThe flaw was corrected in 0.1.20 release of `http` crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0034",
      "package": "http",
      "aliases": [
        "CVE-2019-25009",
        "GHSA-6rhx-hqxm-8p36"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2019-11-16",
      "keywords": [
        "memory-safety",
        "double-free",
        "unsound"
      ]
    },
    "affected": {
      "functions": {
        "http::header::HeaderMap::drain": [
          "< 0.1.20"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.1.20"
      ]
    },
    "text": "\n\n# HeaderMap::Drain API is unsound\n\nAffected versions of this crate incorrectly used raw pointer,\nwhich introduced unsoundness in its public safe API.\n\n[Failing to drop the Drain struct causes double-free](https://github.com/hyperium/http/issues/354),\nand [it is possible to violate Rust's alias rule and cause data race with Drain's Iterator implementation](https://github.com/hyperium/http/issues/355).\n\nThe flaw was corrected in 0.1.20 release of `http` crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0013",
      "package": "spin",
      "aliases": [
        "CVE-2019-16137",
        "GHSA-hv7x-f3pv-gpwr"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2019-08-27",
      "keywords": [
        "atomic",
        "ordering",
        "spin",
        "lock",
        "mutex",
        "rwlock"
      ],
      "url": "https://github.com/mvdnes/spin-rs/issues/65"
    },
    "affected": {
      "functions": {
        "spin::RwLock::new": [
          "< 0.5.2"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.5.2"
      ]
    },
    "text": "\n\n# Wrong memory orderings in RwLock potentially violates mutual exclusion\n\nWrong memory orderings inside the RwLock implementation allow for two writers to acquire the lock at the same time. The drop implementation used Ordering::Relaxed, which allows the compiler or CPU to reorder a mutable access on the locked data after the lock has been yielded.\n\nOnly users of the RwLock implementation are affected. Users of Once (including users of lazy_static with the `spin_no_std` feature enabled) are NOT affected.\n\nOn strongly ordered CPU architectures like x86, the only real way that this would lead to a memory corruption is if the compiler reorders an access after the lock is yielded, which is possible but in practice unlikely. It is a more serious issue on weakly ordered architectures such as ARM which, except in the presence of certain instructions, allow the hardware to decide which accesses are seen at what times. Therefore on an ARM system it is likely that using the wrong memory ordering would result in a memory corruption, even if the compiler itself doesn't reorder the memory accesses in a buggy way.\n\nThe flaw was corrected by https://github.com/mvdnes/spin-rs/pull/66.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0031",
      "package": "spin",
      "date": "2023-03-31",
      "informational": "unsound",
      "url": "https://github.com/mvdnes/spin-rs/issues/148",
      "aliases": [
        "GHSA-2qv5-7mw5-j3cg"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.9.8"
      ],
      "unaffected": [
        "< 0.9.3"
      ]
    },
    "text": "\n\n# Initialisation failure in `Once::try_call_once` can lead to undefined behaviour for other initialisers\n\n`Once::try_call_once` is unsound if invoked more than once concurrently and any call fails to initialise successfully.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0031",
      "package": "spin",
      "date": "2019-11-21",
      "informational": "unmaintained",
      "url": "https://github.com/mvdnes/spin-rs/commit/7516c80",
      "withdrawn": "2020-10-08"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        ">= 0"
      ]
    },
    "text": "\n\n# spin is no longer actively maintained\n\nThe author of the `spin` crate does not have time or interest to maintain it.\n\nConsider the following alternatives (all of which support `no_std`):\n\n- [`conquer-once`](https://github.com/oliver-giersch/conquer-once)\n- [`lock_api`](https://crates.io/crates/lock_api) (a subproject of `parking_lot`)\n  - [`spinning_top`](https://github.com/rust-osdev/spinning_top) spinlock crate built on `lock_api`\n- [`spinning`](https://github.com/4lDO2/spinning-rs)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0038",
      "package": "juniper",
      "date": "2022-07-28",
      "url": "https://github.com/graphql-rust/juniper/security/advisories/GHSA-4rx6-g5vg-5f3j",
      "categories": [
        "denial-of-service"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "aliases": [
        "GHSA-4rx6-g5vg-5f3j",
        "CVE-2022-31173"
      ],
      "related": [
        "GHSA-xq3c-8gqm-v648"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.15.10"
      ]
    },
    "text": "\n\n# Denial of service on deeply nested fragment requests\n\nDeeply nested fragments in a GraphQL request may cause a stack overflow in the server.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0005",
      "package": "glsl-layout",
      "aliases": [
        "CVE-2021-25902",
        "GHSA-cx4j-fxr7-jxg8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2021-01-10",
      "url": "https://github.com/rustgd/glsl-layout/pull/10",
      "categories": [
        "memory-corruption"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.0"
      ]
    },
    "text": "\n\n# Double drop upon panic in 'fn map_array()'\n\nAffected versions of this crate did not guard against panic within the user-provided function `f` (2nd parameter of `fn map_array`), and thus panic within `f` \ncauses double drop of a single object.\n\nThe flaw was corrected in the 0.4.0 release by wrapping the object vulnerable\nto a double drop within `ManuallyDrop<T>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0009",
      "package": "trillium-http",
      "date": "2024-01-23",
      "url": "https://github.com/trillium-rs/trillium/security/advisories/GHSA-9f9p-cp3c-72jf",
      "keywords": [
        "http",
        "request",
        "splitting"
      ],
      "aliases": [
        "GHSA-9f9p-cp3c-72jf",
        "CVE-2024-23644"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.3.12"
      ],
      "unaffected": []
    },
    "affected": {},
    "text": "\n\n# Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n\n### Summary\nInsufficient validation of outbound header values may lead to request splitting or response splitting attacks in scenarios where attackers have sufficient control over outbound headers.\n\n### Details\nOutbound `trillium_http::HeaderValue` and `trillium_http::HeaderName` can be constructed infallibly and were not checked for illegal bytes when sending responses from the server. Thus, if an attacker has sufficient control over header values (or names) in an outbound response that they could inject `\\r\\n` sequences, they could get the client and server out of sync, and then pivot to gain control over other parts of requests or responses. (i.e. exfiltrating data from other requests, SSRF, etc.)\n\n### Patches\n\n#### trillium-http >= 0.3.12:\n* If a header name is invalid in server response headers, the specific header and any associated values are omitted from network transmission.\n* If a header value is invalid in server response headers, the individual header value is omitted from network transmission. Other headers values with the same header name will still be sent.\n\n### Workarounds\n\ntrillium services should sanitize or validate untrusted input that is included in header values and header names. Carriage return, newline, and null characters are not allowed.\n\n### Impact\n\nThis only affects use cases where attackers have control of outbound headers, and can insert \"\\r\\n\" sequences. Specifically, if untrusted and unvalidated input is inserted into header names or values.\n\n### Credit\n\nDiscovered and reported by [@divergentdave](https://github.com/divergentdave)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0165",
      "package": "mozjpeg",
      "date": "2020-07-04",
      "keywords": [
        "type confusion"
      ],
      "url": "https://github.com/ImageOptim/mozjpeg-rust/issues/10",
      "categories": [
        "memory-corruption"
      ],
      "references": [
        "https://github.com/kornelski/rust-rgb/issues/35",
        "https://rustsec.org/advisories/RUSTSEC-2020-0029.html"
      ],
      "informational": "unsound",
      "aliases": [
        "GHSA-v8gq-5grq-9728"
      ]
    },
    "affected": {
      "functions": {
        "mozjpeg::DecompressScanlines::read_scanlines": [
          "< 0.8.19"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.8.19"
      ]
    },
    "text": "\n\n# mozjpeg DecompressScanlines::read_scanlines is Unsound\n\nThis issue and vector is similar to [RUSTSEC-2020-0029] of `rgb` crate which `mozjpeg` depends on.\n\nAffected versions of `mozjpeg` crate allow creating instances of any type `T` from bytes,\nand do not correctly constrain `T` to the types for which it is safe to do so.\n\nExamples of safety violation possible for a type `T`:\n\n* `T` contains a reference type, and it constructs a pointer to an invalid, arbitrary memory address.\n* `T` requires a safety and/or validity invariant for its construction that may be violated.\n\nThe issue was fixed in 0.8.19 by using safer types and involving `rgb` dependency bump.\n\n[RUSTSEC-2020-0029]: https://rustsec.org/advisories/RUSTSEC-2020-0029.html\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0147",
      "package": "daemonize",
      "date": "2021-09-01",
      "withdrawn": "2023-02-19",
      "url": "https://github.com/knsd/daemonize/issues/46",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `daemonize` is Unmaintained\n\nLast release was over four years ago.\n\nThe crate contains undocumented unsafe behind safe fns.\n\nAn [issue](https://github.com/knsd/daemonize/issues/46) inquiring as to possible updates has gone unanswered by the maintainer.\n\n## Possible Alternatives\n\nThe below list has not been vetted in any way and may or may not contain alternatives:\n\n- [daemonize-me](https://crates.io/crates/daemonize-me)\n- [tetsy-daemonize](https://crates.io/crates/tetsy-daemonize)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0012",
      "package": "orion",
      "aliases": [
        "CVE-2018-20999",
        "GHSA-gffv-5hr2-f9gj"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2018-12-20",
      "url": "https://github.com/brycx/orion/issues/46"
    },
    "versions": {
      "patched": [
        ">= 0.11.2"
      ]
    },
    "text": "\n\n# Flaw in streaming state reset() functions can create incorrect results.\n\nAffected versions of this crate did not properly reset a streaming state.\n\nResetting a streaming state, without finalising it first, creates incorrect results.\n \nThe flaw was corrected by not first checking if the state had already been reset, when calling reset().\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0145",
      "package": "heapless",
      "date": "2020-11-02",
      "url": "https://github.com/japaric/heapless/issues/181",
      "categories": [
        "memory-corruption",
        "memory-exposure"
      ],
      "keywords": [
        "use-after-free"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2020-36464",
        "GHSA-qgwf-r2jj-2ccv"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "affected": {
      "functions": {
        "heapless::vec::IntoIter::clone": [
          "<= 0.6"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ]
    },
    "text": "\n\n# Use-after-free when cloning a partially consumed `Vec` iterator\n\nThe `IntoIter` `Clone` implementation clones the whole underlying `Vec`.\nIf the iterator is partially consumed the consumed items will be copied, thus creating a use-after-free access.\n\nA proof of concept is available in the original bug report.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0039",
      "package": "simple-slab",
      "aliases": [
        "CVE-2020-35892",
        "CVE-2020-35893",
        "GHSA-438g-fx34-4h9m",
        "GHSA-hqc8-j86x-2764"
      ],
      "date": "2020-09-03",
      "url": "https://github.com/nathansizemore/simple-slab/issues/2"
    },
    "versions": {
      "patched": [
        ">= 0.3.3"
      ]
    },
    "text": "\n\n# `index()` allows out-of-bound read and `remove()` has off-by-one error\n\n`Slab::index()` does not perform the boundary checking, which leads to out-of-bound read access. `Slab::remove()` copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0054",
      "package": "directories",
      "date": "2020-10-16",
      "informational": "unmaintained",
      "url": "https://github.com/dirs-dev/directories-rs",
      "withdrawn": "2021-04-19"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# directories is unmaintained, use directories-next instead\n\nThe `directories` crate is not maintained any more;\nuse [`directories-next`](https://crates.io/crates/directories-next) instead.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0135",
      "package": "slock",
      "date": "2020-11-17",
      "url": "https://github.com/BrokenLamp/slock-rs/issues/2",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "aliases": [
        "CVE-2020-36455",
        "GHSA-83r8-p8v6-6gfm",
        "GHSA-mc36-5m36-hjh5"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": [
        ">= 0.2.0"
      ]
    },
    "text": "\n\n# Slock<T> allows sending non-Send types across thread boundaries\n\n`Slock<T>` unconditionally implements `Send`/`Sync`.\n\nAffected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0122",
      "package": "flatbuffers",
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2021-10-31",
      "url": "https://github.com/google/flatbuffers/issues/6627",
      "aliases": [
        "GHSA-3jch-9qgp-4844"
      ]
    },
    "versions": {
      "patched": [
        ">= 22.9.29"
      ]
    },
    "text": "\n\n# Generated code can read and write out of bounds in safe code\n\nCode generated by flatbuffers' compiler is `unsafe` but not marked as such.\nSee https://github.com/google/flatbuffers/issues/6627 for details.\n\nFor example, if generated code is used to decode malformed or untrusted input,\nundefined behavior (and thus security vulnerabilities) is possible even without\nthe use of the `unsafe` keyword, [violating the the meaning of \"safe\"](https://doc.rust-lang.org/std/keyword.unsafe.html#the-different-meanings-of-unsafe) code;\n\nAll users that use generated code by `flatbuffers` compiler are recommended to:\n1. not expose flatbuffer generated code as part of their public APIs\n2. audit their code and look for any usage of `follow`, `push`, or any method that uses them\n   (e.g. `self_follow`).\n3. Carefully go through the crates' documentation to understand which \"safe\" APIs are not\n   intended to be used.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0009",
      "package": "flatbuffers",
      "aliases": [
        "CVE-2020-35864",
        "GHSA-c9h5-hf8r-m97x"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-04-11",
      "url": "https://github.com/google/flatbuffers/issues/5825"
    },
    "affected": {
      "functions": {
        "flatbuffers::read_scalar": [
          ">= 0.4.0"
        ],
        "flatbuffers::read_scalar_at": [
          ">= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# `read_scalar` and `read_scalar_at` allow transmuting values without `unsafe` blocks\n\nThe `read_scalar` and `read_scalar_at` functions are unsound\nbecause they allow transmuting values without `unsafe` blocks.\n\nThe following example shows how to create a dangling reference:\n\n```\nfn main() {\n    #[derive(Copy, Clone, PartialEq, Debug)]\n    struct S(&'static str);\n    impl flatbuffers::EndianScalar for S {\n        fn to_little_endian(self) -> Self { self }\n        fn from_little_endian(self) -> Self { self }\n    }\n    println!(\"{:?}\", flatbuffers::read_scalar::<S>(&[1; std::mem::size_of::<S>()]));\n}\n```\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0028",
      "package": "flatbuffers",
      "aliases": [
        "CVE-2019-25004",
        "GHSA-gx73-2498-r55c"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2019-10-20",
      "url": "https://github.com/google/flatbuffers/issues/5530"
    },
    "affected": {
      "functions": {
        "flatbuffers::Follow::follow": [
          ">= 0.4.0",
          "<= 0.6.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.6.1"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# Unsound `impl Follow for bool`\n\nThe implementation of `impl Follow for bool` allows to reinterpret arbitrary bytes as a `bool`.\n\nIn Rust `bool` has stringent requirements for its in-memory representation. Use of this function\nallows to violate these requirements and invoke undefined behaviour in safe code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0045",
      "package": "actix-utils",
      "aliases": [
        "CVE-2020-35898",
        "GHSA-hhw2-pqhf-vmx2"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2020-01-08",
      "informational": "unsound",
      "url": "https://github.com/actix/actix-net/issues/160"
    },
    "versions": {
      "patched": [
        ">= 2.0.0"
      ]
    },
    "text": "\n\n# bespoke Cell implementation allows obtaining several mutable references to the same data\n\nThe custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0013",
      "package": "regex",
      "date": "2022-03-08",
      "url": "https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw",
      "categories": [
        "denial-of-service"
      ],
      "aliases": [
        "CVE-2022-24713",
        "GHSA-m5pq-gvj9-9vr8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
    },
    "versions": {
      "patched": [
        ">= 1.5.5"
      ]
    },
    "text": "\n\n# Regexes with large repetitions on empty sub-expressions take a very long time to parse\n\nThe Rust Security Response WG was notified that the `regex` crate did not\nproperly limit the complexity of the regular expressions (regex) it parses. An\nattacker could use this security issue to perform a denial of service, by\nsending a specially crafted regex to a service accepting untrusted regexes. No\nknown vulnerability is present when parsing untrusted input with trusted\nregexes.\n\nThis issue has been assigned CVE-2022-24713. The severity of this vulnerability\nis \"high\" when the `regex` crate is used to parse untrusted regexes. Other uses\nof the `regex` crate are not affected by this vulnerability.\n\n## Overview\n\nThe `regex` crate features built-in mitigations to prevent denial of service\nattacks caused by untrusted regexes, or untrusted input matched by trusted\nregexes. Those (tunable) mitigations already provide sane defaults to prevent\nattacks. This guarantee is documented and it's considered part of the crate's\nAPI.\n\nUnfortunately a bug was discovered in the mitigations designed to prevent\nuntrusted regexes to take an arbitrary amount of time during parsing, and it's\npossible to craft regexes that bypass such mitigations. This makes it possible\nto perform denial of service attacks by sending specially crafted regexes to\nservices accepting user-controlled, untrusted regexes.\n\n## Affected versions\n\nAll versions of the `regex` crate before or equal to 1.5.4 are affected by this\nissue. The fix is include starting from  `regex` 1.5.5.\n\n## Mitigations\n\nWe recommend everyone accepting user-controlled regexes to upgrade immediately\nto the latest version of the `regex` crate.\n\nUnfortunately there is no fixed set of problematic regexes, as there are\npractically infinite regexes that could be crafted to exploit this\nvulnerability. Because of this, we do not recommend denying known problematic\nregexes.\n\n## Acknowledgements\n\nWe want to thank Addison Crump for responsibly disclosing this to us according\nto the [Rust security policy][1], and for helping review the fix.\n\nWe also want to thank Andrew Gallant for developing the fix, and Pietro Albini\nfor coordinating the disclosure and writing this advisory.\n\n[1]: https://www.rust-lang.org/policies/security\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0050",
      "package": "interledger-packet",
      "date": "2022-08-04",
      "url": "https://github.com/interledger-rs/interledger-rs/issues/745",
      "references": [
        "https://github.com/interledger-rs/interledger-rs/pull/744"
      ],
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n# Interledger is Unmaintained\n\nInterledger family of crates is not being actively maintained anymore.\n\nThe owner of the published crate does not appear to be responsive.\n\nThere is an outstanding concern around username comparison.\n\nThis concern may or may not be resolved by bumping up the dependencies of the project.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0056",
      "package": "clipboard",
      "date": "2022-06-25",
      "informational": "unmaintained",
      "url": "https://github.com/aweinstock314/rust-clipboard/issues/91",
      "references": [
        "https://github.com/aweinstock314/rust-clipboard/issues/90"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# clipboard is Unmaintained\n\nLast release was almost 4 years ago and the repository with outstanding issues and pull requests seems to be abandoned by the maintainer.\n\nIn addition the sole maintainer account may be abandoned that may represent account takeover risk.\n\nCurrent outstanding issues include vulnerable dependencies that all together may mean that security issues may not be addressed now or in the future.\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n- [`arboard`](https://crates.io/crates/arboard)\n- [`clipboard-win`](https://crates.io/crates/clipboard-win) (Windows only)\n- [`copy-pasta`](https://crates.io/crates/copypasta)\n- [`x11-clipboard`](https://crates.io/crates/x11-clipboard) (Linux/BSD only)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0095",
      "package": "mopa",
      "date": "2021-06-01",
      "url": "https://github.com/chris-morgan/mopa/issues/13",
      "categories": [
        "memory-corruption",
        "memory-exposure",
        "code-execution"
      ],
      "keywords": [
        "transmute",
        "dyn"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45695",
        "GHSA-2gxj-qrp2-53jv",
        "GHSA-8mv5-7x95-7wcf"
      ]
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# `mopa` is technically unsound\nThe `mopa` crate redefines the deprecated `TraitObject` struct from `core::raw` like so:\n```rust\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n```\nThis is done to then transmute a reference to a trait object (`&dyn Trait` for any trait `Trait`) into this struct and retrieve the `data` field for the purpose of downcasting. This is used to implement `downcast_ref_unchecked()`, in terms of which `downcast_ref()` is also implemented. Same goes for mutable reference downcasting and `Box` downcasting.\n\nThe Rust compiler explicitly reserves the right to change the memory layout of `&dyn Trait` for any trait `Trait`. The worst case scenario is that it swaps `data` and `vtable`, making an executable location breach and compromisation of ASLR possible, since reads from `data` would read `vtable` instead. Likewise, arbitrary code execution is also theoretically possible if reads of `vtable` generated by the compiler read `data` instead.\n\nWhile, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.\n\nA potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0061",
      "package": "parity-wasm",
      "date": "2022-10-01",
      "url": "https://github.com/paritytech/parity-wasm/pull/334",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# Crate `parity-wasm` deprecated by the author\n\n[This PR](https://github.com/paritytech/parity-wasm/pull/334) explicitly deprecates `parity-wasm`.\nThe author recommends switching to [wasm-tools](https://github.com/bytecodealliance/wasm-tools).\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0044",
      "package": "rocket",
      "aliases": [
        "CVE-2021-29935",
        "GHSA-vcw4-8ph6-7vw8"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
      "date": "2021-02-09",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1534",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "memory-safety",
        "use-after-free"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.4.7"
      ]
    },
    "text": "\n\n# Use after free possible in `uri::Formatter` on panic\n\nAffected versions of this crate transmuted a `&str` to a `&'static str` before\npushing it into a `StackVec`, this value was then popped later in the same\nfunction.\n\nThis was assumed to be safe because the reference would be valid while the\nmethod's stack was active. In between the push and the pop, however, a function\n`f` was called that could invoke a user provided function.\n\nIf the user provided panicked, then the assumption used by the function was no\nlonger true and the transmute to `&'static` would create an illegal static\nreference to the string. This could result in a freed string being used during\n(such as in a `Drop` implementation) or after (e.g through `catch_unwind`) the\npanic unwinding.\n\nThis flaw was corrected in commit [e325e2f](https://github.com/SergioBenitez/Rocket/commit/e325e2fce4d9f9f392761e9fb58b418a48cef8bb)\nby using a guard object to ensure that the `&'static str` was dropped inside\nthe function.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0028",
      "package": "rocket",
      "aliases": [
        "CVE-2020-35882",
        "GHSA-8q2v-67v7-6vc6"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "date": "2020-05-27",
      "informational": "unsound",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1312"
    },
    "affected": {
      "functions": {
        "rocket::local::LocalRequest::clone": [
          "< 0.4.5, >= 0.4.0"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.4.5"
      ],
      "unaffected": [
        "< 0.4.0"
      ]
    },
    "text": "\n\n# `LocalRequest::clone` creates multiple mutable references to the same object\n\nThe affected version of `rocket` contains a `Clone` trait implementation of\n`LocalRequest` that reuses the pointer to inner `Request` object.\nThis causes data race in rare combinations of APIs if the original and the\ncloned objects are modified at the same time.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0112",
      "package": "tectonic_xdv",
      "date": "2021-02-17",
      "url": "https://github.com/tectonic-typesetting/tectonic/issues/752",
      "categories": [
        "memory-exposure"
      ],
      "informational": "unsound",
      "aliases": [
        "CVE-2021-45703",
        "GHSA-6692-8qqf-79jc",
        "GHSA-qwvx-c8j7-5g75"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.1.12"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB ('tectonic_xdv' crate)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe problem was fixed in commit `cdff034` by zero-initializing the buffer before passing it to a user-provided `Read` implementation.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0136",
      "package": "toolshed",
      "date": "2020-11-15",
      "url": "https://github.com/ratel-rust/toolshed/issues/12",
      "categories": [
        "memory-corruption",
        "thread-safety"
      ],
      "keywords": [
        "concurrency"
      ],
      "aliases": [
        "CVE-2020-36456",
        "GHSA-2r6q-6c8c-g762"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# CopyCell lacks bounds on its Send trait allowing for data races\n\n`CopyCell<T>` is a `Cell`-like type that is implemented for any type `T` that\nis `Copy`able. It's `Send` trait has no bounds on the contained type.\n\nAs not all `Copy`able types are thread safe, for example non-mutable references\nimplement the `Copy` trait, it is possible to send references to types with\ninterior mutability such as `Cell` across threads and cause data races.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2019-0032",
      "package": "crust",
      "date": "2019-11-21",
      "informational": "unmaintained",
      "url": "https://github.com/maidsafe/crust"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.32.1"
      ]
    },
    "text": "\n\n# crust repo has been archived; use libp2p instead\n\n** The `crust` crate repo was archived with no warning or explanation.**\n\nGiven that it was archived with no warning or successor, there's not an\nofficial replacement but [`rust-libp2p`](https://github.com/libp2p/rust-libp2p)\nlooks like it's got a similar feature set and is actively maintained.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0036",
      "package": "tree_magic",
      "date": "2023-04-11",
      "url": "https://github.com/aahancoc/tree_magic/issues/16",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# tree_magic is Unmaintained\n\n\nThe `tree_magic` crate is unmaintained. The author has archived the github\nrepository.\n\nAlternatives:\n\n- [tree_magic_mini](https://crates.io/crates/tree_magic_mini)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0017",
      "package": "postscript",
      "aliases": [
        "CVE-2021-26953",
        "GHSA-fhvc-gp6c-h2wx"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
      "date": "2021-01-30",
      "url": "https://github.com/bodoni/postscript/issues/1",
      "categories": [
        "memory-exposure"
      ]
    },
    "versions": {
      "patched": [
        ">= 0.14.0"
      ]
    },
    "text": "\n\n# `Read` on uninitialized buffer may cause UB (`impl Walue for Vec<u8>`)\n\nAffected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 8026286 by zero-initializing the buffer before handing to a user-provided `Read`.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0010",
      "package": "tiberius",
      "date": "2020-02-28",
      "informational": "unmaintained",
      "url": "https://github.com/RustSec/advisory-db/issues/261"
    },
    "versions": {
      "patched": [],
      "unaffected": [
        "> 0.3.2"
      ]
    },
    "text": "\n\n# tiberius is unmaintained\n\nThe author of `tiberius` has archived the GitHub repository and left the\nfollowing note:\n\n> I do not have the time to overhaul the library and do not intend to further\n> maintain the 0.3 version relying on the old futures ecosystem.\n\nSuggested alternatives are:\n\n- [`odbc`](https://crates.io/crates/odbc)\n- [`sqlx`](https://github.com/launchbadge/sqlx/issues/116) (forthcoming)\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0068",
      "package": "multihash",
      "aliases": [
        "CVE-2020-35909",
        "GHSA-h7qh-3h6f-w79p"
      ],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "date": "2020-11-08",
      "url": "https://github.com/multiformats/rust-multihash/pull/72",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [
        "parsing",
        "panic",
        "untrusted data"
      ]
    },
    "affected": {
      "functions": {
        "multihash::digests::MultihashRefGeneric::from_slice": [
          "< 0.11.3"
        ],
        "multihash::digests::MultihashGeneric::from_bytes": [
          "< 0.11.3"
        ]
      }
    },
    "versions": {
      "patched": [
        ">= 0.11.3"
      ],
      "unaffected": []
    },
    "text": "\n\n# Unexpected panic in multihash `from_slice` parsing code\n\nIn versions prior 0.11.3 it's possible to make `from_slice` panic by feeding it certain malformed input.\nIt's never documented that `from_slice` (and `from_bytes` which wraps it) can panic, and its' return type (`Result<Self, DecodeError>`) suggests otherwise.\n\nIn practice, `from_slice`/`from_bytes` is frequently used in networking code (for example [in rust-libp2p](https://github.com/libp2p/rust-libp2p/blob/7b415d5e7040e45c541f76f2c409e63d4d3249c6/core/src/peer_id.rs#L89)) and is being called with unsanitized data from untrusted sources.\nThis can allow attackers to cause DoS by causing an unexpected `panic` in the network client's code.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2018-0011",
      "package": "arrayfire",
      "aliases": [
        "CVE-2018-20998",
        "GHSA-69fv-gw6g-8ccg"
      ],
      "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "categories": [
        "memory-corruption"
      ],
      "date": "2018-12-18",
      "keywords": [
        "enum",
        "repr"
      ],
      "url": "https://github.com/arrayfire/arrayfire-rust/pull/177"
    },
    "affected": {
      "arch": [
        "x86_64"
      ],
      "os": [
        "windows"
      ]
    },
    "versions": {
      "patched": [
        ">= 3.6.0"
      ],
      "unaffected": [
        "<= 3.5.0"
      ]
    },
    "text": "\n\n# Enum repr causing potential memory corruption\n\nThe attribute repr() added to enums to be compatible with C-FFI caused\nmemory corruption on MSVC toolchain.\n\narrayfire crates <= version 3.5.0 do not have this issue when used with\nRust versions 1.27 or earlier. The issue only started to appear since\nRust version 1.28.\n\nThe issue seems to be interlinked with which version of Rust is being used.\n\nThe issue was fixed in crate 3.6.0.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0017",
      "package": "maligned",
      "date": "2023-03-04",
      "url": "https://github.com/tylerhawkes/maligned/issues/5",
      "informational": "unsound",
      "categories": [
        "memory-corruption"
      ],
      "keywords": [
        "unsound",
        "alloc",
        "align"
      ],
      "aliases": [
        "GHSA-wm8x-php5-hvq6"
      ]
    },
    "versions": {
      "patched": [],
      "unaffected": []
    },
    "affected": {
      "functions": {
        "maligned::align_first": [
          "*"
        ],
        "maligned::align_first_boxed": [
          "*"
        ],
        "maligned::align_first_boxed_cloned": [
          "*"
        ],
        "maligned::align_first_boxed_default": [
          "*"
        ]
      }
    },
    "text": "\n\n# `maligned::align_first` causes incorrect deallocation\n\n`maligned::align_first` manually allocates with an alignment larger than T, and then uses `Vec::from_raw_parts` on that allocation to get a `Vec<T>`.\n\n[`GlobalAlloc::dealloc`](https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc) requires that the `layout` argument must be the same layout that was used to allocate that block of memory.\n\nWhen deallocating, `Box` and `Vec` may not respect the specified alignment and can cause undefined behavior.\n"
  },
  {
    "advisory": {
      "id": "RUSTSEC-2024-0015",
      "package": "filesystem",
      "date": "2024-01-25",
      "url": "https://github.com/iredelmeier/filesystem-rs/pull/29",
      "informational": "unmaintained"
    },
    "versions": {
      "patched": []
    },
    "text": "\n\n# filesystem-rs may be implicitly unmaintained\n\nThe last release was over 5 years ago, and the last commit was over 4 years ago.\n\nThe maintainer(s) have not responded to a pull request to update dependencies that are themselves unmaintained, and which poses the question of maintenance.\n"
  }
]